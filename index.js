(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.karas = factory());
})(this, (function () { 'use strict';

  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var Node = /*#__PURE__*/function () {
    function Node() {
      this.__x = 0;
      this.__y = 0;
      this.__ox = 0; // relative造成的偏移量

      this.__oy = 0;
      this.__sx = 0;
      this.__sy = 0;
      this.__width = 0;
      this.__height = 0;
      this.__baseline = 0;
      this.__verticalBaseline = 0;
      this.__prev = null;
      this.__next = null;
      this.__parent = null;
      this.__domParent = null;
      this.__root = null;
      this.__host = null;
      this.__hostRoot = null;
      this.__virtualDom = null;
      this.__bbox = null;
      this.__filterBbox = null;
      this.__isDestroyed = true;
    }

    _createClass(Node, [{
      key: "__structure",
      value: function __structure(lv, j) {
        return this.__struct = {
          node: this,
          childIndex: j,
          lv: lv
        };
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout) {
        if (isLayout) {
          this.__x += diff;
        } else {
          this.__ox += diff;
        }

        this.__sx += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout) {
        if (isLayout) {
          this.__y += diff;
        } else {
          this.__oy += diff;
        }

        this.__sy += diff;
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        this.__isDestroyed = true;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "ox",
      get: function get() {
        return this.__ox;
      }
    }, {
      key: "oy",
      get: function get() {
        return this.__oy;
      }
    }, {
      key: "sx",
      get: function get() {
        return this.x + this.ox;
      }
    }, {
      key: "sy",
      get: function get() {
        return this.y + this.oy;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "prev",
      get: function get() {
        return this.__prev;
      }
    }, {
      key: "next",
      get: function get() {
        return this.__next;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "domParent",
      get: function get() {
        return this.__domParent;
      } // canvas/svg根节点

    }, {
      key: "root",
      get: function get() {
        return this.__root;
      } // component根节点

    }, {
      key: "host",
      get: function get() {
        return this.__host;
      } // 考虑高阶组件在内的component根节点

    }, {
      key: "hostRoot",
      get: function get() {
        return this.__hostRoot;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.__baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        return this.__verticalBaseline;
      }
    }, {
      key: "virtualDom",
      get: function get() {
        return this.__virtualDom;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__isDestroyed;
      }
    }, {
      key: "isReplaced",
      get: function get() {
        return false;
      }
    }]);

    return Node;
  }();

  var mode = {
    CANVAS: 0,
    SVG: 1,
    WEBGL: 2
  };

  var AUTO$8 = 0;
  var PX$b = 1;
  var PERCENT$a = 2;
  var NUMBER$6 = 3;
  var INHERIT$5 = 4;
  var DEG$5 = 5;
  var STRING$3 = 6;
  var RGBA$4 = 7;
  var REM$a = 8;
  var EM = 9;
  var VW$a = 10;
  var VH$a = 11;
  var VMAX$a = 12;
  var VMIN$a = 13;
  var GRADIENT$4 = 14;
  var o$4 = {
    AUTO: AUTO$8,
    PX: PX$b,
    PERCENT: PERCENT$a,
    NUMBER: NUMBER$6,
    INHERIT: INHERIT$5,
    DEG: DEG$5,
    STRING: STRING$3,
    RGBA: RGBA$4,
    REM: REM$a,
    EM: EM,
    VW: VW$a,
    VH: VH$a,
    VMAX: VMAX$a,
    VMIN: VMIN$a,
    GRADIENT: GRADIENT$4,
    // 特殊格式，color/fill/stroke用给ctx传值

    /**
     * 通用的格式化计算数值单位的方法，百分比/像素/REM/VW/auto和纯数字
     * @param v value
     * @returns 格式化好的[number, unit]
     */
    calUnit: function calUnit(v) {
      var n = parseFloat(v) || 0;

      if (/%$/.test(v)) {
        return {
          v: n,
          u: PERCENT$a
        };
      } else if (/px$/i.test(v)) {
        return {
          v: n,
          u: PX$b
        };
      } else if (/deg$/i.test(v)) {
        return {
          v: n,
          u: DEG$5
        };
      } else if (/rem$/i.test(v)) {
        return {
          v: n,
          u: REM$a
        };
      } else if (/vw$/i.test(v)) {
        return {
          v: n,
          u: VW$a
        };
      } else if (/vh$/i.test(v)) {
        return {
          v: n,
          u: VH$a
        };
      } else if (/em$/i.test(v)) {
        return {
          v: n,
          u: EM
        };
      } else if (/vw$/i.test(v)) {
        return {
          v: n,
          u: VW$a
        };
      } else if (/vh$/i.test(v)) {
        return {
          v: n,
          u: VH$a
        };
      } else if (/vmax$/i.test(v)) {
        return {
          v: n,
          u: VMAX$a
        };
      } else if (/vmin$/i.test(v)) {
        return {
          v: n,
          u: VMIN$a
        };
      }

      return {
        v: n,
        u: NUMBER$6
      };
    }
  };

  // 类型为引用防止json仿造
  var TYPE_VD$3 = Symbol('Dom');
  var TYPE_GM$3 = Symbol('Geom');
  var TYPE_CP$3 = Symbol('Component');
  var $$type = {
    TYPE_VD: TYPE_VD$3,
    TYPE_GM: TYPE_GM$3,
    TYPE_CP: TYPE_CP$3
  };

  // 生成4*4单位矩阵
  function identity$1() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  } // 矩阵a*b，固定两个matrix都是长度16


  function multiply$3(a, b) {
    if (!a && !b) {
      return identity$1();
    }

    if (isE$5(a)) {
      return b;
    }

    if (isE$5(b)) {
      return a;
    }

    var c = [];

    for (var i = 0; i < 4; i++) {
      var a0 = a[i] || 0;
      var a1 = a[i + 4] || 0;
      var a2 = a[i + 8] || 0;
      var a3 = a[i + 12] || 0;
      c[i] = a0 * b[0] + a1 * b[1] + a2 * b[2] + a3 * b[3];
      c[i + 4] = a0 * b[4] + a1 * b[5] + a2 * b[6] + a3 * b[7];
      c[i + 8] = a0 * b[8] + a1 * b[9] + a2 * b[10] + a3 * b[11];
      c[i + 12] = a0 * b[12] + a1 * b[13] + a2 * b[14] + a3 * b[15];
    }

    return c;
  } // 特殊优化，b为tfo，因此既只有12/13/14有值


  function multiplyTfo$1(m, x, y) {
    if (x === 0 && y === 0) {
      return m;
    }

    var res = m.slice(0);
    res[12] = m[0] * x + m[4] * y + m[12];
    res[13] = m[1] * x + m[5] * y + m[13];
    res[14] = m[2] * x + m[6] * y + m[14];
    return res;
  }

  function calPoint$2(point, m) {
    var _point = _slicedToArray(point, 4),
        x = _point[0],
        y = _point[1],
        z = _point[2],
        w = _point[3];

    if (w === undefined) {
      w = 1;
    }

    if (m && !isE$5(m)) {
      if (m.length === 16) {
        z = z || 0;

        var _m = _slicedToArray(m, 16),
            a1 = _m[0],
            b1 = _m[1],
            c1 = _m[2],
            d1 = _m[3],
            a2 = _m[4],
            b2 = _m[5],
            c2 = _m[6],
            d2 = _m[7],
            a3 = _m[8],
            b3 = _m[9],
            c3 = _m[10],
            d3 = _m[11],
            a4 = _m[12],
            b4 = _m[13],
            c4 = _m[14],
            d4 = _m[15];

        w *= x * d1 + y * d2 + z * d3 + d4;
        return [x * a1 + y * a2 + z * a3 + a4, x * b1 + y * b2 + z * b3 + b4, x * c1 + y * c2 + z * c3 + c4, w];
      } // 6位类型


      var _m2 = _slicedToArray(m, 6),
          a = _m2[0],
          b = _m2[1],
          c = _m2[2],
          d = _m2[3],
          e = _m2[4],
          f = _m2[5];

      return [a * x + c * y + e, b * x + d * y + f];
    }

    return [x, y, z, w];
  }
  /**
   * 初等行变换求3*3特定css的matrix方阵，一维6长度
   * https://blog.csdn.net/iloveas2014/article/details/82930946
   * @param m
   * @returns {number[]|*}
   */


  function inverse$1(m) {
    if (m.length === 16) {
      return inverse4(m);
    }

    var _m3 = _slicedToArray(m, 6),
        a = _m3[0],
        b = _m3[1],
        c = _m3[2],
        d = _m3[3],
        e = _m3[4],
        f = _m3[5];

    if (a === 1 && b === 0 && c === 0 && d === 1 && e === 0 && f === 0) {
      return m;
    }

    var divisor = a * d - b * c;

    if (divisor === 0) {
      return m;
    }

    return [d / divisor, -b / divisor, -c / divisor, a / divisor, (c * f - d * e) / divisor, (b * e - a * f) / divisor];
  } // 16位或者6位单位矩阵判断，空也认为是


  function isE$5(m) {
    if (!m || !m.length) {
      return true;
    }

    if (m.length === 16) {
      return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
    }

    return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;
  }
  /**
   * 求任意4*4矩阵的逆矩阵，行列式为 0 则返回单位矩阵兜底
   * 格式：matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4)
   * 参见: https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d()
   * 对应：
   * [
   *   a1,a2,a3,a4,
   *   b1,b2,b3,b4,
   *   c1,c2,c3,c4,
   *   d1,d2,d3,d4,
   * ]
   *
   * 根据公式 A* = |A|A^-1 来计算
   * A* 表示矩阵 A 的伴随矩阵，A^-1 表示矩阵 A 的逆矩阵，|A| 表示行列式的值
   *
   * @returns {number[]}
   */


  function inverse4(s) {
    var inv = [];
    inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];
    inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];
    inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];
    inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];
    inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];
    inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];
    inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];
    inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];
    inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];
    inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];
    inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];
    inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];
    inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];
    inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];
    inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];
    inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];
    var det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];

    if (det === 0) {
      return identity$1();
    }

    det = 1 / det;
    var d = [];

    for (var i = 0; i < 16; i++) {
      d[i] = inv[i] * det;
    }

    return d;
  } // 将4*4的16长度矩阵转成css/canvas的6位标准使用，忽略transform3d


  function m2m6(m) {
    return [m[0], m[1], m[4], m[5], m[12], m[13]];
  }

  function point2d$1(point) {
    var w = point[3];

    if (w && w !== 1) {
      point = point.slice(0, 2);
      point[0] /= w;
      point[1] /= w;
    }

    return point;
  }

  var mx = {
    identity: identity$1,
    multiply: multiply$3,
    multiplyTfo: multiplyTfo$1,
    calPoint: calPoint$2,
    point2d: point2d$1,
    inverse: inverse$1,
    isE: isE$5,
    m2m6: m2m6
  };

  var toString = {}.toString;

  function isType(type) {
    return function (obj) {
      return toString.call(obj) === '[object ' + type + ']';
    };
  }

  var isObject$2 = isType('Object');
  var isString$1 = isType('String');
  var isFunction$b = isType('Function');
  var isNumber$1 = isType('Number');
  var isBoolean = isType('Boolean');
  var isDate = isType('Date');
  var hasOwn = {}.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);

  function isNil$e(v) {
    return v === undefined || v === null;
  }

  function _joinSourceArray(arr) {
    var res = '';

    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];

      if (Array.isArray(item)) {
        res += _joinSourceArray(item);
      } else {
        res += stringify(item);
      }
    }

    return res;
  }

  function stringify(s) {
    if (isNil$e(s)) {
      return '';
    }

    return s.toString();
  }

  function encodeHtml(s, prop) {
    if (prop) {
      return s.replace(/"/g, '&quot;');
    }

    return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/ /g, '&nbsp;');
  } // 根元素专用


  function joinVirtualDom(vd) {
    var s = '<defs>';
    vd.defs.forEach(function (item) {
      s += joinDef$1(item);
    });
    s += '</defs><g>';
    vd.bb.forEach(function (item) {
      s += joinVd$1(item);
    });
    s += '</g><g';

    if (vd.conClip) {
      s += ' clip-path="' + vd.conClip + '"';
    }

    s += '>';
    (vd.children || []).forEach(function (item) {
      if (item.isMask) {
        return;
      }

      s += joinVd$1(item);
    });
    s += '</g>';
    return s;
  } // 普通元素


  function joinVd$1(vd) {
    if (vd.type === 'item' || vd.type === 'img') {
      var s = '';
      (vd.props || []).forEach(function (item) {
        s += ' ' + item[0] + '="' + item[1] + '"';
      });

      if (vd.tagName === 'text') {
        return '<text' + s + '>' + vd.content + '</text>';
      }

      return '<' + vd.tagName + s + '/>';
    } else if (vd.type === 'text') {
      var _s = ''; // text有许多lineBox

      (vd.children || []).forEach(function (item) {
        _s += joinVd$1(item);
      });
      return '<g>' + _s + '</g>';
    } else if (vd.type === 'dom' || vd.type === 'geom') {
      var _s2 = '<g>';
      vd.bb.forEach(function (item) {
        _s2 += joinVd$1(item);
      });
      _s2 += '</g><g';

      if (vd.conClip) {
        _s2 += ' clip-path="' + vd.conClip + '"';
      }

      _s2 += '>';
      (vd.children || []).forEach(function (item) {
        if (item.isMask) {
          return;
        }

        _s2 += joinVd$1(item);
      });
      _s2 += '</g>';
      var opacity = vd.opacity,
          transform = vd.transform,
          visibility = vd.visibility,
          mask = vd.mask,
          overflow = vd.overflow,
          filter = vd.filter,
          mixBlendMode = vd.mixBlendMode;
      return '<g' + (opacity !== 1 && opacity !== undefined ? ' opacity="' + opacity + '"' : '') + (transform ? ' transform="' + transform + '"' : '') + ' visibility="' + visibility + '"' + (mask ? ' mask="' + mask + '"' : '') + (overflow ? ' clip-path="' + overflow + '"' : '') + (filter || mixBlendMode ? ' style="' : '') + (filter ? 'filter:' + filter + ';' : '') + (mixBlendMode ? 'mix-blend-mode:' + mixBlendMode + ';' : '') + (filter || mixBlendMode ? '"' : '') + '>' + _s2 + '</g>';
    }
  }

  function joinDef$1(def) {
    var s = '<' + def.tagName + ' id="' + def.uuid + '"';

    if (def.tagName === 'mask' || def.tagName === 'clipPath') ; else if (def.tagName === 'filter') ; else {
      s += ' gradientUnits="userSpaceOnUse"';
    }

    (def.props || []).forEach(function (item) {
      s += ' ' + item[0] + '="' + item[1] + '"';
    });
    s += '>';
    (def.children || []).forEach(function (item) {
      s += joinItem(item);
    });
    s += '</' + def.tagName + '>';
    return s;
  }

  function joinItem(item) {
    var s = '<' + item.tagName;
    (item.props || []).forEach(function (item) {
      s += ' ' + item[0] + '="' + item[1] + '"';
    });
    s += '></' + item.tagName + '>';
    return s;
  }

  function rgba2int$3(color) {
    if (Array.isArray(color)) {
      return color;
    }

    var res = [];

    if (!color || color === 'transparent') {
      res = [0, 0, 0, 0];
    } else if (color.charAt(0) === '#') {
      color = color.slice(1);

      if (color.length === 3) {
        res.push(parseInt(color.charAt(0) + color.charAt(0), 16));
        res.push(parseInt(color.charAt(1) + color.charAt(1), 16));
        res.push(parseInt(color.charAt(2) + color.charAt(2), 16));
        res[3] = 1;
      } else if (color.length === 6) {
        res.push(parseInt(color.slice(0, 2), 16));
        res.push(parseInt(color.slice(2, 4), 16));
        res.push(parseInt(color.slice(4), 16));
        res[3] = 1;
      } else if (color.length === 8) {
        res.push(parseInt(color.slice(0, 2), 16));
        res.push(parseInt(color.slice(2, 4), 16));
        res.push(parseInt(color.slice(4, 6), 16));
        res.push(parseInt(color.slice(6), 16) / 255);
      } else {
        res[0] = res[1] = res[2] = 0;
        res[3] = 1;
      }
    } else {
      var c = color.match(/rgba?\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)(?:\s*,\s*([\d.]+))?\s*\)/i);

      if (c) {
        res = [parseInt(c[1]), parseInt(c[2]), parseInt(c[3])];

        if (!isNil$e(c[4])) {
          res[3] = parseFloat(c[4]);
        } else {
          res[3] = 1;
        }
      } else {
        res = [0, 0, 0, 0];
      }
    }

    return res;
  }

  function int2rgba$4(color) {
    if (Array.isArray(color)) {
      if (color.length === 3 || color.length === 4) {
        color[0] = Math.floor(Math.max(color[0], 0));
        color[1] = Math.floor(Math.max(color[1], 0));
        color[2] = Math.floor(Math.max(color[2], 0));

        if (color.length === 4) {
          color[3] = Math.max(color[3], 0);
          return 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',' + color[3] + ')';
        }

        return 'rgba(' + color[0] + ',' + color[1] + ',' + color[2] + ',1)';
      } // if(color.length === 4) {
      //   color = color.map((c, i) => i === 3 ? c : Math.floor(Math.max(0, c)));
      //   return 'rgba(' + joinArr(color, ',') + ')';
      // }
      // else if(color.length === 3) {
      //   color = color.map(c => Math.floor(c));
      //   return 'rgba(' + joinArr(color, ',') + ',1)';
      // }

    }

    return color || 'rgba(0,0,0,0)';
  }

  function int2invert(color) {
    if (Array.isArray(color)) {
      color = color.slice(0);
      color[0] = 255 - color[0];
      color[1] = 255 - color[1];
      color[2] = 255 - color[2];

      if (color.length === 4) {
        return 'rgba(' + joinArr$3(color, ',') + ')';
      } else if (color.length === 3) {
        return 'rgba(' + joinArr$3(color, ',') + ',1)';
      }
    }

    return 'rgba(0,0,0,0)';
  }

  function arr2hash(arr) {
    var hash = {};

    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];

      if (Array.isArray(item)) {
        hash[item[0]] = item[1];
      } else {
        for (var list = Object.keys(item), j = list.length - 1; j >= 0; j--) {
          var k = list[j];
          hash[k] = item[k];
        }
      }
    }

    return hash;
  }

  function hash2arr(hash) {
    if (Array.isArray(hash)) {
      return hash;
    }

    var arr = [];

    for (var list = Object.keys(hash), i = 0, len = list.length; i < len; i++) {
      var k = list[i];
      arr.push([k, hash[k]]);
    }

    return arr;
  }

  function clone$3(obj) {
    if (isNil$e(obj) || _typeof(obj) !== 'object') {
      return obj;
    } // parse递归会出现内部先返回解析好的json，外部parse不能clone


    if (obj.$$type === $$type.TYPE_VD || obj.$$type === $$type.TYPE_GM || obj.$$type === $$type.TYPE_CP) {
      return obj;
    }

    if (util.isDate(obj)) {
      return new Date(obj);
    }

    if (!isPlainObject(obj) && !Array.isArray(obj)) {
      return obj;
    }

    var n = Array.isArray(obj) ? [] : {};
    Object.keys(obj).forEach(function (i) {
      n[i] = clone$3(obj[i]);
    });
    return n;
  }
  /**
   * 简化的arr对比，arr中只有arr和其它类型，其它类型对比值或引用，arr递归
   * @param a
   * @param b
   * @returns {boolean}
   */


  function equalArr$2(a, b) {
    if (!a || !b) {
      return a === b;
    }

    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0, len = a.length; i < len; i++) {
      var ai = a[i];
      var bi = b[i];
      var isArrayA = Array.isArray(ai);
      var isArrayB = Array.isArray(bi);

      if (isArrayA && isArrayB) {
        if (!equalArr$2(ai, bi)) {
          return false;
        }
      } else if (isArrayA || isArrayB) {
        return false;
      } else if (ai !== bi) {
        return false;
      }
    }

    return true;
  }
  /**
   * 深度对比对象
   * @param a
   * @param b
   * @returns {boolean}
   */


  function equal$1(a, b) {
    if (a === b) {
      return true;
    }

    if (isObject$2(a) && isObject$2(b)) {
      var hash = {};

      for (var i = 0, arr = Object.keys(a), len = arr.length; i < len; i++) {
        var k = arr[i];

        if (!b.hasOwnProperty(k) || !equal$1(a[k], b[k])) {
          return false;
        }

        hash[k] = true;
      } // a没有b有则false


      for (var _i = 0, _arr = Object.keys(b), _len = _arr.length; _i < _len; _i++) {
        var _k = _arr[_i];

        if (!hash.hasOwnProperty(_k)) {
          return false;
        }
      }
    } else if (isDate(a) && isDate(b)) {
      return a.getTime() === b.getTime();
    } else if (Array.isArray(a) && Array.isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i2 = 0, _len2 = a.length; _i2 < _len2; _i2++) {
        if (!equal$1(a[_i2], b[_i2])) {
          return false;
        }
      }
    } else {
      return a === b;
    }

    return true;
  }

  function extend$3(target, source, keys) {
    if (source === null || _typeof(source) !== 'object') {
      return target;
    }

    if (!keys) {
      keys = Object.keys(source);
    }

    var i = 0;
    var len = keys.length;

    while (i < len) {
      var k = keys[i];
      target[k] = source[k];
      i++;
    }

    return target;
  }

  function joinArr$3(arr, split) {
    var s = arr.length ? arr[0] : '';

    for (var i = 1, len = arr.length; i < len; i++) {
      s += split + arr[i];
    }

    return s;
  }

  function transformBbox$1(bbox, matrix) {
    var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    if (matrix && !mx.isE(matrix)) {
      var _bbox = bbox,
          _bbox2 = _slicedToArray(_bbox, 4),
          x1 = _bbox2[0],
          y1 = _bbox2[1],
          x2 = _bbox2[2],
          y2 = _bbox2[3]; // 可能因filter的原因扩展范围


      if (dx) {
        x1 -= dx;
        x2 += dx;
      }

      if (dy) {
        y1 -= dy;
        y2 += dy;
      }

      var list = [x2, y1, x1, y2, x2, y2];
      var w;

      var _mx$calPoint = mx.calPoint([x1, y1], matrix);

      var _mx$calPoint2 = _slicedToArray(_mx$calPoint, 4);

      x1 = _mx$calPoint2[0];
      y1 = _mx$calPoint2[1];
      w = _mx$calPoint2[3];

      if (w && w !== 1) {
        x1 /= w;
        y1 /= w;
      }

      var xa = x1,
          ya = y1,
          xb = x1,
          yb = y1;

      for (var i = 0; i < 6; i += 2) {
        var x = list[i],
            y = list[i + 1];

        var _mx$calPoint3 = mx.calPoint([x, y], matrix);

        var _mx$calPoint4 = _slicedToArray(_mx$calPoint3, 4);

        x = _mx$calPoint4[0];
        y = _mx$calPoint4[1];
        w = _mx$calPoint4[3];

        if (w && w !== 1) {
          x /= w;
          y /= w;
        }

        xa = Math.min(xa, x);
        xb = Math.max(xb, x);
        ya = Math.min(ya, y);
        yb = Math.max(yb, y);
      }

      bbox = [xa, ya, xb, yb];
    } else if (dx || dy) {
      bbox = bbox.slice(0);
      bbox[0] -= dx;
      bbox[1] -= dy;
      bbox[2] += dx;
      bbox[3] += dy;
    }

    return bbox;
  }

  function isPlainObject(obj) {
    if (!obj || toString.call(obj) !== '[object Object]') {
      return false;
    }

    var proto = Object.getPrototypeOf(obj);

    if (!proto) {
      return true;
    }

    var Ctor = hasOwn.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor === 'function' && fnToString.call(Ctor) === ObjectFunctionString;
  }

  function assignMatrix$2(t, v) {
    t[0] = v[0];
    t[1] = v[1];
    t[2] = v[2];
    t[3] = v[3];
    t[4] = v[4];
    t[5] = v[5];
    t[6] = v[6];
    t[7] = v[7];
    t[8] = v[8];
    t[9] = v[9];
    t[10] = v[10];
    t[11] = v[11];
    t[12] = v[12];
    t[13] = v[13];
    t[14] = v[14];
    t[15] = v[15];
    return t;
  }

  function prefixHex(s) {
    if (s.length === 1) {
      return '0' + s;
    }

    return s;
  }

  function replaceRgba2Hex$1(s) {
    return (s || '').replace(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([\d.]+)\s*)?\)/ig, function ($0, $1, $2, $3, $4) {
      var res = '#' + prefixHex(parseInt($1).toString(16)) + prefixHex(parseInt($2).toString(16)) + prefixHex(parseInt($3).toString(16));

      if ($4) {
        res += prefixHex(Math.floor(parseFloat($4) * 255).toString(16));
      }

      return res;
    });
  }

  var util = {
    isObject: isObject$2,
    isString: isString$1,
    isFunction: isFunction$b,
    isNumber: isNumber$1,
    isBoolean: isBoolean,
    isDate: isDate,
    isNil: isNil$e,
    isPrimitive: function isPrimitive(v) {
      return util.isNil(v) || util.isBoolean(v) || util.isString(v) || util.isNumber(v);
    },
    // css中常用undefined/null表示auto本身
    isAuto: function isAuto(v) {
      return isNil$e(v) || v === 'auto';
    },
    isPlainObject: isPlainObject,
    stringify: stringify,
    joinSourceArray: function joinSourceArray(arr) {
      return _joinSourceArray(arr);
    },
    encodeHtml: encodeHtml,
    joinVirtualDom: joinVirtualDom,
    joinVd: joinVd$1,
    joinDef: joinDef$1,
    rgba2int: rgba2int$3,
    int2rgba: int2rgba$4,
    int2invert: int2invert,
    arr2hash: arr2hash,
    hash2arr: hash2arr,
    clone: clone$3,
    equalArr: equalArr$2,
    equal: equal$1,
    extend: extend$3,
    joinArr: joinArr$3,
    transformBbox: transformBbox$1,
    assignMatrix: assignMatrix$2,
    prefixHex: prefixHex,
    replaceRgba2Hex: replaceRgba2Hex$1
  };

  var debug = {
    flag: false
  };

  var ca = {
    alpha: true,
    antialias: true,
    premultipliedAlpha: true,
    preserveDrawingBuffer: true // depth: true,
    // stencil: true,

  };

  var calPoint$1 = mx.calPoint;
  /**
   * 初始化 shader
   * @param gl GL context
   * @param vshader vertex shader (string)
   * @param fshader fragment shader (string)
   * @return program, if the program object was created and successfully made current
   */

  function initShaders(gl, vshader, fshader) {
    var program = createProgram(gl, vshader, fshader);

    if (!program) {
      throw new Error('Failed to create program');
    } // 要开启透明度，用以绘制透明的图形


    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
    return program;
  }
  /**
   * Create the linked program object
   * @param gl GL context
   * @param vshader a vertex shader program (string)
   * @param fshader a fragment shader program (string)
   * @return created program object, or null if the creation has failed
   */


  function createProgram(gl, vshader, fshader) {
    // Create shader object
    var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
    var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);

    if (!vertexShader || !fragmentShader) {
      return null;
    } // Create a program object


    var program = gl.createProgram();

    if (!program) {
      return null;
    }

    program.vertexShader = vertexShader;
    program.fragmentShader = fragmentShader; // Attach the shader objects

    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader); // Link the program object

    gl.linkProgram(program); // Check the result of linking

    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);

    if (!linked) {
      var error = gl.getProgramInfoLog(program);
      gl.deleteProgram(program);
      gl.deleteShader(fragmentShader);
      gl.deleteShader(vertexShader);
      throw new Error('Failed to link program: ' + error);
    }

    return program;
  }
  /**
   * Create a shader object
   * @param gl GL context
   * @param type the type of the shader object to be created
   * @param source shader program (string)
   * @return created shader object, or null if the creation has failed.
   */


  function loadShader(gl, type, source) {
    // Create shader object
    var shader = gl.createShader(type);

    if (shader == null) {
      throw new Error('unable to create shader');
    } // Set the shader program


    gl.shaderSource(shader, source); // Compile the shader

    gl.compileShader(shader); // Check the result of compilation

    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

    if (!compiled) {
      var error = gl.getShaderInfoLog(shader);
      gl.deleteShader(shader);
      throw new Error('Failed to compile shader: ' + error);
    }

    return shader;
  }

  function convertCoords2Gl(_ref, cx, cy, revertY) {
    var _ref2 = _slicedToArray(_ref, 4),
        x = _ref2[0],
        y = _ref2[1],
        z = _ref2[2],
        w = _ref2[3];

    if (z === undefined) {
      z = 0;
    }

    if (w === undefined) {
      w = 1;
    }

    if (w && w !== 1) {
      x /= w;
      y /= w;
      z /= w;
    }

    if (x === cx) {
      x = 0;
    } else {
      x = (x - cx) / cx;
    }

    if (y === cy) {
      y = 0;
    } else {
      y = (y - cy) / cy;

      if (revertY) {
        y = -y;
      }
    }

    return [x * w, y * w, z * w, w];
  }

  function createTexture(gl, tex, n, width, height) {
    var texture = gl.createTexture();
    bindTexture(gl, texture, n); // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, -1);

    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true); // 传入高宽时是绑定fbo，且tex一定为null

    if (width && height) {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, tex);
    } // 普通将canvas对象作为纹理
    else {
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, tex);
    }

    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    return texture;
  }

  function bindTexture(gl, texture, n) {
    gl.activeTexture(gl['TEXTURE' + n]);
    gl.bindTexture(gl.TEXTURE_2D, texture);
  }
  /**
   * texCache集满纹理上传占用最多可用纹理单元后，进行批量顺序绘制
   * 将所有dom的矩形顶点（经过transform变换后的）、贴图坐标、透明度存入3个buffer中，
   * 然后相同纹理单元的形成一批，设置uniform的纹理单元号进行绘制，如此循环
   * @param gl
   * @param list
   * @param hash
   * @param cx
   * @param cy
   * @param revertY
   */


  function drawTextureCache(gl, list, hash, cx, cy, revertY) {
    var length = list.length;
    var vtPoint = new Float32Array(length * 24),
        vtTex = new Float32Array(length * 12),
        vtOpacity = new Float32Array(length * 6);
    var lastChannel; // 上一个dom的单元号

    var record = [0]; // [num, channel]每一批的数量和单元号记录

    var stack = [record]; // 所有批的数据记录集合

    list.forEach(function (item, i) {
      var _item = _slicedToArray(item, 5),
          cache = _item[0],
          opacity = _item[1],
          matrix = _item[2],
          dx = _item[3],
          dy = _item[4];

      if (i) {
        var channel = hash[cache.page.uuid]; // 和上一个单元号不同时，生成新的批次记录

        if (lastChannel !== channel) {
          lastChannel = channel;
          record = [0, lastChannel];
          stack.push(record);
        }
      } else {
        lastChannel = hash[cache.page.uuid];
        record[1] = lastChannel;
      }

      var x = cache.x,
          y = cache.y,
          width = cache.width,
          height = cache.height,
          page = cache.page,
          bbox = cache.bbox; // 计算顶点坐标和纹理坐标，转换[0,1]对应关系

      var bx = bbox[0],
          by = bbox[1];
      var xa = bx + (dx || 0),
          ya = by + height + (dy || 0);
      var xb = bx + width + (dx || 0),
          yb = by + (dy || 0);

      var _calPoint = calPoint$1([xa, ya], matrix),
          _calPoint2 = _slicedToArray(_calPoint, 4),
          x1 = _calPoint2[0],
          y1 = _calPoint2[1],
          w1 = _calPoint2[3];

      var _calPoint3 = calPoint$1([xb, ya], matrix),
          _calPoint4 = _slicedToArray(_calPoint3, 4),
          x2 = _calPoint4[0],
          y2 = _calPoint4[1],
          w2 = _calPoint4[3];

      var _calPoint5 = calPoint$1([xb, yb], matrix),
          _calPoint6 = _slicedToArray(_calPoint5, 4),
          x3 = _calPoint6[0],
          y3 = _calPoint6[1],
          w3 = _calPoint6[3];

      var _calPoint7 = calPoint$1([xa, yb], matrix),
          _calPoint8 = _slicedToArray(_calPoint7, 4),
          x4 = _calPoint8[0],
          y4 = _calPoint8[1],
          w4 = _calPoint8[3];

      var _convertCoords2Gl = convertCoords2Gl([x1, y1, 0, w1], cx, cy, revertY);

      var _convertCoords2Gl2 = _slicedToArray(_convertCoords2Gl, 2);

      x1 = _convertCoords2Gl2[0];
      y1 = _convertCoords2Gl2[1];

      var _convertCoords2Gl3 = convertCoords2Gl([x2, y2, 0, w2], cx, cy, revertY);

      var _convertCoords2Gl4 = _slicedToArray(_convertCoords2Gl3, 2);

      x2 = _convertCoords2Gl4[0];
      y2 = _convertCoords2Gl4[1];

      var _convertCoords2Gl5 = convertCoords2Gl([x3, y3, 0, w3], cx, cy, revertY);

      var _convertCoords2Gl6 = _slicedToArray(_convertCoords2Gl5, 2);

      x3 = _convertCoords2Gl6[0];
      y3 = _convertCoords2Gl6[1];

      var _convertCoords2Gl7 = convertCoords2Gl([x4, y4, 0, w4], cx, cy, revertY);

      var _convertCoords2Gl8 = _slicedToArray(_convertCoords2Gl7, 2);

      x4 = _convertCoords2Gl8[0];
      y4 = _convertCoords2Gl8[1];
      // vtPoint.push(x1, y1, 0, w1, x4, y4, 0, w4, x2, y2, 0, w2, x4, y4, 0, w4, x2, y2, 0, w2, x3, y3, 0, w3);
      var j = i * 24;
      vtPoint[j] = x1;
      vtPoint[j + 1] = y1;
      vtPoint[j + 3] = w1;
      vtPoint[j + 4] = x4;
      vtPoint[j + 5] = y4;
      vtPoint[j + 7] = w4;
      vtPoint[j + 8] = x2;
      vtPoint[j + 9] = y2;
      vtPoint[j + 11] = w2;
      vtPoint[j + 12] = x4;
      vtPoint[j + 13] = y4;
      vtPoint[j + 15] = w4;
      vtPoint[j + 16] = x2;
      vtPoint[j + 17] = y2;
      vtPoint[j + 19] = w2;
      vtPoint[j + 20] = x3;
      vtPoint[j + 21] = y3;
      vtPoint[j + 23] = w3;
      var tx1 = x / page.width,
          ty1 = (y + height) / page.height;
      var tx2 = (x + width) / page.width,
          ty2 = y / page.height; // vtTex.push(tx1, ty1, tx1, ty2, tx2, ty1, tx1, ty2, tx2, ty1, tx2, ty2);

      j = i * 12;
      vtTex[j] = tx1;
      vtTex[j + 1] = ty1;
      vtTex[j + 2] = tx1;
      vtTex[j + 3] = ty2;
      vtTex[j + 4] = tx2;
      vtTex[j + 5] = ty1;
      vtTex[j + 6] = tx1;
      vtTex[j + 7] = ty2;
      vtTex[j + 8] = tx2;
      vtTex[j + 9] = ty1;
      vtTex[j + 10] = tx2;
      vtTex[j + 11] = ty2; // vtOpacity.push(opacity, opacity, opacity, opacity, opacity, opacity);

      j = i * 6;
      vtOpacity[j] = opacity;
      vtOpacity[j + 1] = opacity;
      vtOpacity[j + 2] = opacity;
      vtOpacity[j + 3] = opacity;
      vtOpacity[j + 4] = opacity;
      vtOpacity[j + 5] = opacity;
      record[0]++;
    }); // 顶点buffer

    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vtPoint, gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(gl.program, 'a_position');
    gl.vertexAttribPointer(a_position, 4, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vtTex, gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // opacity buffer

    var opacityBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, vtOpacity, gl.STATIC_DRAW);
    var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
    gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_opacity); // 纹理单元

    var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
    var count = 0; // 循环按批次渲染

    stack.forEach(function (record) {
      var _record = _slicedToArray(record, 2),
          num = _record[0],
          channel = _record[1];

      gl.uniform1i(u_texture, channel);
      num *= 6;
      gl.drawArrays(gl.TRIANGLES, count, num);
      count += num;
    });
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.deleteBuffer(opacityBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    gl.disableVertexAttribArray(a_opacity);
  }
  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据cacheTotal生成cacheFilter，按照css规范的优化方法执行3次，避免卷积核扩大3倍性能慢
   * x/y方向分开执行，加速性能，计算次数由d*d变为d+d，d为卷积核大小
   * spread由d和sigma计算得出，d由sigma计算得出，sigma即css的blur()参数
   * 规范的优化方法对d的值分奇偶优化，这里再次简化，d一定是奇数，即卷积核大小
   * i和j为total和filter的纹理单元，3次执行（x/y合起来算1次）需互换单元，来回执行源和结果
   * 由total变为filter时cache会各方向上扩展spread的大小到width/height
   * 因此第一次绘制时坐标非1，后面则固定1
   * @param gl
   * @param program
   * @param frameBuffer
   * @param tex1 初次绘制目标纹理
   * @param tex2 初次绘制源纹理
   * @param i 初次绘制目标纹理单元
   * @param j 初次绘制源纹理单元
   * @param width
   * @param height
   * @param spread
   * @param widthNew
   * @param heightNew
   * @param cx
   * @param cy
   */


  function drawBlur(gl, program, frameBuffer, tex1, tex2, i, j, width, height, spread, widthNew, heightNew, cx, cy) {
    // 第一次将total绘制到blur上，此时尺寸存在spread差值，因此不加模糊防止坐标计算问题，仅作为扩展纹理尺寸
    var _convertCoords2Gl9 = convertCoords2Gl([spread, height + spread, 0, 1], cx, cy, false),
        _convertCoords2Gl10 = _slicedToArray(_convertCoords2Gl9, 2),
        x1 = _convertCoords2Gl10[0],
        y2 = _convertCoords2Gl10[1];

    var _convertCoords2Gl11 = convertCoords2Gl([width + spread, spread, 0, 1], cx, cy, false),
        _convertCoords2Gl12 = _slicedToArray(_convertCoords2Gl11, 2),
        x2 = _convertCoords2Gl12[0],
        y1 = _convertCoords2Gl12[1]; // 顶点buffer


    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // direction全0，即无模糊，此时只是进行扩展尺寸操作，还没到模糊所以传0

    var u_direction = gl.getUniformLocation(program, 'u_direction');
    gl.uniform2f(u_direction, 0, 0); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, j);
    gl.drawArrays(gl.TRIANGLES, 0, 6); // fbo绑定切换纹理对象和单元索引，同时注意不能向源纹理绘制，因为源是cacheTotal，需要重新生成一个，y方向再来一次

    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    /**
     * 反复执行共3次，坐标等均不变，只是切换fbo绑定对象和纹理单元
     * 注意max和ratio的设置，当是100尺寸的正方形时，传给direction的始终为1
     * 当正方形<100时，direction相应地要扩大相对于100的倍数，反之则缩小，如此为了取相邻点坐标时是+-1
     * 当非正方形时，长轴一端为基准值不变，短的要二次扩大比例倍数
     */

    var max = 100 / Math.max(widthNew, heightNew);
    var ratio = widthNew / heightNew;
    var recycle = []; // 3次过程中新生成的中间纹理需要回收

    for (var k = 0; k < 3; k++) {
      var tex3 = createTexture(gl, null, j, widthNew, heightNew);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex3, 0);

      if (widthNew >= heightNew) {
        gl.uniform2f(u_direction, max, 0);
      } else {
        gl.uniform2f(u_direction, max * ratio, 0);
      }

      gl.uniform1i(u_texture, i);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      recycle.push(tex1);
      var tex4 = createTexture(gl, null, i, widthNew, heightNew);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex4, 0);

      if (widthNew >= heightNew) {
        gl.uniform2f(u_direction, 0, max * ratio);
      } else {
        gl.uniform2f(u_direction, 0, max);
      }

      gl.uniform1i(u_texture, j);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      tex1 = tex4;
      recycle.push(tex3);
    } // 回收


    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    recycle.forEach(function (item) {
      return gl.deleteTexture(item);
    });
    return tex1;
  }

  function drawCm(gl, program, i, m) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, i); // matrix

    var u_m = gl.getUniformLocation(program, 'u_m');
    gl.uniform1fv(u_m, new Float32Array(m));
    gl.drawArrays(gl.TRIANGLES, 0, 6); // 回收

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
  }
  /**
   * 根据total/filter生成overflow
   * @param gl
   * @param i 输入纹理单元
   * @param dx 二者偏移值
   * @param dy
   * @param width 最终大小
   * @param height
   * @param w 输入纹理大小
   * @param h
   */


  function drawOverflow(gl, i, dx, dy, width, height, w, h) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(gl.programOverflow, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer，原本大小width/height，使用其中的w/h

    var x1 = dx / w,
        y1 = dy / h,
        x2 = (width + dx) / w,
        y2 = (height + dy) / h;
    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([x1, y1, x1, y2, x2, y1, x1, y2, x2, y1, x2, y2]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(gl.programOverflow, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(gl.programOverflow, 'u_texture');
    gl.uniform1i(u_texture, i);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
  }

  function drawMask(gl, i, j, program) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture1 = gl.getUniformLocation(program, 'u_texture1');
    gl.uniform1i(u_texture1, j);
    var u_texture2 = gl.getUniformLocation(program, 'u_texture2');
    gl.uniform1i(u_texture2, i);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
  }

  function drawMbm(gl, program, i, j, W, H) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture1 = gl.getUniformLocation(program, 'u_texture1');
    gl.uniform1i(u_texture1, i);
    var u_texture2 = gl.getUniformLocation(program, 'u_texture2');
    gl.uniform1i(u_texture2, j);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
  }

  function drawDropShadow(gl, program, frameBuffer, tex1, tex2, i, j, width, height, color) {
    // 顶点buffer
    var pointBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
    var a_position = gl.getAttribLocation(program, 'a_position');
    gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_position); // 纹理buffer

    var texBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
    var a_texCoords = gl.getAttribLocation(program, 'a_texCoords');
    gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(a_texCoords); // 纹理单元

    var u_texture = gl.getUniformLocation(program, 'u_texture');
    gl.uniform1i(u_texture, j); // color

    var u_color = gl.getUniformLocation(program, 'u_color');
    gl.uniform1fv(u_color, new Float32Array([color[0] / 255, color[1] / 255, color[2] / 255, color[3]]));
    gl.drawArrays(gl.TRIANGLES, 0, 6); // 回收

    gl.deleteBuffer(pointBuffer);
    gl.deleteBuffer(texBuffer);
    gl.disableVertexAttribArray(a_position);
    gl.disableVertexAttribArray(a_texCoords);
    return tex1;
  }

  var webgl = {
    initShaders: initShaders,
    createTexture: createTexture,
    bindTexture: bindTexture,
    drawTextureCache: drawTextureCache,
    drawBlur: drawBlur,
    drawOverflow: drawOverflow,
    drawMask: drawMask,
    drawMbm: drawMbm,
    drawCm: drawCm,
    drawDropShadow: drawDropShadow
  };

  var SPF = 1000 / 60;
  var CANVAS$5 = {};
  var WEBGL$5 = {};
  var CANVAS_LIST = [];
  var WEBGL_LIST = [];
  var SUPPORT_OFFSCREEN_CANVAS = typeof OffscreenCanvas === 'function' && util.isFunction(OffscreenCanvas.prototype.getContext);

  function cache(key, width, height, hash, message) {
    var o;

    if (!key) {
      var target = hash === CANVAS$5 ? CANVAS_LIST : WEBGL_LIST;

      if (target.length) {
        o = target.pop();
      } else {
        o = !debug.flag && SUPPORT_OFFSCREEN_CANVAS ? new OffscreenCanvas(width, height) : document.createElement('canvas');
      }
    } else if (!hash[key]) {
      o = hash[key] = !debug.flag && SUPPORT_OFFSCREEN_CANVAS ? new OffscreenCanvas(width, height) : document.createElement('canvas');
    } else {
      o = hash[key];
    }

    o.width = width;
    o.height = height;

    if (debug.flag) {
      o.style.width = width + 'px';
      o.style.height = height + 'px';
      o.setAttribute('type', hash === CANVAS$5 ? 'canvas' : 'webgl');

      if (key) {
        o.setAttribute('key', key);
      }

      if (message) {
        o.setAttribute('message', message);
      }

      document.body.appendChild(o);
    }

    var ctx;

    if (hash === CANVAS$5) {
      ctx = o.getContext('2d');
    } else {
      ctx = o.getContext('webgl', ca) || o.getContext('experimental-webgl', ca);
    }

    return {
      canvas: o,
      ctx: ctx,
      enabled: true,
      available: true,
      release: function release() {
        if (!key && this.available) {
          if (hash === CANVAS$5) {
            CANVAS_LIST.push(this.canvas);
          } else {
            WEBGL_LIST.push(this.canvas);
          }
        }

        this.available = false;
      }
    };
  }

  function cacheCanvas(key, width, height, message) {
    return cache(key, width, height, CANVAS$5, message);
  }

  function cacheWebgl(key, width, height, message) {
    return cache(key, width, height, WEBGL$5, message);
  }

  var IMG = {};
  var INIT = 0;
  var LOADING = 1;
  var LOADED = 2;
  var FONT = {};
  var COMPONENT = {};
  var div;
  var SUPPORT_FONT = {};
  var defaultFontFamilyData;

  function createDiv() {
    div = document.createElement('div');
    div.style.position = 'absolute';
    div.style.left = '99999px';
    div.style.top = '-99999px';
    div.style.visibility = 'hidden';
    div.style.whiteSpace = 'nowrap';
    document.body.appendChild(div);
  }

  var inject = {
    measureTextSync: function measureTextSync(str, ff, fs, fw, isUpright) {
      if (!div) {
        createDiv();
      }

      div.style.fontFamily = ff;
      div.style.fontSize = fs + 'px';
      div.style.fontWeight = fw;

      if (isUpright) {
        div.style.writingMode = 'vertical-lr';
      } else {
        div.style.writingMode = 'horizontal-tb';
      }

      div.innerHTML = str.replace(/</g, '&lt;').replace(/[ \n]/g, '&nbsp;');

      if (isUpright) {
        return parseFloat(window.getComputedStyle(div, null).height);
      } else {
        return parseFloat(window.getComputedStyle(div, null).width);
      }
    },
    measureTextListMax: function measureTextListMax(str, ff, fs, fw) {
      if (!div) {
        createDiv();
      }

      div.style.fontFamily = ff;
      div.style.fontSize = fs + 'px';
      div.style.fontWeight = fw;
      var s = '';

      for (var i = 0, len = str.length; i < len; i++) {
        s += '<span style="position:absolute">' + str.charAt(i).replace('<', '&lt;').replace(/[ \n]/, '&nbsp;') + '</span>';
      }

      div.innerHTML = s;
      var max = 0;
      var cns = div.childNodes;

      for (var _i = 0, _len = cns.length; _i < _len; _i++) {
        var node = cns[_i]; // clientWidth只返回ceil整数，精度必须用getComputedStyle

        max = Math.max(max, parseFloat(window.getComputedStyle(node, null).width));
      }

      return max;
    },
    IMG: IMG,
    INIT: INIT,
    LOADED: LOADED,
    LOADING: LOADING,
    measureImg: function measureImg(url, cb) {
      if (Array.isArray(url)) {
        if (!url.length) {
          return cb && cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.measureImg(item, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb && cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Measure img invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      var cache = IMG[url] = IMG[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        cache.state = LOADING;
        cb && cache.task.push(cb);
        var img = new Image();

        img.onload = function () {
          cache.state = LOADED;
          cache.success = true;
          cache.width = img.width;
          cache.height = img.height;
          cache.source = img;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
        };

        img.onerror = function (e) {
          cache.state = LOADED;
          cache.success = false;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
        };

        if (url.substr(0, 5) !== 'data:') {
          var host = /^(?:\w+:)?\/\/([^/:]+)/.exec(url);

          if (host) {
            if (typeof location === 'undefined' || location.hostname !== host[1]) {
              img.crossOrigin = 'anonymous';
            }
          }
        }

        img.src = url;

        if (debug.flag && typeof document !== 'undefined') {
          document.body.appendChild(img);
        }
      }
    },
    warn: function warn(s) {
      console.warn(s);
    },
    error: function error(s) {
      console.error(s);
    },
    requestAnimationFrame: function (_requestAnimationFrame) {
      function requestAnimationFrame(_x) {
        return _requestAnimationFrame.apply(this, arguments);
      }

      requestAnimationFrame.toString = function () {
        return _requestAnimationFrame.toString();
      };

      return requestAnimationFrame;
    }(function (cb) {
      if (!cb) {
        return;
      }

      var res;

      if (typeof requestAnimationFrame !== 'undefined') {
        inject.requestAnimationFrame = requestAnimationFrame.bind(window);
        res = requestAnimationFrame(cb);
      } else {
        res = setTimeout(cb, SPF);

        inject.requestAnimationFrame = function (cb) {
          return setTimeout(cb, SPF);
        };
      }

      return res;
    }),
    cancelAnimationFrame: function (_cancelAnimationFrame) {
      function cancelAnimationFrame(_x2) {
        return _cancelAnimationFrame.apply(this, arguments);
      }

      cancelAnimationFrame.toString = function () {
        return _cancelAnimationFrame.toString();
      };

      return cancelAnimationFrame;
    }(function (id) {
      var res;

      if (typeof cancelAnimationFrame !== 'undefined') {
        inject.cancelAnimationFrame = cancelAnimationFrame.bind(window);
        res = cancelAnimationFrame(id);
      } else {
        res = clearTimeout(id);

        inject.cancelAnimationFrame = function (id) {
          return clearTimeout(id);
        };
      }

      return res;
    }),
    now: function now() {
      if (typeof performance !== 'undefined') {
        inject.now = function () {
          return Math.floor(performance.now());
        };

        return Math.floor(performance.now());
      }

      inject.now = Date.now.bind(Date);
      return Date.now();
    },
    hasCacheCanvas: function hasCacheCanvas(key) {
      return key && CANVAS$5.hasOwnProperty(key);
    },
    getCacheCanvas: function getCacheCanvas(width, height, key, message) {
      return cacheCanvas(key, width, height, message);
    },
    releaseCacheCanvas: function releaseCacheCanvas(o) {
      CANVAS_LIST.push(o);
    },
    delCacheCanvas: function delCacheCanvas(key) {
      key && delete CANVAS$5[key];
    },
    hasCacheWebgl: function hasCacheWebgl(key) {
      return key && WEBGL$5.hasOwnProperty(key);
    },
    getCacheWebgl: function getCacheWebgl(width, height, key, message) {
      return cacheWebgl(key, width, height, message);
    },
    releaseCacheWebgl: function releaseCacheWebgl(o) {
      WEBGL_LIST.push(o);
    },
    delCacheWebgl: function delCacheWebgl(key) {
      key && delete WEBGL$5[key];
    },
    isDom: function isDom(o) {
      if (o) {
        if (util.isString(o)) {
          return true;
        }

        if (typeof window !== 'undefined' && window.Element && o instanceof window.Element) {
          return true;
        }

        if (typeof window !== 'undefined' && window.OffscreenCanvas && o instanceof window.OffscreenCanvas) {
          return true;
        } // worker


        if (typeof self !== 'undefined' && self.OffscreenCanvas && o instanceof self.OffscreenCanvas) {
          return true;
        }

        if (util.isFunction(o.getElementsByTagName)) {
          return true;
        }
      }

      return false;
    },
    isWebGLTexture: function isWebGLTexture(o) {
      if (o && typeof WebGLTexture !== 'undefined') {
        return o instanceof WebGLTexture;
      }
    },
    defaultFontFamily: 'arial',
    getFontCanvas: function getFontCanvas() {
      return inject.getCacheCanvas(16, 16, '__$$CHECK_SUPPORT_FONT_FAMILY$$__');
    },
    checkSupportFontFamily: function checkSupportFontFamily(ff) {
      ff = ff.toLowerCase(); // 强制arial兜底

      if (ff === this.defaultFontFamily) {
        return true;
      }

      if (SUPPORT_FONT.hasOwnProperty(ff)) {
        return SUPPORT_FONT[ff];
      }

      var canvas = inject.getFontCanvas();
      var context = canvas.ctx;
      context.textAlign = 'center';
      context.fillStyle = '#000';
      context.textBaseline = 'middle';

      if (!defaultFontFamilyData) {
        context.clearRect(0, 0, 16, 16);
        context.font = '16px ' + this.defaultFontFamily;
        context.fillText('a', 8, 8);
        defaultFontFamilyData = context.getImageData(0, 0, 16, 16).data;
      }

      context.clearRect(0, 0, 16, 16);

      if (/\s/.test(ff)) {
        ff = '"' + ff.replace(/"/g, '\\"') + '"';
      }

      context.font = '16px ' + ff + ',' + this.defaultFontFamily;
      context.fillText('a', 8, 8);
      var data = context.getImageData(0, 0, 16, 16).data;

      for (var i = 0, len = data.length; i < len; i++) {
        if (defaultFontFamilyData[i] !== data[i]) {
          return SUPPORT_FONT[ff] = true;
        }
      }

      return SUPPORT_FONT[ff] = false;
    },
    loadFont: function loadFont(fontFamily, url, cb) {
      if (util.isFunction(url)) {
        cb = url;
        url = fontFamily;
      }

      if (Array.isArray(url)) {
        if (!url.length) {
          return cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.loadFont(item.fontFamily, item.url, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Load font invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      if (!fontFamily) {
        fontFamily = url;
      }

      var cache = FONT[url] = FONT[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        cache.state = LOADING;
        cb && cache.task.push(cb);

        if (!(url instanceof ArrayBuffer) && !/url\(/.test(url)) {
          url = "url(".concat(url, ")");
        }

        var f = new FontFace(fontFamily, url);
        f.load().then(function () {
          document.fonts.add(f);
          cache.state = LOADED;
          cache.success = true;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
        })["catch"](function () {
          cache.state = LOADED;
          cache.success = false;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
        });
      }
    },
    loadComponent: function loadComponent(url, cb) {
      if (Array.isArray(url)) {
        if (!url.length) {
          return cb();
        }

        var count = 0;
        var len = url.length;
        var list = [];
        url.forEach(function (item, i) {
          inject.loadComponent(item, function (cache) {
            list[i] = cache;

            if (++count === len) {
              cb(list);
            }
          });
        });
        return;
      } else if (!url || !util.isString(url)) {
        inject.error('Load component invalid: ' + url);
        cb && cb({
          state: LOADED,
          success: false,
          url: url
        });
        return;
      }

      var cache = COMPONENT[url] = COMPONENT[url] || {
        state: INIT,
        task: []
      };

      if (cache.state === LOADED) {
        cb && cb(cache);
      } else if (cache.state === LOADING) {
        cb && cache.task.push(cb);
      } else {
        cache.state = LOADING;
        cb && cache.task.push(cb);
        var script = document.createElement('script');
        script.src = url;
        script.async = true;

        script.onload = function () {
          cache.state = LOADED;
          cache.success = true;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
          document.head.removeChild(script);
        };

        script.onerror = function () {
          cache.state = LOADED;
          cache.success = false;
          cache.url = url;
          var list = cache.task.splice(0);
          list.forEach(function (cb) {
            return cb(cache);
          });
          document.head.removeChild(script);
        };

        document.head.appendChild(script);
      }
    }
  };

  var isString = util.isString;
  var CALLBACK = {};
  var o$3 = {
    info: {
      arial: {
        lhr: 1.14990234375,
        // 默认line-height ratio，(67+1854+434)/2048
        // car: 1.1171875, // content-area ratio，(1854+434)/2048
        blr: 0.9052734375,
        // base-line ratio，1854/2048
        // mdr: 0.64599609375, // middle ratio，(1854-1062/2)/2048
        lgr: 0.03271484375 // line-gap ratio，67/2048，默认0

      },
      helvetica: {
        lhr: 1.14990234375,
        // (8+1900+447)/2048
        blr: 0.927734375,
        // 1900/2048
        lgr: 0.00390625 // 8/2048

      },
      verdana: {
        lhr: 1.21533203125,
        // (0+2059+430)/2048
        blr: 1.00537109375 // 2059/2048

      },
      tahoma: {
        lhr: 1.20703125,
        // (0+2049+423)/2048
        blr: 1.00048828125 // 2049/2048

      },
      georgia: {
        lhr: 1.13623046875,
        // (0+1878+449)/2048
        blr: 0.9169921875 // 1878/2048

      },
      'courier new': {
        lhr: 1.1328125,
        // (0+1705+615)/2048
        blr: 0.83251953125 // 1705/2048

      },
      'pingfang sc': {
        lhr: 1.4,
        // (0+1060+340)/1000
        blr: 1.06 // 1060/1000

      },
      simsun: {
        lhr: 1.4,
        // (0+1060+340)/1000
        blr: 1.06
      }
    },
    support: function support(fontFamily) {
      return this.info.hasOwnProperty(fontFamily) && this.info[fontFamily].checked;
    },
    register: function register(name, url, data) {
      // url和data同时需要，也可以先data后url，不能先url后data
      name = name.toLowerCase();

      if (!isString(url) && !(url instanceof ArrayBuffer)) {
        data = url;
        url = null;
      }

      var info = this.info;
      info[name] = info[name] || {};

      if (url && !info[name].url) {
        // 不能覆盖
        info[name].url = url;
        inject.loadFont(name, url, function (res) {
          info[name].success = res.success;

          if (res.success) {
            var list = CALLBACK[name] || [];

            while (list.length) {
              var node = list.pop();

              node.__emitFontRegister(name);
            }
          }
        });
      } // 防止先没url只注册，再调用只传url的情况


      if (!data || info[name].lhr) {
        return;
      }

      var _ref = data || {},
          _ref$emSquare = _ref.emSquare,
          emSquare = _ref$emSquare === void 0 ? 2048 : _ref$emSquare,
          _ref$ascent = _ref.ascent,
          ascent = _ref$ascent === void 0 ? 1854 : _ref$ascent,
          _ref$descent = _ref.descent,
          descent = _ref$descent === void 0 ? 434 : _ref$descent,
          _ref$lineGap = _ref.lineGap,
          lineGap = _ref$lineGap === void 0 ? 0 : _ref$lineGap;

      Object.assign(info[name], {
        lhr: (ascent + descent + lineGap) / emSquare,
        blr: ascent / emSquare
      });
    },
    hasRegister: function hasRegister(fontFamily) {
      return this.info.hasOwnProperty(fontFamily) && this.info[fontFamily].hasOwnProperty('lhr');
    },
    hasLoaded: function hasLoaded(fontFamily) {
      return this.info.hasOwnProperty(fontFamily) && this.info[fontFamily].success;
    },
    onRegister: function onRegister(fontFamily, node) {
      var list = CALLBACK[fontFamily] = CALLBACK[fontFamily] || [];
      list.push(node);
    },
    offRegister: function offRegister(fontFamily, node) {
      var list = CALLBACK[fontFamily] = CALLBACK[fontFamily] || [];
      var i = list.indexOf(node);

      if (i > -1) {
        list.splice(i, 1);
      }
    }
  };
  o$3.info['宋体'] = o$3.info.simsun;
  o$3.info['pingfang'] = o$3.info['pingfang sc'];

  var DOM = {
    position: 'static',
    display: 'block',
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto',
    marginTop: 0,
    marginRight: 0,
    marginBottom: 0,
    marginLeft: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    fontSize: 'inherit',
    fontFamily: 'inherit',
    color: 'inherit',
    fontStyle: 'inherit',
    fontWeight: 'inherit',
    lineHeight: 'inherit',
    backgroundImage: null,
    backgroundColor: 'transparent',
    backgroundSize: 'auto',
    backgroundRepeat: 'repeat',
    backgroundPositionX: 0,
    backgroundPositionY: 0,
    backgroundClip: 'borderBox',
    borderTopWidth: 0,
    borderRightWidth: 0,
    borderBottomWidth: 0,
    borderLeftWidth: 0,
    borderTopColor: 'transparent',
    borderRightColor: 'transparent',
    borderBottomColor: 'transparent',
    borderLeftColor: 'transparent',
    borderTopStyle: 'none',
    borderRightStyle: 'none',
    borderBottomStyle: 'none',
    borderLeftStyle: 'none',
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    borderBottomRightRadius: 0,
    borderBottomLeftRadius: 0,
    width: 'auto',
    height: 'auto',
    flexGrow: 0,
    flexShrink: 1,
    flexBasis: 'auto',
    flexDirection: 'row',
    flexWrap: 'nowrap',
    order: 0,
    justifyContent: 'flexStart',
    alignItems: 'stretch',
    alignSelf: 'auto',
    alignContent: 'stretch',
    textAlign: 'inherit',
    letterSpacing: 'inherit',
    transformOrigin: 'center',
    visibility: 'inherit',
    opacity: 1,
    zIndex: 0,
    transform: null,
    translateX: 0,
    translateY: 0,
    translateZ: 0,
    scaleX: 1,
    scaleY: 1,
    scaleZ: 1,
    skewX: 0,
    skewY: 0,
    rotateX: 0,
    rotateY: 0,
    rotateZ: 0,
    rotate3d: '0, 0, 0, 0',
    perspective: 0,
    perspectiveOrigin: 'center',
    filter: null,
    boxShadow: null,
    pointerEvents: 'inherit',
    overflow: 'visible',
    mixBlendMode: 'normal',
    whiteSpace: 'inherit',
    textOverflow: 'clip',
    lineClamp: 0,
    textStrokeWidth: 'inherit',
    textStrokeColor: 'inherit',
    textStrokeOver: 'inherit',
    writingMode: 'inherit'
  };
  var GEOM$4 = {
    fill: 'transparent',
    stroke: '#000',
    strokeWidth: 1,
    strokeDasharray: '',
    strokeLinecap: 'butt',
    strokeLinejoin: 'miter',
    strokeMiterlimit: 4,
    fillRule: 'nonzero'
  };
  var DOM_ENTRY_SET = [];
  var DOM_KEY_SET = [];
  Object.keys(DOM).forEach(function (k) {
    DOM_KEY_SET.push(k);
    var v = DOM[k];
    DOM_ENTRY_SET.push({
      k: k,
      v: v
    });
  });
  var GEOM_ENTRY_SET = [];
  var GEOM_KEY_SET$2 = [];
  Object.keys(GEOM$4).forEach(function (k) {
    GEOM_KEY_SET$2.push(k);
    var v = GEOM$4[k];
    GEOM_ENTRY_SET.push({
      k: k,
      v: v
    });
  });
  var INHERIT$4 = {
    get fontFamily() {
      return inject.defaultFontFamily;
    },

    fontSize: 16,
    fontWeight: 400,
    fontStyle: 'normal',
    color: '#000',
    textAlign: 'left',
    visibility: 'visible',
    pointerEvents: 'auto',
    textStrokeColor: '#000',
    textStrokeWidth: 0,
    textStrokeOver: 'none',
    writingMode: 'horizontalTb'
  };
  var INHERIT_KEY_SET = [];
  Object.keys(INHERIT$4).forEach(function (k) {
    INHERIT_KEY_SET.push(k);
  }); // 默认值放第一个

  var VALID_STRING_VALUE$1 = {
    position: ['static', 'relative', 'absolute'],
    display: ['block', 'inlineBlock', 'inline', 'flex', 'none'],
    flexDirection: ['row', 'column', 'rowReverse', 'columnReverse'],
    flexWrap: ['wrap', 'wrapReverse', 'nowrap'],
    justifyContent: ['flexStart', 'center', 'flexEnd', 'spaceBetween', 'spaceAround', 'spaceEvenly'],
    alignItems: ['stretch', 'flexStart', 'center', 'flexEnd', 'baseline'],
    alignSelf: ['auto', 'stretch', 'flexStart', 'center', 'flexEnd', 'baseline'],
    overflow: ['visible', 'hidden'],
    mixBlendMode: ['normal', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'colorDodge', 'colorBurn', 'hardLight', 'softLight', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'],
    borderTopStyle: ['solid', 'dashed', 'dotted'],
    borderRightStyle: ['solid', 'dashed', 'dotted'],
    borderBottomStyle: ['solid', 'dashed', 'dotted'],
    borderLeftStyle: ['solid', 'dashed', 'dotted'],
    backgroundClip: ['borderBox', 'paddingBox', 'contentBox'],
    textOverflow: ['clip', 'ellipsis'],
    alignContent: ['stretch', 'flexStart', 'center', 'flexEnd', 'spaceBetween', 'spaceAround']
  };
  var reset = {
    DOM: DOM,
    GEOM: GEOM$4,
    isValid: function isValid(i) {
      return DOM.hasOwnProperty(i) || GEOM$4.hasOwnProperty(i);
    },
    DOM_KEY_SET: DOM_KEY_SET,
    GEOM_KEY_SET: GEOM_KEY_SET$2,
    DOM_ENTRY_SET: DOM_ENTRY_SET,
    GEOM_ENTRY_SET: GEOM_ENTRY_SET,
    INHERIT: INHERIT$4,
    INHERIT_KEY_SET: INHERIT_KEY_SET,
    VALID_STRING_VALUE: VALID_STRING_VALUE$1
  };

  var reg = {
    position: /(([-+]?[\d.]+[pxremvwhina%]*)|(left|top|right|bottom|center)){1,2}/ig,
    gradient: /\b(\w+)-?gradient\((.+)\)/i,
    img: /(?:\burl\((['"]?)(.*?)\1\))|(?:\b((data:)))/i
  };

  // 向量点乘积
  function dotProduct(x1, y1, x2, y2) {
    return x1 * x2 + y1 * y2;
  } // 向量叉乘积


  function crossProduct$1(x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1;
  }

  var vector = {
    dotProduct: dotProduct,
    crossProduct: crossProduct$1
  };

  var STYLE_KEY$4 = {
    POSITION: 0,
    DISPLAY: 1,
    TOP: 2,
    RIGHT: 3,
    BOTTOM: 4,
    LEFT: 5,
    MARGIN_TOP: 6,
    MARGIN_RIGHT: 7,
    MARGIN_BOTTOM: 8,
    MARGIN_LEFT: 9,
    PADDING_TOP: 10,
    PADDING_RIGHT: 11,
    PADDING_BOTTOM: 12,
    PADDING_LEFT: 13,
    FONT_SIZE: 14,
    FONT_FAMILY: 15,
    COLOR: 16,
    FONT_STYLE: 17,
    FONT_WEIGHT: 18,
    LINE_HEIGHT: 19,
    BACKGROUND_IMAGE: 20,
    BACKGROUND_COLOR: 21,
    BACKGROUND_SIZE: 22,
    BACKGROUND_REPEAT: 23,
    BACKGROUND_POSITION_X: 24,
    BACKGROUND_POSITION_Y: 25,
    BORDER_TOP_WIDTH: 26,
    BORDER_RIGHT_WIDTH: 27,
    BORDER_BOTTOM_WIDTH: 28,
    BORDER_LEFT_WIDTH: 29,
    BORDER_TOP_COLOR: 30,
    BORDER_RIGHT_COLOR: 31,
    BORDER_BOTTOM_COLOR: 32,
    BORDER_LEFT_COLOR: 33,
    BORDER_TOP_STYLE: 34,
    BORDER_RIGHT_STYLE: 35,
    BORDER_BOTTOM_STYLE: 36,
    BORDER_LEFT_STYLE: 37,
    BORDER_TOP_LEFT_RADIUS: 38,
    BORDER_TOP_RIGHT_RADIUS: 39,
    BORDER_BOTTOM_RIGHT_RADIUS: 40,
    BORDER_BOTTOM_LEFT_RADIUS: 41,
    WIDTH: 42,
    HEIGHT: 43,
    FLEX_GROW: 44,
    FLEX_SHRINK: 45,
    FLEX_BASIS: 46,
    FLEX_DIRECTION: 47,
    JUSTIFY_CONTENT: 48,
    ALIGN_ITEMS: 49,
    ALIGN_SELF: 50,
    TEXT_ALIGN: 51,
    TRANSFORM_ORIGIN: 52,
    VISIBILITY: 53,
    OPACITY: 54,
    Z_INDEX: 55,
    TRANSFORM: 56,
    TRANSLATE_X: 57,
    TRANSLATE_Y: 58,
    TRANSLATE_Z: 59,
    SCALE_X: 60,
    SCALE_Y: 61,
    SCALE_Z: 62,
    SKEW_X: 63,
    SKEW_Y: 64,
    ROTATE_X: 65,
    ROTATE_Y: 66,
    ROTATE_Z: 67,
    ROTATE_3D: 68,
    PERSPECTIVE: 69,
    PERSPECTIVE_ORIGIN: 70,
    FILTER: 71,
    BOX_SHADOW: 72,
    POINTER_EVENTS: 73,
    OVERFLOW: 74,
    MIX_BLEND_MODE: 75,
    BACKGROUND_CLIP: 76,
    WHITE_SPACE: 77,
    TEXT_OVERFLOW: 78,
    LETTER_SPACING: 79,
    LINE_CLAMP: 80,
    ORDER: 81,
    FLEX_WRAP: 82,
    ALIGN_CONTENT: 83,
    TEXT_STROKE_WIDTH: 84,
    TEXT_STROKE_COLOR: 85,
    TEXT_STROKE_OVER: 86,
    WRITING_MODE: 87,
    // GEOM
    FILL: 88,
    STROKE: 89,
    STROKE_WIDTH: 90,
    STROKE_DASHARRAY: 91,
    STROKE_DASHARRAY_STR: 92,
    STROKE_LINECAP: 93,
    STROKE_LINEJOIN: 94,
    STROKE_MITERLIMIT: 95,
    FILL_RULE: 96,
    // 无此样式，仅cache或特殊情况需要
    MATRIX: 97,
    BORDER_TOP: 98,
    BORDER_RIGHT: 99,
    BORDER_BOTTOM: 100,
    BORDER_LEFT: 101,
    TRANSLATE_PATH: 102
  };
  var STYLE2LOWER_MAP = {};

  function style2Lower(s) {
    var res = STYLE2LOWER_MAP[s];

    if (!res) {
      res = STYLE2LOWER_MAP[s] = s.toLowerCase().replace(/_([a-z])/g, function ($0, $1) {
        return $1.toUpperCase();
      });
    }

    return res;
  }

  var STYLE2UPPER_MAP = {};

  function style2Upper$2(s) {
    var res = STYLE2UPPER_MAP[s];

    if (!res) {
      res = STYLE2UPPER_MAP[s] = s.replace(/([a-z\d_])([A-Z])/g, function ($0, $1, $2) {
        return $1 + '_' + $2;
      }).toUpperCase();
    }

    return res;
  }

  var STYLE_R_KEY = {};
  var STYLE_RV_KEY$1 = {};
  var STYLE_V_KEY = {};
  Object.keys(STYLE_KEY$4).forEach(function (k) {
    var k2 = STYLE_KEY$4[k];
    STYLE_R_KEY[k2] = k;
    var l = style2Lower(k);
    STYLE_RV_KEY$1[k2] = l;
    STYLE_V_KEY[l] = k2;
  });
  var enums = {
    STYLE_KEY: STYLE_KEY$4,
    // 大写常量为k，数字为值
    STYLE_R_KEY: STYLE_R_KEY,
    // 数字为k，大写常量为值
    STYLE_RV_KEY: STYLE_RV_KEY$1,
    // 数字为k，小写为值
    STYLE_V_KEY: STYLE_V_KEY,
    // 小写为k，数字为值
    style2Lower: style2Lower,
    style2Upper: style2Upper$2,
    ELLIPSIS: '…'
  };

  var H$1 = 4 * (Math.sqrt(2) - 1) / 3;
  var crossProduct = vector.crossProduct;
  var calPoint = mx.calPoint,
      isE$4 = mx.isE;
  var _enums$STYLE_KEY$k = enums.STYLE_KEY,
      WIDTH$a = _enums$STYLE_KEY$k.WIDTH,
      HEIGHT$a = _enums$STYLE_KEY$k.HEIGHT,
      TRANSFORM_ORIGIN$6 = _enums$STYLE_KEY$k.TRANSFORM_ORIGIN;
  /**
   * 圆弧拟合公式，根据角度求得3阶贝塞尔控制点比例长度，一般<=90，超过拆分
   * @param deg
   * @returns {number}
   */

  function h(deg) {
    deg *= 0.5;
    return 4 * ((1 - Math.cos(deg)) / Math.sin(deg)) / 3;
  }
  /**
   * 判断点是否在多边形内
   * @param x 点坐标
   * @param y
   * @param vertexes 多边形顶点坐标
   * @returns {boolean}
   */


  function pointInConvexPolygon(x, y, vertexes) {
    // 先取最大最小值得一个外围矩形，在外边可快速判断false
    var _vertexes$ = _slicedToArray(vertexes[0], 2),
        xmax = _vertexes$[0],
        ymax = _vertexes$[1];

    var _vertexes$2 = _slicedToArray(vertexes[0], 2),
        xmin = _vertexes$2[0],
        ymin = _vertexes$2[1];

    var len = vertexes.length;

    for (var i = 1; i < len; i++) {
      var _vertexes$i = _slicedToArray(vertexes[i], 2),
          _x = _vertexes$i[0],
          _y = _vertexes$i[1];

      xmax = Math.max(xmax, _x);
      ymax = Math.max(ymax, _y);
      xmin = Math.min(xmin, _x);
      ymin = Math.min(ymin, _y);
    }

    if (x < xmin || y < ymin || x > xmax || y > ymax) {
      return false;
    }

    var first; // 所有向量积均为非负数（逆时针，反过来顺时针是非正）说明在多边形内或边上

    for (var _i = 0, _len = vertexes.length; _i < _len; _i++) {
      var _vertexes$_i = _slicedToArray(vertexes[_i], 2),
          x1 = _vertexes$_i[0],
          y1 = _vertexes$_i[1];

      var _vertexes = _slicedToArray(vertexes[(_i + 1) % _len], 2),
          x2 = _vertexes[0],
          y2 = _vertexes[1];

      var n = crossProduct(x2 - x1, y2 - y1, x - x1, y - y1);

      if (n !== 0) {
        n = n > 0 ? 1 : 0; // 第一个赋值，后面检查是否正负一致性，不一致是反例就跳出

        if (first === undefined) {
          first = n;
        } else if (first ^ n) {
          return false;
        }
      }
    }

    return true;
  } // 判断点是否在一个4边形内，比如事件发生是否在节点上


  function pointInQuadrilateral(x, y, x1, y1, x2, y2, x4, y4, x3, y3, matrix) {
    if (matrix && !isE$4(matrix)) {
      var w1, w2, w3, w4;

      var _calPoint = calPoint([x1, y1], matrix);

      var _calPoint2 = _slicedToArray(_calPoint, 4);

      x1 = _calPoint2[0];
      y1 = _calPoint2[1];
      w1 = _calPoint2[3];

      var _calPoint3 = calPoint([x2, y2], matrix);

      var _calPoint4 = _slicedToArray(_calPoint3, 4);

      x2 = _calPoint4[0];
      y2 = _calPoint4[1];
      w2 = _calPoint4[3];

      var _calPoint5 = calPoint([x3, y3], matrix);

      var _calPoint6 = _slicedToArray(_calPoint5, 4);

      x3 = _calPoint6[0];
      y3 = _calPoint6[1];
      w3 = _calPoint6[3];

      var _calPoint7 = calPoint([x4, y4], matrix);

      var _calPoint8 = _slicedToArray(_calPoint7, 4);

      x4 = _calPoint8[0];
      y4 = _calPoint8[1];
      w4 = _calPoint8[3];

      if (w1 && w1 !== 1) {
        x1 /= w1;
        y1 /= w1;
      }

      if (w2 && w2 !== 1) {
        x2 /= w2;
        y2 /= w2;
      }

      if (w3 && w3 !== 1) {
        x3 /= w3;
        y3 /= w3;
      }

      if (w4 && w4 !== 1) {
        x4 /= w4;
        y4 /= w4;
      }

      return pointInConvexPolygon(x, y, [[x1, y1], [x2, y2], [x4, y4], [x3, y3]]);
    } else {
      return x >= x1 && y >= y1 && x <= x4 && y <= y4;
    }
  }
  /**
   * 余弦定理3边长求夹角
   * @param a
   * @param b
   * @param c
   */


  function angleBySide(a, b, c) {
    var theta = (Math.pow(b, 2) + Math.pow(c, 2) - Math.pow(a, 2)) / (2 * b * c);
    return Math.acos(theta);
  }
  /**
   * 余弦定理2边长和夹角求3边
   * @param alpha 弧度
   * @param a
   * @param b
   */


  function sideByAngle(alpha, a, b) {
    var cos = Math.cos(alpha);
    return Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) - 2 * a * b * cos);
  }
  /**
   * 两点距离
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   */


  function pointsDistance(x1, y1, x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  }
  /**
   * 三角形内心
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   * @param x3
   * @param y3
   */


  function triangleIncentre(x1, y1, x2, y2, x3, y3) {
    var a = pointsDistance(x2, y2, x3, y3);
    var b = pointsDistance(x1, y1, x3, y3);
    var c = pointsDistance(x1, y1, x2, y2);
    return [(a * x1 + b * x2 + c * x3) / (a + b + c), (a * y1 + b * y2 + c * y3) / (a + b + c)];
  }
  /**
   * 椭圆圆心和长短轴生成4个端点和控制点
   */


  function ellipsePoints(x, y, a) {
    var b = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : a;
    var ox = a * H$1;
    var oy = b === a ? ox : b * H$1;
    return [[x - a, y], [x - a, y - oy, x - ox, y - b, x, y - b], [x + ox, y - b, x + a, y - oy, x + a, y], [x + a, y + oy, x + ox, y + b, x, y + b], [x - ox, y + b, x - a, y + oy, x - a, y]];
  }
  /**
   * 扇形圆心和半径起始角度生成4个端点和控制点
   * 分为4个象限进行拟合，0、1、2、3
   */


  function sectorPoints$1(x, y, r, begin, end) {
    if (begin > end) {
      var _ref = [end, begin];
      begin = _ref[0];
      end = _ref[1];
    }

    if (begin === end) {
      return [];
    }

    var list = [];
    var b = Math.floor(begin / 90);
    var e = Math.floor(end / 90); // 同象限直接算

    if (b === e || e - b === 1 && end % 90 === 0) {
      var h2 = h(d2r$2(Math.abs(begin - end)));
      var d = h2 * r;
      var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
      var alpha = Math.atan(d / r);

      if (b < 90) {
        // 第1个交点
        var rx = Math.sin(d2r$2(begin)) * r;
        var ry = Math.cos(d2r$2(begin)) * r;
        var p1 = [x + rx, y - ry]; // 第1个控制点

        var deg = alpha + d2r$2(begin);
        rx = Math.sin(deg) * c;
        ry = Math.cos(deg) * c;
        var p2 = [x + rx, y - ry]; // 第2个交点

        rx = Math.sin(d2r$2(end)) * r;
        ry = Math.cos(d2r$2(end)) * r;
        var p4 = [x + rx, y - ry]; // 第2个控制点

        deg = d2r$2(end) - alpha;
        rx = Math.sin(deg) * c;
        ry = Math.cos(deg) * c;
        var p3 = [x + rx, y - ry];
        list.push(p1);
        list.push(p2.concat(p3).concat(p4));
      } else if (b < 180) {
        // 第1个交点
        var _rx = Math.cos(d2r$2(begin - 90)) * r;

        var _ry = Math.sin(d2r$2(begin - 90)) * r;

        var _p = [x + _rx, y + _ry]; // 第1个控制点

        var _deg = alpha + d2r$2(begin - 90);

        _rx = Math.cos(_deg) * c;
        _ry = Math.sin(_deg) * c;
        var _p2 = [x + _rx, y + _ry]; // 第2个交点

        _rx = Math.cos(d2r$2(end - 90)) * r;
        _ry = Math.sin(d2r$2(end - 90)) * r;
        var _p3 = [x + _rx, y + _ry]; // 第2个控制点

        _deg = d2r$2(end - 90) - alpha;
        _rx = Math.cos(_deg) * c;
        _ry = Math.sin(_deg) * c;
        var _p4 = [x + _rx, y + _ry];
        list.push(_p);
        list.push(_p2.concat(_p4).concat(_p3));
      } else if (b < 270) {
        // 第1个交点
        var _rx2 = Math.sin(d2r$2(begin - 180)) * r;

        var _ry2 = Math.cos(d2r$2(begin - 180)) * r;

        var _p5 = [x - _rx2, y + _ry2]; // 第1个控制点

        var _deg2 = alpha + d2r$2(begin - 180);

        _rx2 = Math.sin(_deg2) * c;
        _ry2 = Math.cos(_deg2) * c;
        var _p6 = [x - _rx2, y + _ry2]; // 第2个交点

        _rx2 = Math.sin(d2r$2(end - 180)) * r;
        _ry2 = Math.cos(d2r$2(end - 180)) * r;
        var _p7 = [x - _rx2, y + _ry2]; // 第2个控制点

        _deg2 = d2r$2(end - 180) - alpha;
        _rx2 = Math.sin(_deg2) * c;
        _ry2 = Math.cos(_deg2) * c;
        var _p8 = [x - _rx2, y + _ry2];
        list.push(_p5);
        list.push(_p6.concat(_p8).concat(_p7));
      } else {
        // 第1个交点
        var _rx3 = Math.cos(d2r$2(begin - 270)) * r;

        var _ry3 = Math.sin(d2r$2(begin - 270)) * r;

        var _p9 = [x - _rx3, y + _ry3]; // 第1个控制点

        var _deg3 = alpha + d2r$2(begin - 270);

        _rx3 = Math.cos(_deg3) * c;
        _ry3 = Math.sin(_deg3) * c;
        var _p10 = [x - _rx3, y + _ry3]; // 第2个交点

        _rx3 = Math.cos(d2r$2(end - 270)) * r;
        _ry3 = Math.sin(d2r$2(end - 270)) * r;
        var _p11 = [x - _rx3, y + _ry3]; // 第2个控制点

        _deg3 = d2r$2(end - 270) - alpha;
        _rx3 = Math.cos(_deg3) * c;
        _ry3 = Math.sin(_deg3) * c;
        var _p12 = [x - _rx3, y + _ry3];
        list.push(_p9);
        list.push(_p10.concat(_p12).concat(_p11));
      }
    } // 跨象限循环算
    else {
      var i = b;
      var temp = [];

      for (; i <= e; i++) {
        if (i === 0) {
          var res = sectorPoints$1(x, y, r, begin, 90);
          temp.push(res);
        } else if (i === 1) {
          // 防止90~90这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 90) {
            var _res = sectorPoints$1(x, y, r, begin < 90 ? 90 : begin, end > 180 ? 180 : end);

            temp.push(_res);
          }
        } else if (i === 2) {
          // 防止180~180这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 180) {
            var _res2 = sectorPoints$1(x, y, r, begin < 180 ? 180 : begin, end > 270 ? 270 : end);

            temp.push(_res2);
          }
        } else if (i === 3) {
          // 防止180~180这种情况，但如果begin和end都是90时又要显示
          if (b === i || end > 270) {
            var _res3 = sectorPoints$1(x, y, r, begin < 270 ? 270 : begin, end);

            temp.push(_res3);
          }
        }
      } // 去掉重复的首尾扇弧点


      list = temp[0];

      for (var _i2 = 1, len = temp.length; _i2 < len; _i2++) {
        list.push(temp[_i2][1]);
      }
    }

    return list;
  }
  /**
   * 获取2个矩形重叠区域，如不重叠返回null
   * @param a
   * @param b
   */


  function getRectsIntersection(a, b) {
    if (!isRectsOverlap$1(a, b)) {
      return null;
    }

    var _a = _slicedToArray(a, 4),
        ax1 = _a[0],
        ay1 = _a[1],
        ax4 = _a[2],
        ay4 = _a[3];

    var _b = _slicedToArray(b, 4),
        bx1 = _b[0],
        by1 = _b[1],
        bx4 = _b[2],
        by4 = _b[3];

    return [Math.max(ax1, bx1), Math.max(ay1, by1), Math.min(ax4, bx4), Math.min(ay4, by4)];
  }
  /**
   * 2个矩形是否重叠
   */


  function isRectsOverlap$1(a, b, includeIntersect) {
    var _a2 = _slicedToArray(a, 4),
        ax1 = _a2[0],
        ay1 = _a2[1],
        ax4 = _a2[2],
        ay4 = _a2[3];

    var _b2 = _slicedToArray(b, 4),
        bx1 = _b2[0],
        by1 = _b2[1],
        bx4 = _b2[2],
        by4 = _b2[3];

    if (includeIntersect) {
      if (ax1 > bx4 || ay1 > by4 || bx1 > ax4 || by1 > ay4) {
        return false;
      }
    } else if (ax1 >= bx4 || ay1 >= by4 || bx1 >= ax4 || by1 >= ay4) {
      return false;
    }

    return true;
  }
  /**
   * 2个矩形是否包含，a包含b
   */


  function isRectsInside(a, b, includeIntersect) {
    var _a3 = _slicedToArray(a, 4),
        ax1 = _a3[0],
        ay1 = _a3[1],
        ax4 = _a3[2],
        ay4 = _a3[3];

    var _b3 = _slicedToArray(b, 4),
        bx1 = _b3[0],
        by1 = _b3[1],
        bx4 = _b3[2],
        by4 = _b3[3];

    if (includeIntersect) {
      if (ax1 <= bx1 && ay1 <= by1 && ax4 >= bx4 && ay4 >= by4) {
        return true;
      }
    } else if (ax1 < bx1 && ay1 < by1 && ax4 > bx4 && ay4 > by4) {
      return true;
    }

    return false;
  }

  function calCoordsInNode(px, py, node) {
    var _node$matrix = node.matrix,
        matrix = _node$matrix === void 0 ? [1, 0, 0, 1, 0, 0] : _node$matrix,
        _node$computedStyle = node.computedStyle,
        computedStyle = _node$computedStyle === void 0 ? {} : _node$computedStyle;
    var width = computedStyle[WIDTH$a],
        height = computedStyle[HEIGHT$a],
        _computedStyle$TRANSF = computedStyle[TRANSFORM_ORIGIN$6];
    _computedStyle$TRANSF = _computedStyle$TRANSF === void 0 ? [width * 0.5, height * 0.5] : _computedStyle$TRANSF;

    var _computedStyle$TRANSF2 = _slicedToArray(_computedStyle$TRANSF, 2),
        ox = _computedStyle$TRANSF2[0],
        oy = _computedStyle$TRANSF2[1];

    var _calPoint9 = calPoint([px * width - ox, py * height - oy], matrix);

    var _calPoint10 = _slicedToArray(_calPoint9, 2);

    px = _calPoint10[0];
    py = _calPoint10[1];
    return [px + ox, py + oy];
  }

  function calPercentInNode(x, y, node) {
    var _node$computedStyle2 = node.computedStyle,
        width = _node$computedStyle2[WIDTH$a],
        height = _node$computedStyle2[HEIGHT$a],
        _node$computedStyle2$ = _slicedToArray(_node$computedStyle2[TRANSFORM_ORIGIN$6], 2),
        ox = _node$computedStyle2$[0],
        oy = _node$computedStyle2$[1]; // 先求无旋转时右下角相对于原点的角度ds


    var ds = Math.atan((height - oy) / (width - ox));

    var _calCoordsInNode = calCoordsInNode(1, 1, node),
        _calCoordsInNode2 = _slicedToArray(_calCoordsInNode, 2),
        x1 = _calCoordsInNode2[0],
        y1 = _calCoordsInNode2[1];

    var d1;
    var deg; // 根据旋转后的坐标，分4个象限，求旋转后的右下角相对于原点的角度d1，得出偏移角度deg，分顺逆时针[-180, 180]

    if (x1 >= ox && y1 >= oy) {
      if (ox === x1) {
        d1 = -Math.atan(Infinity);
      } else {
        d1 = Math.atan((y1 - oy) / (x1 - ox));
      }

      deg = d1 - ds;
    } else if (x1 >= ox && y1 < oy) {
      if (ox === x1) {
        d1 = -Math.atan(Infinity);
      } else {
        d1 = Math.atan((oy - y1) / (x1 - ox));
      }

      deg = d1 + ds;
    } else if (x1 < ox && y1 >= oy) {
      d1 = Math.atan((y1 - oy) / (ox - x1));
      deg = d1 - ds;
    } else if (x1 < ox && y1 < oy) {
      d1 = Math.atan((y1 - oy) / (x1 - ox));

      if (ds >= d1) {
        deg = d1 + Math.PI - ds;
      } else {
        deg = Math.PI - d1 + ds;
        deg = -deg;
      }
    } else {
      deg = 0;
    } // 目标点到原点的边长不会变


    var dt = Math.sqrt(Math.pow(x - ox, 2) + Math.pow(y - oy, 2)); // 分4个象限，先求目标点到原点的角度d2，再偏移deg后求得原始坐标

    var d2;

    if (x >= ox && y >= oy) {
      if (ox === x) {
        d2 = -Math.atan(Infinity);
      } else {
        d2 = Math.atan((y - oy) / (x - ox));
      }
    } else if (x >= ox && y < oy) {
      if (ox === x) {
        d2 = -Math.atan(Infinity);
      } else {
        d2 = -Math.atan((y - oy) / (ox - x));
      }
    } else if (x < ox && y >= oy) {
      d2 = Math.PI - Math.atan((y - oy) / (ox - x));
    } else {
      d2 = Math.atan((y - oy) / (x - ox)) - Math.PI;
    }

    d2 -= deg;

    if (d2 > Math.PI) {
      d2 -= Math.PI;
      return [(ox - dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
    }

    if (d2 > Math.PI * 0.5) {
      d2 = Math.PI - d2;
      return [(ox - dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
    }

    if (d2 >= 0) {
      return [(ox + dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
    }

    if (d2 >= -Math.PI * 0.5) {
      d2 = -d2;
      return [(ox + dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
    }

    if (d2 >= -Math.PI) {
      d2 = Math.PI + d2;
      return [(ox - dt * Math.cos(d2)) / width, (oy - dt * Math.sin(d2)) / height];
    }

    d2 = -Math.PI - d2;
    return [(ox - dt * Math.cos(d2)) / width, (oy + dt * Math.sin(d2)) / height];
  }

  function d2r$2(n) {
    return n * Math.PI / 180;
  }

  function r2d(n) {
    return n * 180 / Math.PI;
  }

  function pointOnCircle(x, y, r, deg) {
    if (deg >= 270) {
      deg -= 270;
      deg = d2r$2(deg);
      return [x - Math.cos(deg) * r, y - Math.sin(deg) * r];
    } else if (deg >= 180) {
      deg -= 180;
      deg = d2r$2(deg);
      return [x - Math.sin(deg) * r, y + Math.cos(deg) * r];
    } else if (deg >= 90) {
      deg -= 90;
      deg = d2r$2(deg);
      return [x + Math.cos(deg) * r, y + Math.sin(deg) * r];
    } else {
      deg = d2r$2(deg);
      return [x + Math.sin(deg) * r, y - Math.cos(deg) * r];
    }
  }

  var geom$1 = {
    pointInConvexPolygon: pointInConvexPolygon,
    pointInQuadrilateral: pointInQuadrilateral,
    d2r: d2r$2,
    r2d: r2d,
    // 贝塞尔曲线模拟1/4圆弧比例
    H: H$1,
    // <90任意角度贝塞尔曲线拟合圆弧的比例公式
    h: h,
    angleBySide: angleBySide,
    sideByAngle: sideByAngle,
    pointsDistance: pointsDistance,
    triangleIncentre: triangleIncentre,
    ellipsePoints: ellipsePoints,
    sectorPoints: sectorPoints$1,
    getRectsIntersection: getRectsIntersection,
    isRectsOverlap: isRectsOverlap$1,
    isRectsInside: isRectsInside,
    calCoordsInNode: calCoordsInNode,
    calPercentInNode: calPercentInNode,
    pointOnCircle: pointOnCircle
  };

  /**
   * @typedef {Object} gradientStatement
   * @property {Array<number>} color - 颜色rgba，0～255，如 [0, 255, 0, 255]
   * @property {number} angle - 角度，0～2 * Math.PI，(originX, originY) 为原点，垂直向上为0
   */

  /**
   * 获取渐变图像像素数组
   * @param {number} originX - 渐变中心x坐标（相对图片左上角(0,0)的值，可在图片外，下同）
   * @param {number} originY - 渐变中心y坐标
   * @param {number} width - 图片宽度
   * @param {number} height - 图片高度
   * @param {Array<stop>} stop - 渐变声明列表
   * @param data - canvas的imgData.data
   * @returns {Array<number>} 图像像素数组，每4个元素（rgba）构成一个像素点
   * @example
       // 矩形宽度为200*200，此时坐标为0～199，渐变中心为中点时，应传入99.5，可消除零点问题
       // 若渐变中心在某一整数轴上，就会引入零点问题，此时零点取y轴正半轴的色值，要消除这个问题，可以对渐变中心增加一个偏移量，使其不为整数
       let w = 200;
       let h = 200;
       let ctx = document.getElementById('example').getContext('2d');
       let imgData = ctx.getImageData(0,0, w, h);
       let data = getConicGradientImage(99.5, 99.5, w, h, [{
         color: [0,0,0,255],
         angle: 0,
       } ,{
         color: [255,0,0,255],
         angle: 2 * Math.PI,
       }]);
       for (let i = 0; i < imgData.data.length; i++) {
         imgData.data[i] = data[i];
       }
       ctx.putImageData(imgData, 0, 0);
   */
  function getConicGradientImage(originX, originY, width, height, stop, data) {
    if (stop.length < 2) {
      throw new Error('Conic gradient should recieve at least 2 gradient statements (start line and end line).');
    }

    width = Math.floor(width);
    height = Math.floor(height);
    /**
     * 根据坐标获取角度
     * @param {number} x - x坐标，左上角为原点
     * @param {number} y - y坐标，左上角为原点
     * @returns {number} angle - 角度，0～2 * Math.PI，(originX, originY) 为原点，垂直向上为0
     */

    var getAngle = function getAngle(x, y) {
      // 此函数注释内的x、y轴基于 (originX, originY)
      // 计算相对 (originX, originY) 的坐标(dx, dy)
      var dx = x - originX;
      var dy = originY - y; // 在y轴上

      if (dx === 0) {
        return dy < 0 ? // y轴负半轴，
        1 * Math.PI : // y轴正半轴，因此，(originX, originY) 的angle视作0
        0;
      } // 在x轴上


      if (dy === 0) {
        return dx < 0 ? // x轴负半轴
        1.5 * Math.PI : // x轴正半轴
        0.5 * Math.PI;
      }

      var atan = Math.atan(dy / dx);
      /**
       *  2   |  1
       * -----|-----
       *  3   |  4
       */
      // 第一象限，atan > 0
      // 第四象限，atan < 0

      if (dx > 0) {
        return 0.5 * Math.PI - atan;
      } // 第二象限，atan < 0
      // 第三象限，atan > 0


      if (dx < 0) {
        return 1.5 * Math.PI - atan;
      }
    };

    var increasingList = stop.map(function (item) {
      return {
        color: item[0],
        angle: item[1] * Math.PI * 2
      };
    });

    for (var y = 0; y < height; y++) {
      var _loop = function _loop(x) {
        // step 1. 找到当前点坐标相对 (originX, originY) 的角度
        var angle = getAngle(x, y); // step 2. 找到当前点坐标对应的渐变区间

        var j = void 0;

        for (j = 0; j < increasingList.length && increasingList[j].angle <= angle; j++) {}

        var start = increasingList[j - 1];
        var end = increasingList[j];

        if (!(start && end)) {
          // step 2-1. 不在渐变区间里
          return "continue";
        } // step 3. 计算色值并填充


        var factor = (angle - start.angle) / (end.angle - start.angle);
        var color = end.color.map(function (v, idx) {
          return factor * (v - start.color[idx]) + start.color[idx];
        });
        var i = (x + y * width) * 4;
        data[i] = color[0];
        data[i + 1] = color[1];
        data[i + 2] = color[2];
        data[i + 3] = Math.min(255, color[3] * 255);
      };

      for (var x = 0; x < width; x++) {
        var _ret = _loop(x);

        if (_ret === "continue") continue;
      }
    }

    return data;
  }

  var gradient$1 = {
    getConicGradientImage: getConicGradientImage
  };

  var int2rgba$3 = util.int2rgba;

  function canvasPolygon$7(ctx, list) {
    var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    if (!list || !list.length) {
      return;
    }

    var start = -1;

    for (var i = 0, len = list.length; i < len; i++) {
      var item = list[i];

      if (Array.isArray(item) && item.length) {
        start = i;
        break;
      }
    }

    if (start === -1) {
      return;
    }

    var first = list[start];
    ctx.moveTo(first[0] + dx, first[1] + dy); // 特殊的情况，布尔运算数学库会打乱原有顺序，致使第一个点可能有冗余的贝塞尔值，move到正确的索引坐标

    if (first.length === 4) {
      ctx.moveTo(first[2] + dx, first[3] + dy);
    } else if (first.length === 6) {
      ctx.moveTo(first[4] + dx, first[5] + dy);
    }

    for (var _i = start + 1, _len = list.length; _i < _len; _i++) {
      var _item = list[_i];

      if (!Array.isArray(_item)) {
        continue;
      }

      if (_item.length === 2) {
        ctx.lineTo(_item[0] + dx, _item[1] + dy);
      } else if (_item.length === 4) {
        ctx.quadraticCurveTo(_item[0] + dx, _item[1] + dy, _item[2] + dx, _item[3] + dy);
      } else if (_item.length === 6) {
        ctx.bezierCurveTo(_item[0] + dx, _item[1] + dy, _item[2] + dx, _item[3] + dy, _item[4] + dx, _item[5] + dy);
      }
    }
  }

  function svgPolygon$6(list) {
    if (!list || !list.length) {
      return '';
    }

    var start = -1;

    for (var i = 0, len = list.length; i < len; i++) {
      var item = list[i];

      if (Array.isArray(item) && item.length) {
        start = i;
        break;
      }
    }

    if (start === -1) {
      return '';
    }

    var first = list[start];
    var s = 'M' + first[0] + ',' + first[1];

    if (first.length === 4) {
      s = 'M' + first[2] + ',' + first[3];
    } else if (first.length === 6) {
      s = 'M' + first[4] + ',' + first[5];
    }

    for (var _i2 = start + 1, _len2 = list.length; _i2 < _len2; _i2++) {
      var _item2 = list[_i2];

      if (!Array.isArray(_item2)) {
        continue;
      }

      if (_item2.length === 2) {
        s += 'L' + _item2[0] + ',' + _item2[1];
      } else if (_item2.length === 4) {
        s += 'Q' + _item2[0] + ',' + _item2[1] + ' ' + _item2[2] + ',' + _item2[3];
      } else if (_item2.length === 6) {
        s += 'C' + _item2[0] + ',' + _item2[1] + ' ' + _item2[2] + ',' + _item2[3] + ' ' + _item2[4] + ',' + _item2[5];
      }
    }

    return s;
  }

  function canvasLine(ctx, x1, y1, x2, y2, controlA, controlB, num) {
    var dx = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
    var dy = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    ctx.moveTo(x1 + dx, y1 + dy);

    if (num === 3) {
      ctx.bezierCurveTo(controlA[0] + dx, controlA[1] + dy, controlB[0] + dx, controlB[1], x2 + dx, y2 + dy);
      return 2;
    } else if (num === 2) {
      ctx.quadraticCurveTo(controlB[0] + dx, controlB[1] + dy, x2 + dx, y2 + dy);
      return 2;
    } else if (num === 1) {
      ctx.quadraticCurveTo(controlA[0] + dx, controlA[1] + dy, x2 + dx, y2 + dy);
      return 2;
    } else {
      ctx.lineTo(x2 + dx, y2 + dy);
      return 1;
    }
  }

  function svgLine(x1, y1, x2, y2, controlA, controlB, num) {
    if (num === 3) {
      return 'M' + x1 + ',' + y1 + 'C' + controlA[0] + ',' + controlA[1] + ' ' + controlB[0] + ',' + controlB[1] + ' ' + x2 + ',' + y2;
    } else if (num === 2) {
      return 'M' + x1 + ',' + y1 + 'Q' + controlB[0] + ',' + controlB[1] + ' ' + x2 + ',' + y2;
    } else if (num === 1) {
      return 'M' + x1 + ',' + y1 + 'Q' + controlA[0] + ',' + controlA[1] + ' ' + x2 + ',' + y2;
    } else {
      return 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;
    }
  }

  function canvasFilter(filter) {
    var s = '';
    filter.forEach(function (item) {
      var k = item.k,
          v = item.v;

      if (k === 'blur') {
        s += "blur(".concat(v, "px)");
      } else if (k === 'dropShadow') {
        // 浏览器暂未支持spread，去掉v[3]
        s += "drop-shadow(".concat(v[0], "px ").concat(v[1], "px ").concat(v[2], "px ").concat(int2rgba$3(v[4]), ")");
      } else if (k === 'hueRotate') {
        s += "hue-rotate(".concat(v, "deg)");
      } else if (k === 'saturate' || k === 'brightness' || k === 'grayscale' || k === 'contrast' || k === 'sepia' || k === 'invert') {
        s += "".concat(k, "(").concat(v, "%)");
      }
    });
    return s;
  }

  var painter = {
    canvasPolygon: canvasPolygon$7,
    svgPolygon: svgPolygon$6,
    canvasLine: canvasLine,
    svgLine: svgLine,
    canvasFilter: canvasFilter,
    svgFilter: canvasFilter
  };

  var H = geom$1.H;
  var PX$a = o$4.PX,
      PERCENT$9 = o$4.PERCENT,
      REM$9 = o$4.REM,
      VW$9 = o$4.VW,
      VH$9 = o$4.VH,
      VMAX$9 = o$4.VMAX,
      VMIN$9 = o$4.VMIN;
  var canvasPolygon$6 = painter.canvasPolygon,
      svgPolygon$5 = painter.svgPolygon;
  var _enums$STYLE_KEY$j = enums.STYLE_KEY,
      BORDER_LEFT_WIDTH$9 = _enums$STYLE_KEY$j.BORDER_LEFT_WIDTH,
      BORDER_TOP_WIDTH$7 = _enums$STYLE_KEY$j.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$6 = _enums$STYLE_KEY$j.BORDER_BOTTOM_WIDTH,
      PADDING_LEFT$9 = _enums$STYLE_KEY$j.PADDING_LEFT,
      PADDING_BOTTOM$6 = _enums$STYLE_KEY$j.PADDING_BOTTOM,
      PADDING_TOP$7 = _enums$STYLE_KEY$j.PADDING_TOP,
      BORDER_TOP_LEFT_RADIUS$4 = _enums$STYLE_KEY$j.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$3 = _enums$STYLE_KEY$j.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$4 = _enums$STYLE_KEY$j.BORDER_BOTTOM_LEFT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$4 = _enums$STYLE_KEY$j.BORDER_BOTTOM_RIGHT_RADIUS,
      FONT_SIZE$b = _enums$STYLE_KEY$j.FONT_SIZE;
  /* 获取合适的虚线实体空白宽度ps/pd和数量n
   * 总长total，start边长bs，end边长be，内容长w，
   * 实体长范围[smin,smax]，空白长范围[dmin,dmax]
   */

  function calFitDashed(total, bs, be, w, smin, smax, dmin, dmax) {
    var n = 1;
    var ps = 1;
    var pd = 1; // 从最大实体空白长开始尝试

    outer: for (var i = smax; i >= smin; i--) {
      for (var j = dmax; j >= dmin; j--) {
        // 已知实体空白长度，n实体和n-1空白组成total，计算获取n数量
        var per = i + j;
        var num = Math.floor((total + j) / per);
        var k = j; // 可能除不尽，此时扩展空白长

        if (num * per < j + total) {
          var free = total - num * i;
          k = free / (num - 1);

          if (k > dmax) {
            continue;
          }
        }

        per = i + k; // bs比实体大才有效，因为小的话必定和第一个实体完整相连

        if (bs > 1 && bs > i) {
          var mo = bs % per;

          if (mo > i) {
            continue;
          }

          if (be > 1) {
            var _mo = (bs + w) % per;

            if (_mo > i) {
              continue;
            }
          }
        }

        if (be > 1) {
          var _mo2 = (bs + w) % per;

          if (_mo2 > i) {
            continue;
          }
        }

        if (num > 0) {
          n = num;
          ps = i;
          pd = k;
        }

        break outer;
      }
    }

    return {
      n: n,
      ps: ps,
      pd: pd
    };
  } // dashed时n个实线和n-1虚线默认以3:1宽度组成，dotted则是n和n以1:1组成


  function calDashed(style, m1, m2, m3, m4, bw) {
    var total = m4 - m1;
    var w = m3 - m2;
    var bs = m2 - m1;
    var be = m4 - m3;

    if (style === 'dotted') {
      return calFitDashed(total, bs, be, w, bw, bw, Math.max(1, bw * 0.25), bw * 2);
    } else {
      var _calFitDashed = calFitDashed(total, bs, be, w, bw, bw * 3, Math.max(1, bw * 0.25), bw * 2),
          n = _calFitDashed.n,
          ps = _calFitDashed.ps,
          pd = _calFitDashed.pd;

      if (n === 1) {
        return calFitDashed(total, bs, be, w, bw, bw, Math.max(1, bw * 0.25), bw * 2);
      } // 降级为dotted


      return {
        n: n,
        ps: ps,
        pd: pd
      };
    }
  } // 获取边框分割为几块的坐标，虚线分割为若干四边形、三边型、五边形
  // 三边形重复内外边交点形成四边形，五边形进行切割形成2个四边形
  // direction为上右下左0123


  function calPoints(borderWidth, borderStyle, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, direction, beginRadius, endRadius) {
    var points = [];

    if (borderStyle === 'none') {
      return points;
    }

    if (['dashed', 'dotted'].indexOf(borderStyle) > -1) {
      // 寻找一个合适的虚线线段长度和之间空白边距长度
      var _ref = direction === 0 || direction === 2 ? calDashed(borderStyle, x1, x2, x3, x4, borderWidth) : calDashed(borderStyle, y1, y2, y3, y4, borderWidth),
          n = _ref.n,
          ps = _ref.ps,
          pd = _ref.pd;

      if (n > 1) {
        for (var i = 0; i < n; i++) {
          // 最后一个可能没有到底，延长之
          var isLast = i === n - 1;
          var main1 = void 0;
          var main2 = void 0;
          var cross1 = void 0;
          var cross2 = void 0;

          if (direction === 0 || direction === 2) {
            main1 = i ? x1 + ps * i + pd * i : x1;
          } else {
            main1 = i ? y1 + ps * i + pd * i : y1;
          }

          main2 = main1 + ps;

          if (direction === 0) {
            // 整个和borderLeft重叠
            if (main2 <= x2) {
              if (isLast) {
                points.push([[x1, y1], [x4, y1], [x3, y2], [x2, y2]]);
              } else {
                cross1 = y1 + (main1 - x1) * Math.tan(deg1);
                cross2 = y1 + (main2 - x1) * Math.tan(deg1);
                points.push([[main1, y1], [main2, y1], [main2, cross2], [main1, cross1]]);
              }
            } // 整个和borderRight重叠
            else if (main1 >= x3) {
              cross1 = y1 + (x4 - main1) * Math.tan(deg2);
              cross2 = y1 + (x4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[main1, y1], [x4, y1], [x4, y1], [main1, cross1]]);
              } else {
                points.push([[main1, y1], [main2, y1], [main2, cross2], [main1, cross1]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderLeft重叠
              if (main1 < x2) {
                cross1 = y1 + (main1 - x1) * Math.tan(deg1);
                points.push([[main1, y1], [x2, y1], [x2, y2], [main1, cross1]]);

                if (isLast) {
                  points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
                  points.push([[x3, y1], [x4, y1], [x4, y1], [x2, y2]]);
                } else {
                  // 下部分和borderRight重叠
                  if (main2 > x3) {
                    cross2 = y1 + (x4 - main2) * Math.tan(deg2);
                    points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
                    points.push([[x3, y1], [main2, y1], [main2, cross2], [x3, y2]]);
                  } // 下部独立
                  else {
                    points.push([[x2, y1], [main2, y1], [main2, y2], [x2, y2]]);
                  }
                }
              } // 下部分和borderRight重叠
              else if (main2 > x3) {
                cross1 = y1 + (x4 - main2) * Math.tan(deg2); // 上部分和borderLeft重叠

                if (main1 < x2) {
                  cross2 = y1 + (main1 - x1) * Math.tan(deg1);
                  points.push([[main1, y1], [x2, y1], [x2, y2], [main1, cross2]]);
                  points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);

                  if (isLast) {
                    points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
                  } else {
                    points.push([[x3, y1], [main2, y1], [main2, cross1], [x3, y2]]);
                  }
                } // 上部独立
                else {
                  points.push([[main1, y1], [x3, y1], [x3, y2], [main1, y2]]);

                  if (isLast) {
                    points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
                  } else {
                    points.push([[x3, y1], [main2, y1], [main2, cross1], [x3, y2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[main1, y1], [x4, y1], [x3, y2], [main1, y2]]);
                } else {
                  points.push([[main1, y1], [main2, y1], [main2, y2], [main1, y2]]);
                }
              }
            }
          } else if (direction === 1) {
            // 整个和borderTop重叠
            if (main2 <= y2) {
              if (isLast) {
                points.push([[x3, y2], [x4, y1], [x4, y4], [x3, y3]]);
              } else {
                cross1 = x4 - (main1 - y1) * Math.tan(deg1);
                cross2 = x4 - (main2 - y1) * Math.tan(deg1);
                points.push([[cross1, main1], [x4, main1], [x4, main2], [cross2, main2]]);
              }
            } // 整个和borderBottom重叠
            else if (main1 >= y3) {
              cross1 = x3 + (main1 - y3) * Math.tan(deg2);
              cross2 = x3 + (main2 - y3) * Math.tan(deg2);

              if (isLast) {
                points.push([[cross1, main1], [x4, main1], [x4, y4], [x4, y4]]);
              } else {
                points.push([[cross1, main1], [x4, main1], [x4, main2], [cross2, main2]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderTop重叠
              if (main1 < y2) {
                cross1 = x3 + (y2 - main1) * Math.tan(deg1);
                points.push([[cross1, main1], [x4, main1], [x4, y2], [x3, y2]]);

                if (isLast) {
                  points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
                  points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
                } else {
                  // 下部分和borderBottom重叠
                  if (main2 > y3) {
                    cross2 = x3 + (main2 - y3) * Math.tan(deg2);
                    points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross2, main2]]);
                  } // 下部独立
                  else {
                    points.push([[x3, y2], [x4, y2], [x4, main2], [x3, main2]]);
                  }
                }
              } // 下部分和borderBottom重叠
              else if (main2 > y3) {
                cross1 = x3 + (main2 - y3) * Math.tan(deg2); // 上部分和borderTop重叠

                if (main1 < y2) {
                  cross2 = x3 + (y2 - main1) * Math.tan(deg1);
                  points.push([[cross2, main1], [x4, main1], [x4, y2], [x3, y2]]);
                  points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y3], [x4, x4], [x4, x4]]);
                  } else {
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross1, main2]]);
                  }
                } // 上部独立
                else {
                  points.push([[x3, main1], [x4, main1], [x4, y3], [x3, y3]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
                  } else {
                    points.push([[x3, y3], [x4, y3], [x4, main2], [cross1, main2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[x3, main1], [x4, main1], [x4, y4], [x3, y3]]);
                } else {
                  points.push([[x3, main1], [x4, main1], [x4, main2], [x3, main2]]);
                }
              }
            }
          } else if (direction === 2) {
            // 整个和borderLeft重叠
            if (main2 <= x2) {
              if (isLast) {
                points.push([[x1, y4], [x2, y3], [x3, y3], [x4, y4]]);
              } else {
                cross1 = y4 - (main1 - x1) * Math.tan(deg1);
                cross2 = y4 - (main2 - x1) * Math.tan(deg1);
                points.push([[main1, cross1], [main2, cross2], [main2, y4], [main1, y4]]);
              }
            } // 整个和borderRight重叠
            else if (main1 >= x3) {
              cross1 = y4 - (x4 - main1) * Math.tan(deg2);
              cross2 = y4 - (x4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[main1, cross1], [x4, y4], [x4, y4], [main1, y4]]);
              } else {
                points.push([[main1, cross1], [main2, cross2], [main2, y4], [main1, y4]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderLeft重叠
              if (main1 < x2) {
                cross1 = y4 - (main1 - x1) * Math.tan(deg1);
                points.push([[main1, cross1], [x2, y3], [x2, y4], [main1, y4]]);

                if (isLast) {
                  points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
                  points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                } else {
                  // 下部分和borderRight重叠
                  if (main2 > x3) {
                    cross2 = y4 - (main2 - x3) * Math.tan(deg2);
                    points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
                    points.push([[x3, y3], [main2, cross2], [main2, y4], [x3, y4]]);
                  } // 下部独立
                  else {
                    points.push([[x2, y3], [main2, y3], [main2, y4], [x2, y4]]);
                  }
                }
              } // 下部分和borderRight重叠
              else if (main2 > x3) {
                cross1 = y4 - (x4 - main2) * Math.tan(deg2); // 上部分和borderLeft重叠

                if (main1 < x2) {
                  cross2 = y4 - (main1 - x3) * Math.tan(deg1);
                  points.push([[main1, cross2], [x2, y3], [x2, y4], [main1, y4]]);
                  points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                  } else {
                    points.push([[x3, y3], [main2, cross1], [main2, y4], [x3, y4]]);
                  }
                } // 上部独立
                else {
                  points.push([[main1, y3], [x3, y3], [x3, y4], [main1, y4]]);

                  if (isLast) {
                    points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
                  } else {
                    points.push([[x3, y3], [main2, cross1], [main2, y4], [x3, y4]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[main1, y3], [x3, y3], [x4, y4], [main1, y4]]);
                } else {
                  points.push([[main1, y3], [main2, y3], [main2, y4], [main1, y4]]);
                }
              }
            }
          } else if (direction === 3) {
            // 整个和borderTop重叠
            if (main2 <= y2) {
              if (isLast) {
                points.push([[x1, y1], [x2, y2], [x2, y3], [x1, y4]]);
              } else {
                cross1 = x1 + (main1 - y1) * Math.tan(deg1);
                cross2 = x1 + (main2 - y1) * Math.tan(deg1);
                points.push([[x1, main1], [cross1, main1], [cross2, main2], [x1, main2]]);
              }
            } // 整个和borderBottom重叠
            else if (main1 >= y3) {
              cross1 = x1 + (y4 - main1) * Math.tan(deg2);
              cross2 = x1 + (y4 - main2) * Math.tan(deg2);

              if (isLast) {
                points.push([[x1, main1], [cross1, main1], [x1, y4], [x1, y4]]);
              } else {
                points.push([[x1, main1], [cross1, main1], [cross2, main2], [x1, main2]]);
              }
            } // 不被整个重叠的情况再细分
            else {
              // 上部分和borderTop重叠
              if (main1 < y2) {
                cross1 = x1 + (main1 - y1) * Math.tan(deg1);
                points.push([[x1, main1], [cross1, main1], [x2, y2], [x1, y2]]);

                if (isLast) {
                  points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
                  points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                } else {
                  // 下部分和borderBottom重叠
                  if (main2 > y3) {
                    cross2 = x1 + (y4 - main2) * Math.tan(deg2);
                    points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
                    points.push([[x1, y3], [x2, y3], [cross2, main2], [x1, main2]]);
                  } // 下部独立
                  else {
                    points.push([[x1, y2], [x2, y2], [x2, main2], [x1, main2]]);
                  }
                }
              } // 下部分和borderBottom重叠
              else if (main2 > y3) {
                cross1 = x1 + (y4 - main2) * Math.tan(deg2); // 上部分和borderTop重叠

                if (main1 < y2) {
                  cross2 = x1 + (main1 - y1) * Math.tan(deg1);
                  points.push([[x1, main1], [cross2, main1], [x2, y2], [x1, y1]]);
                  points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);

                  if (isLast) {
                    points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                  } else {
                    points.push([[x1, y3], [x2, y3], [cross1, main2], [x1, main2]]);
                  }
                } // 上部独立
                else {
                  points.push([[x1, main1], [x2, main1], [x2, y3], [x1, y3]]);

                  if (isLast) {
                    points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
                  } else {
                    points.push([[x1, y3], [x2, y3], [cross1, main2], [x1, main2]]);
                  }
                }
              } // 完全独立
              else {
                if (isLast) {
                  points.push([[x1, main1], [x2, main1], [x2, y3], [x1, y4]]);
                } else {
                  points.push([[x1, main1], [x2, main1], [x2, main2], [x1, main2]]);
                }
              }
            }
          }
        }

        if (direction === 0) {
          return calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 1) {
          return calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 2) {
          return calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        } else if (direction === 3) {
          return calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
        }
      }
    } // 兜底返回实线


    if (direction === 0) {
      if (x2 > x1) {
        points.push([[x1, y1], [x2, y1], [x2, y2], [x1, y1]]);
      }

      points.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);

      if (x4 > x3) {
        points.push([[x3, y1], [x4, y1], [x4, y1], [x3, y2]]);
      }

      return calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 1) {
      if (y2 > y1) {
        points.push([[x4, y1], [x4, y1], [x4, y2], [x3, y2]]);
      }

      points.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);

      if (y4 > y3) {
        points.push([[x3, y3], [x4, y3], [x4, y4], [x4, y4]]);
      }

      return calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 2) {
      if (x2 > x1) {
        points.push([[x1, y4], [x2, y3], [x2, y4], [x1, y4]]);
      }

      points.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);

      if (x4 > x3) {
        points.push([[x3, y3], [x4, y4], [x4, y4], [x3, y4]]);
      }

      return calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    } else if (direction === 3) {
      if (y2 > y1) {
        points.push([[x1, y1], [x1, y1], [x2, y2], [x1, y2]]);
      }

      points.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);

      if (y4 > y3) {
        points.push([[x1, y3], [x2, y3], [x1, y4], [x1, y4]]);
      }

      return calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, points, beginRadius, endRadius);
    }
  }

  function calTopRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius = _slicedToArray(beginRadius, 2),
        brx = _beginRadius[0],
        bry = _beginRadius[1];

    var _endRadius = _slicedToArray(endRadius, 2),
        erx = _endRadius[0],
        ery = _endRadius[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，左圆角、右圆角、中间矩形，3个区域2个坐标；当左右圆角相接时中间矩形为0即中间2个坐标相等


    var oxl = x2 + brx - (x2 - x1);
    var oxr = x3 - erx + (x4 - x3); // 先拆分，当一块四边形跨越左右圆角和中间非圆角时被拆为3份，只跨一边圆角拆2份，不跨不处理
    // 也有可能左右圆角相接，跨越的只分为左右2份
    // 最终左圆角内的存入begin，右圆角内的存入end，中间center

    var beginList = [];
    var centerList = [];
    var endList = [];

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在左圆角

      if (points[1][0] < oxl) {
        beginList.push(points);
      } // 全在右圆角
      else if (points[0][0] > oxr) {
        endList.push(points);
      } // 跨越左右圆角
      else if (points[1][0] > oxr && points[0][0] < oxl) {
        var ya = oxl < x2 ? y1 + Math.tan(deg1) * (oxl - x1) : y2;
        var yb = oxr > x3 ? y1 + Math.tan(deg2) * (x4 - oxr) : y2;
        beginList.push([points[0], [oxl, y1], [oxl, ya], points[3]]);

        if (oxl < oxr) {
          if (oxl > x2 && oxr < x3) {
            centerList.push([[oxl, y1], [oxr, y1], [oxr, y2], [oxl, y2]]);
          } else if (oxl > x2) {
            centerList.push([[oxl, y1], [x3, y1], [x3, y2], [oxl, y2]]);
            centerList.push([[x3, y1], [oxr, y1], [oxr, yb], [x3, y2]]);
          } else if (oxr < x3) {
            centerList.push([[oxl, y1], [x2, y1], [x2, y2], [oxl, ya]]);
            centerList.push([[x2, y1], [oxr, y1], [oxr, y2], [x2, y2]]);
          } else {
            centerList.push([[oxl, y1], [x2, y1], [x2, y2], [oxl, ya]]);
            centerList.push([[x2, y1], [x3, y1], [x3, y2], [x2, y2]]);
            centerList.push([[x3, y1], [oxr, y1], [oxr, yb], [x3, y2]]);
          }
        }

        endList.push([[oxr, y1], points[1], points[2], [oxr, yb]]);
      } // 跨越右圆角
      else if (points[1][0] > oxr) {
        var y = oxr > x3 ? y1 + Math.tan(deg2) * (x4 - oxr) : y2;
        centerList.push([points[0], [oxr, y1], [oxr, y], points[3]]);
        endList.push([[oxr, y1], points[1], points[2], [oxr, y]]);
      } // 跨越左圆角
      else if (points[0][0] < oxl) {
        var _y = oxl < x2 ? y1 + Math.tan(deg1) * (oxl - x1) : y2;

        beginList.push([points[0], [oxl, y1], [oxl, _y], points[3]]);
        centerList.push([[oxl, y1], points[1], points[2], [oxl, _y]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var needInner = brx > x2 - x1 && borderWidth < bry; // 算这个角度是为了头部和上条边相交线的延长线

      var crossDeg = Math.atan((x2 - x1) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oyl = y1 + bry;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var xa, _ya, xb, _yb;

      var ca = calBezierTopLeft(beginList[0][0], beginList[0][1], oxl, oyl, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca$ = _slicedToArray(ca[0], 2);

      xa = _ca$[0];
      _ya = _ca$[1];
      var cb;

      if (needInner) {
        cb = calBezierTopLeft(beginList[0][3], beginList[0][2], oxl, oyl, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb$ = _slicedToArray(cb[0], 2);

        xb = _cb$[0];
        _yb = _cb$[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierTopLeft(points[0], points[1], oxl, oyl, sx1, ry1);

          if (needInner) {
            controls2 = calBezierTopLeft(points[3], points[2], oxl, oyl, sx2, ry2);
          }
        }

        for (var _i = 0, _len = controls1.length; _i < _len; _i++) {
          limit(controls1[_i], xa, _ya, 0);
        }

        points[0] = controls1[0];

        if (controls1[1]) {
          points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
        }

        if (needInner) {
          for (var _i2 = 0, _len2 = controls2.length; _i2 < _len2; _i2++) {
            limit(controls2[_i2], xb, _yb, 0);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        }
      });
    }

    var endLength = endList.length;

    if (endLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var _needInner = erx > x4 - x3 && borderWidth < ery; // 算这个角度是为了最后和下条边相交线的延长线


      var _crossDeg = Math.atan((x4 - x3) / (y2 - y1));

      var _rx = erx;
      var _ry = ery;

      var _sx = _ry / _rx;

      var oyr = y1 + ery;

      var _rx2 = erx - (x4 - x3);

      var _ry2 = ery - (y2 - y1);

      var _sx2 = _ry2 / _rx2; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa, _ya2, _xb, _yb2;

      var _ca = calBezierTopRight(endList[endLength - 1][0], endList[endLength - 1][1], oxr, oyr, _sx, _ry, true, Math.tan(_crossDeg) * _ry);

      var _ca2 = _slicedToArray(_ca[_ca.length - 1], 2);

      _xa = _ca2[0];
      _ya2 = _ca2[1];

      var _cb;

      if (_needInner) {
        _cb = calBezierTopRight(endList[endLength - 1][3], endList[endLength - 1][2], oxr, oyr, _sx2, _ry2, true, Math.tan(_crossDeg) * _ry2);

        var _cb2 = _slicedToArray(_cb[_cb.length - 1], 2);

        _xb = _cb2[0];
        _yb2 = _cb2[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca;

          if (_needInner) {
            controls2 = _cb;
          }
        } else {
          controls1 = calBezierTopRight(points[0], points[1], oxr, oyr, _sx, _ry);

          if (_needInner) {
            controls2 = calBezierTopRight(points[3], points[2], oxr, oyr, _sx2, _ry2);
          }
        }

        for (var _i3 = 0, _len3 = controls1.length; _i3 < _len3; _i3++) {
          limit(controls1[_i3], _xa, _ya2, 1);
        }

        points[0] = controls1[0];

        if (controls1[1]) {
          points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
        }

        if (_needInner) {
          for (var _i4 = 0, _len4 = controls2.length; _i4 < _len4; _i4++) {
            limit(controls2[_i4], _xb, _yb2, 1);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        }
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierTopLeft(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p = _slicedToArray(p1, 2),
        p1x = _p[0],
        p1y = _p[1];

    var _p2 = _slicedToArray(p2, 2),
        p2x = _p2[0],
        p2y = _p2[1];

    var dx1 = -p1x + ox;
    var dsx1 = dx1 * sx;
    var dx2 = -p2x + ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1; // 最初的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom$1.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(p1x, p1y, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(p2x, p2y, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calBezierTopRight(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p3 = _slicedToArray(p1, 2),
        p1x = _p3[0],
        p1y = _p3[1];

    var _p4 = _slicedToArray(p2, 2),
        p2x = _p4[0],
        p2y = _p4[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (oy - p1y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy - Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2; // 最后的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy - Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (oy - p2y));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy - Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom$1.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calRightRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius2 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius2[0],
        bry = _beginRadius2[1];

    var _endRadius2 = _slicedToArray(endRadius, 2),
        erx = _endRadius2[0],
        ery = _endRadius2[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，上圆角、下圆角、中间矩形，3个区域2个坐标；当上下圆角相接时中间矩形为0即中间2个坐标相等


    var oyt = y2 + bry - (y2 - y1);
    var oyb = y3 - ery + (y4 - y3);
    var beginList = [];
    var centerList = [];
    var endList = []; // 同borderTop拆分

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在上圆角

      if (points[2][1] < oyt) {
        beginList.push(points);
      } // 全在下圆角
      else if (points[1][1] > oyb) {
        endList.push(points);
      } // 跨越上下圆角
      else if (points[2][1] > oyb && points[1][1] < oyt) {
        var xa = oyt < y2 ? x3 + Math.tan(deg2) * (y2 - oyt) : x3;
        var xb = oyb > y3 ? x3 + Math.tan(deg1) * (oyb - y3) : x3;
        beginList.push([points[0], points[1], [x4, oyt], [xa, oyt]]);

        if (oyt < oyb) {
          if (oyb < y3 && oyt > y2) {
            centerList.push([[x3, oyt], [x4, oyt], [x4, oyb], [x3, oyb]]);
          } else if (oyt > y2) {
            centerList.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
            centerList.push([[x3, y3], [x4, y3], [x4, oyb], [xb, oyb]]);
          } else if (oyb < y3) {
            centerList.push([[xa, oyt], [x4, oyt], [x4, y2], [x3, y2]]);
            centerList.push([[x3, y2], [x4, y2], [x4, oyb], [x3, oyb]]);
          } else {
            centerList.push([[xa, oyt], [x4, oyt], [x4, y2], [x3, y2]]);
            centerList.push([[x3, y2], [x4, y2], [x4, y3], [x3, y3]]);
            centerList.push([[x3, y3], [x4, y3], [x4, oyb], [xb, oyb]]);
          }
        }

        endList.push([[xb, oyb], [x4, oyb], points[2], points[3]]);
      } // 跨越下圆角
      else if (points[2][1] > oyb) {
        var x = oyb > y3 ? x3 + Math.tan(deg1) * (oyb - y3) : x3;
        centerList.push([points[0], points[1], [x4, oyb], [x, oyb]]);
        endList.push([[x, oyb], [x4, oyb], points[2], points[3]]);
      } // 跨越上圆角
      else if (points[1][1] < oyt) {
        var _x = oyt < y2 ? x3 + Math.tan(deg2) * (y2 - oyt) : x3;

        beginList.push([points[0], points[1], [x4, oyt], [_x, oyt]]);
        centerList.push([[_x, oyt], [x4, oyt], points[2], points[3]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      var needInner = bry > y2 - y1 && borderWidth < brx;
      var crossDeg = Math.atan((x4 - x3) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oxt = x4 - brx;
      var rx2 = brx - (x4 - x3);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var _xa2, ya, _xb2, yb;

      var ca = calBezierRightTop(beginList[0][1], beginList[0][2], oxt, oyt, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca3 = _slicedToArray(ca[ca.length - 1], 2);

      _xa2 = _ca3[0];
      ya = _ca3[1];
      var cb;

      if (needInner) {
        cb = calBezierRightTop(beginList[0][0], beginList[0][3], oxt, oyt, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb3 = _slicedToArray(cb[cb.length - 1], 2);

        _xb2 = _cb3[0];
        yb = _cb3[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierRightTop(points[1], points[2], oxt, oyt, sx1, ry1);

          if (needInner) {
            controls2 = calBezierRightTop(points[0], points[3], oxt, oyt, sx2, ry2);
          }
        }

        for (var _i5 = 0, _len5 = controls1.length; _i5 < _len5; _i5++) {
          limit(controls1[_i5], _xa2, ya, 2);
        }

        if (needInner) {
          for (var _i6 = 0, _len6 = controls2.length; _i6 < _len6; _i6++) {
            limit(controls2[_i6], _xb2, yb, 2);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[2] = points[3];
          points[3] = points[0];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    var endLength = endList.length;

    if (endLength) {
      var _needInner2 = ery > y4 - y3 && borderWidth < erx;

      var _crossDeg2 = Math.atan((x4 - x3) / (y4 - y3));

      var _rx3 = erx;
      var _ry3 = ery;

      var _sx3 = _ry3 / _rx3;

      var oxb = x4 - erx;

      var _rx4 = erx - (x4 - x3);

      var _ry4 = ery - (y4 - y3);

      var _sx4 = _ry4 / _rx4; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa3, _ya3, _xb3, _yb3;

      var _ca4 = calBezierRightBottom(endList[endLength - 1][1], endList[endLength - 1][2], oxb, oyb, _sx3, _ry3, true, Math.tan(_crossDeg2) * _ry3);

      var _ca4$ = _slicedToArray(_ca4[0], 2);

      _xa3 = _ca4$[0];
      _ya3 = _ca4$[1];

      var _cb4;

      if (_needInner2) {
        _cb4 = calBezierRightBottom(endList[endLength - 1][0], endList[endLength - 1][3], oxb, oyb, _sx4, _ry4, true, Math.tan(_crossDeg2) * _ry4);

        var _cb4$ = _slicedToArray(_cb4[0], 2);

        _xb3 = _cb4$[0];
        _yb3 = _cb4$[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca4;

          if (_needInner2) {
            controls2 = _cb4;
          }
        } else {
          controls1 = calBezierRightBottom(points[1], points[2], oxb, oyb, _sx3, _ry3);

          if (_needInner2) {
            controls2 = calBezierRightBottom(points[0], points[3], oxb, oyb, _sx4, _ry4);
          }
        }

        for (var _i7 = 0, _len7 = controls1.length; _i7 < _len7; _i7++) {
          limit(controls1[_i7], _xa3, _ya3, 3);
        }

        if (_needInner2) {
          for (var _i8 = 0, _len8 = controls2.length; _i8 < _len8; _i8++) {
            limit(controls2[_i8], _xb3, _yb3, 3);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[2] = points[3];
          points[3] = points[0];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierRightTop(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p5 = _slicedToArray(p1, 2),
        p1x = _p5[0],
        p1y = _p5[1];

    var _p6 = _slicedToArray(p2, 2),
        p2x = _p6[0],
        p2y = _p6[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox + Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1;

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox + Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox + Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom$1.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#000';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBezierRightBottom(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p7 = _slicedToArray(p1, 2),
        p1x = _p7[0],
        p1y = _p7[1];

    var _p8 = _slicedToArray(p2, 2),
        p2x = _p8[0],
        p2y = _p8[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2;

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom$1.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBottomRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius3 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius3[0],
        bry = _beginRadius3[1];

    var _endRadius3 = _slicedToArray(endRadius, 2),
        erx = _endRadius3[0],
        ery = _endRadius3[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，左圆角、右圆角、中间矩形，3个区域2个坐标；当左右圆角相接时中间矩形为0即中间2个坐标相等


    var oxl = x2 + brx - (x2 - x1);
    var oxr = x3 - erx + (x4 - x3); // 先拆分，当一块四边形跨越左右圆角和中间非圆角时被拆为3份，只跨一边圆角拆2份，不跨不处理
    // 也有可能左右圆角相接，跨越的只分为左右2份
    // 最终左圆角内的存入begin，右圆角内的存入end，中间center

    var beginList = [];
    var centerList = [];
    var endList = [];

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在左圆角

      if (points[2][0] < oxl) {
        beginList.push(points);
      } // 全在右圆角
      else if (points[3][0] > oxr) {
        endList.push(points);
      } // 跨越左右圆角
      else if (points[2][0] > oxr && points[3][0] < oxl) {
        var ya = oxl < x2 ? y4 - Math.tan(deg1) * (oxl - x1) : y2;
        var yb = oxr > x3 ? y4 - Math.tan(deg2) * (x4 - oxr) : y3;
        beginList.push([points[0], [oxl, ya], [oxl, y4], points[3]]);

        if (oxl < oxr) {
          if (oxl > x2 && oxr < x3) {
            centerList.push([[oxl, y3], [oxr, y3], [oxr, y4], [oxl, y4]]);
          } else if (oxl > x2) {
            centerList.push([[oxl, y3], [x3, y3], [x3, y4], [oxl, y4]]);
            centerList.push([[x3, y3], [oxr, yb], [oxr, y4], [x3, y4]]);
          } else if (oxr < x3) {
            centerList.push([[oxl, ya], [x2, y3], [x2, y4], [oxl, y4]]);
            centerList.push([[x2, y3], [oxr, y3], [oxr, y4], [x2, y4]]);
          } else {
            centerList.push([[oxl, ya], [x2, y3], [x2, y4], [oxl, y4]]);
            centerList.push([[x2, y3], [x3, y3], [x3, y4], [x2, y4]]);
            centerList.push([[x3, y3], [oxr, yb], [oxr, y4], [x3, y4]]);
          }
        }

        endList.push([[oxr, yb], points[1], points[2], [oxr, y4]]);
      } // 跨越右圆角
      else if (points[2][0] > oxr) {
        var y = oxr > x3 ? y4 - Math.tan(deg2) * (x4 - oxr) : y3;
        centerList.push([points[0], [oxr, y], [oxr, y4], points[3]]);
        endList.push([[oxr, y], points[1], points[2], [oxr, y4]]);
      } // 跨越左圆角
      else if (points[3][0] < oxl) {
        var _y2 = oxl < x2 ? y4 - Math.tan(deg1) * (oxl - x1) : y3;

        beginList.push([points[0], [oxl, _y2], [oxl, y4], points[3]]);
        centerList.push([[oxl, _y2], points[1], points[2], [oxl, y4]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var needInner = brx > x2 - x1 && borderWidth < bry; // 算这个角度是为了头部和上条边相交线的延长线

      var crossDeg = Math.atan((x2 - x1) / (y4 - y3));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oyl = y4 - bry;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y4 - y3);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var xa, _ya4, xb, _yb4;

      var ca = calBezierBottomLeft(beginList[0][3], beginList[0][2], oxl, oyl, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca$2 = _slicedToArray(ca[0], 2);

      xa = _ca$2[0];
      _ya4 = _ca$2[1];
      var cb;

      if (needInner) {
        cb = calBezierBottomLeft(beginList[0][0], beginList[0][1], oxl, oyl, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb$2 = _slicedToArray(cb[0], 2);

        xb = _cb$2[0];
        _yb4 = _cb$2[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierBottomLeft(points[3], points[2], oxl, oyl, sx1, ry1);

          if (needInner) {
            controls2 = calBezierBottomLeft(points[0], points[1], oxl, oyl, sx2, ry2);
          }
        }

        for (var _i9 = 0, _len9 = controls1.length; _i9 < _len9; _i9++) {
          limit(controls1[_i9], xa, _ya4, 4);
        }

        if (needInner) {
          for (var _i10 = 0, _len10 = controls2.length; _i10 < _len10; _i10++) {
            limit(controls2[_i10], xb, _yb4, 4);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        } else {
          points[2] = points[1];
          points[3] = points[0];
        }

        points[0] = controls1[0];

        if (controls1[1]) {
          points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
        }
      });
    }

    var endLength = endList.length;

    if (endLength) {
      // 边宽可能大于圆角尺寸，边的里面无需圆弧化
      var _needInner3 = erx > x4 - x3 && borderWidth < ery; // 算这个角度是为了最后和下条边相交线的延长线


      var _crossDeg3 = Math.atan((x4 - x3) / (y4 - y3));

      var _rx5 = erx;
      var _ry5 = ery;

      var _sx5 = _ry5 / _rx5;

      var oyr = y4 - ery;

      var _rx6 = erx - (x4 - x3);

      var _ry6 = ery - (y4 - y3);

      var _sx6 = _ry6 / _rx6; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa4, _ya5, _xb4, _yb5;

      var _ca5 = calBezierBottomRight(endList[endLength - 1][3], endList[endLength - 1][2], oxr, oyr, _sx5, _ry5, true, Math.tan(_crossDeg3) * _ry5);

      var _ca6 = _slicedToArray(_ca5[_ca5.length - 1], 2);

      _xa4 = _ca6[0];
      _ya5 = _ca6[1];

      var _cb5;

      if (_needInner3) {
        _cb5 = calBezierBottomRight(endList[endLength - 1][0], endList[endLength - 1][1], oxr, oyr, _sx6, _ry6, true, Math.tan(_crossDeg3) * _ry6);

        var _cb6 = _slicedToArray(_cb5[_cb5.length - 1], 2);

        _xb4 = _cb6[0];
        _yb5 = _cb6[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca5;

          if (_needInner3) {
            controls2 = _cb5;
          }
        } else {
          controls1 = calBezierBottomRight(points[3], points[2], oxr, oyr, _sx5, _ry5);

          if (_needInner3) {
            controls2 = calBezierBottomRight(points[0], points[1], oxr, oyr, _sx6, _ry6);
          }
        }

        for (var _i11 = 0, _len11 = controls1.length; _i11 < _len11; _i11++) {
          limit(controls1[_i11], _xa4, _ya5, 5);
        }

        if (_needInner3) {
          for (var _i12 = 0, _len12 = controls2.length; _i12 < _len12; _i12++) {
            limit(controls2[_i12], _xb4, _yb5, 5);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[3];
            points[3] = controls2[2].concat(controls2[1]).concat(controls2[0]);
          }
        } else {
          points[2] = points[1];
          points[3] = points[0];
        }

        points[0] = controls1[0];

        if (controls1[1]) {
          points[1] = controls1[1].concat(controls1[2]).concat(controls1[3]);
        }
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierBottomLeft(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p9 = _slicedToArray(p1, 2),
        p1x = _p9[0],
        p1y = _p9[1];

    var _p10 = _slicedToArray(p2, 2),
        p2x = _p10[0],
        p2y = _p10[1];

    var dx1 = -p1x + ox;
    var dsx1 = dx1 * sx;
    var dx2 = -p2x + ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (p2y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy + Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1; // 最初的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy + Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (p1y - oy));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy + Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom$1.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calBezierBottomRight(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p11 = _slicedToArray(p1, 2),
        p1x = _p11[0],
        p1y = _p11[1];

    var _p12 = _slicedToArray(p2, 2),
        p2x = _p12[0],
        p2y = _p12[1];

    var dx1 = p1x - ox;
    var dsx1 = dx1 * sx;
    var dx2 = p2x - ox;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox + Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2; // 最后的是两条border的交界线，需要特殊求交界线延长和椭圆的交点，不能直连圆心求交点

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox + Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox + Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom$1.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox + cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox + cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx1, cpy1], [cx1, cy1], [cx2, cy2], [cpx2, cpy2]];
  }

  function calLeftRadiusPoints(borderWidth, deg1, deg2, x1, x2, x3, x4, y1, y2, y3, y4, pointsList, beginRadius, endRadius) {
    var _beginRadius4 = _slicedToArray(beginRadius, 2),
        brx = _beginRadius4[0],
        bry = _beginRadius4[1];

    var _endRadius4 = _slicedToArray(endRadius, 2),
        erx = _endRadius4[0],
        ery = _endRadius4[1]; // 一条边的两侧圆角均为0时无效


    if ((!brx || !bry) && (!erx || !ery)) {
      return pointsList;
    } // 分界坐标圆心，上圆角、下圆角、中间矩形，3个区域2个坐标；当上下圆角相接时中间矩形为0即中间2个坐标相等


    var oyt = y2 + bry - (y2 - y1);
    var oyb = y3 - ery + (y4 - y3);
    var beginList = [];
    var centerList = [];
    var endList = []; // 同borderTop拆分

    for (var i = 0, len = pointsList.length; i < len; i++) {
      var points = pointsList[i]; // 全在上圆角

      if (points[3][1] < oyt) {
        beginList.push(points);
      } // 全在下圆角
      else if (points[0][1] > oyb) {
        endList.push(points);
      } // 跨越上下圆角
      else if (points[3][1] > oyb && points[0][1] < oyt) {
        var xa = oyt < y2 ? x2 - Math.tan(deg2) * (y2 - oyt) : x2;
        var xb = oyb > y3 ? x2 - Math.tan(deg1) * (oyb - y3) : x2;
        beginList.push([points[0], points[1], [xa, oyt], [x1, oyt]]);

        if (oyt < oyb) {
          if (oyb < y3 && oyt > y2) {
            centerList.push([[x1, oyt], [x2, oyt], [x2, oyb], [x1, oyb]]);
          } else if (oyt > y2) {
            centerList.push([[x1, oyt], [x2, oyt], [x2, y3], [x1, y3]]);
            centerList.push([[x1, y3], [x2, y3], [xb, oyb], [x1, oyb]]);
          } else if (oyb < y3) {
            centerList.push([[x1, oyt], [xa, oyt], [x2, y2], [x1, y2]]);
            centerList.push([[x1, y2], [x2, y2], [x2, oyb], [x1, oyb]]);
          } else {
            centerList.push([[x1, oyt], [xa, oyt], [x2, y2], [x1, y2]]);
            centerList.push([[x1, y2], [x2, y2], [x2, y3], [x1, y3]]);
            centerList.push([[x1, y3], [x2, y3], [xb, oyb], [x1, oyb]]);
          }
        }

        endList.push([[x1, oyb], [xb, oyb], points[2], points[3]]);
      } // 跨越下圆角
      else if (points[3][1] > oyb) {
        var x = oyb > y3 ? x2 - Math.tan(deg1) * (oyb - y3) : x2;
        centerList.push([points[0], points[1], [x, oyb], [x1, oyb]]);
        endList.push([[x1, oyb], [x, oyb], points[2], points[3]]);
      } // 跨越上圆角
      else if (points[1][1] < oyt) {
        var _x2 = oyt < y2 ? x2 - Math.tan(deg2) * (y2 - oyt) : x2;

        beginList.push([points[0], points[1], [_x2, oyt], [x1, oyt]]);
        centerList.push([[x1, oyt], [_x2, oyt], points[2], points[3]]);
      } else {
        centerList.push(points);
      }
    }

    var beginLength = beginList.length;

    if (beginLength) {
      var needInner = bry > y2 - y1 && borderWidth < brx;
      var crossDeg = Math.atan((x2 - x1) / (y2 - y1));
      var rx1 = brx;
      var ry1 = bry;
      var sx1 = ry1 / rx1;
      var oxt = x1 + brx;
      var rx2 = brx - (x2 - x1);
      var ry2 = bry - (y2 - y1);
      var sx2 = ry2 / rx2; // 先计算第一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉

      var _xa5, ya, _xb5, yb;

      var ca = calBezierLeftTop(beginList[0][0], beginList[0][3], oxt, oyt, sx1, ry1, true, Math.tan(crossDeg) * ry1);

      var _ca7 = _slicedToArray(ca[ca.length - 1], 2);

      _xa5 = _ca7[0];
      ya = _ca7[1];
      var cb;

      if (needInner) {
        cb = calBezierLeftTop(beginList[0][1], beginList[0][2], oxt, oyt, sx2, ry2, true, Math.tan(crossDeg) * ry2);

        var _cb7 = _slicedToArray(cb[cb.length - 1], 2);

        _xb5 = _cb7[0];
        yb = _cb7[1];
      }

      beginList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === 0) {
          controls1 = ca;

          if (needInner) {
            controls2 = cb;
          }
        } else {
          controls1 = calBezierLeftTop(points[0], points[3], oxt, oyt, sx1, ry1);

          if (needInner) {
            controls2 = calBezierLeftTop(points[1], points[2], oxt, oyt, sx2, ry2);
          }
        }

        for (var _i13 = 0, _len13 = controls1.length; _i13 < _len13; _i13++) {
          limit(controls1[_i13], _xa5, ya, 6);
        }

        if (needInner) {
          for (var _i14 = 0, _len14 = controls2.length; _i14 < _len14; _i14++) {
            limit(controls2[_i14], _xb5, yb, 6);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[3] = points[1];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    var endLength = endList.length;

    if (endLength) {
      var _needInner4 = ery > y4 - y3 && borderWidth < erx;

      var _crossDeg4 = Math.atan((x2 - x1) / (y4 - y3));

      var _rx7 = erx;
      var _ry7 = ery;

      var _sx7 = _ry7 / _rx7;

      var oxb = x1 + erx;

      var _rx8 = erx - (x2 - x1);

      var _ry8 = ery - (y4 - y3);

      var _sx8 = _ry8 / _rx8; // 先计算最后一个块，确定x/y边界，防止因为划分原因导致出现超过边界情况交叉


      var _xa6, _ya6, _xb6, _yb6;

      var _ca8 = calBezierLeftBottom(endList[endLength - 1][0], endList[endLength - 1][3], oxb, oyb, _sx7, _ry7, true, Math.tan(_crossDeg4) * _ry7);

      var _ca8$ = _slicedToArray(_ca8[0], 2);

      _xa6 = _ca8$[0];
      _ya6 = _ca8$[1];

      var _cb8;

      if (_needInner4) {
        _cb8 = calBezierLeftBottom(endList[endLength - 1][1], endList[endLength - 1][2], oxb, oyb, _sx8, _ry8, true, Math.tan(_crossDeg4) * _ry8);

        var _cb8$ = _slicedToArray(_cb8[0], 2);

        _xb6 = _cb8$[0];
        _yb6 = _cb8$[1];
      }

      endList.forEach(function (points, i) {
        var controls1;
        var controls2;

        if (i === endLength - 1) {
          controls1 = _ca8;

          if (_needInner4) {
            controls2 = _cb8;
          }
        } else {
          controls1 = calBezierLeftBottom(points[0], points[3], oxb, oyb, _sx7, _ry7);

          if (_needInner4) {
            controls2 = calBezierLeftBottom(points[1], points[2], oxb, oyb, _sx8, _ry8);
          }
        }

        for (var _i15 = 0, _len15 = controls1.length; _i15 < _len15; _i15++) {
          limit(controls1[_i15], _xa6, _ya6, 7);
        }

        if (_needInner4) {
          for (var _i16 = 0, _len16 = controls2.length; _i16 < _len16; _i16++) {
            limit(controls2[_i16], _xb6, _yb6, 7);
          }

          if (controls2.length === 1) {
            points[2] = controls2[0];
            points.pop();
          } else {
            points[2] = controls2[0];
            points[3] = controls2[1].concat(controls2[2]).concat(controls2[3]);
          }
        } else {
          points[3] = points[1];
        }

        points[0] = controls1[3];
        points[1] = controls1[2].concat(controls1[1]).concat(controls1[0]);
      });
    }

    return beginList.concat(centerList).concat(endList);
  }

  function calBezierLeftTop(p1, p2, ox, oy, sx, r, isStart, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p13 = _slicedToArray(p1, 2),
        p1x = _p13[0],
        p1y = _p13[1];

    var _p14 = _slicedToArray(p2, 2),
        p2x = _p14[0],
        p2y = _p14[1];

    var dx1 = ox - p1x;
    var dsx1 = dx1 * sx;
    var dx2 = ox - p2x;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg2 = Math.atan(dsx2 / (oy - p2y)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx2 = ox - Math.sin(deg2) * r / sx;
    var cpy2 = oy - Math.cos(deg2) * r;
    var deg1;
    var cpx1;
    var cpy1;

    if (isStart) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg1 = Math.PI * 0.5 - alpha;
      cpx1 = ox - Math.cos(alpha) * r / sx;
      cpy1 = oy - Math.sin(alpha) * r;
    } else {
      deg1 = Math.atan(dsx1 / (oy - p1y));
      cpx1 = ox - Math.sin(deg1) * r / sx;
      cpy1 = oy - Math.cos(deg1) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom$1.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 + degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy - cdy1;
    var degTg2 = deg2 - degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy - cdy2; // window.ctx.fillStyle = '#000';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }

  function calBezierLeftBottom(p1, p2, ox, oy, sx, r, isEnd, crossDx) {
    // 先缩放x轴，椭圆变圆，2个点x坐标相应变化，y不变
    var _p15 = _slicedToArray(p1, 2),
        p1x = _p15[0],
        p1y = _p15[1];

    var _p16 = _slicedToArray(p2, 2),
        p2x = _p16[0],
        p2y = _p16[1];

    var dx1 = ox - p1x;
    var dsx1 = dx1 * sx;
    var dx2 = ox - p2x;
    var dsx2 = dx2 * sx; // 求2个点和1/4圆弧的交点坐标，和圆心连线，反三角函数求出夹角

    var deg1 = Math.atan(dsx1 / (p1y - oy)); // 根据角和半径再三角函数求交点坐标，可以直接缩放x轴恢复原本椭圆坐标，求贝塞尔控制点用不到交点

    var cpx1 = ox - Math.sin(deg1) * r / sx;
    var cpy1 = oy + Math.cos(deg1) * r;
    var deg2;
    var cpx2;
    var cpy2;

    if (isEnd) {
      // 交界线和y轴夹角beta以及交点的x坐标都会受缩放影响，先化圆好求交点坐标
      var crossDsx = crossDx * sx;
      var beta = Math.atan(crossDsx / r); // 公式计算可得beta和交点连圆心的角alpha关系

      var tanBetaDiv2Sqrt = Math.sqrt(Math.tan(beta) / 2);
      var tanAlphaHalf = tanBetaDiv2Sqrt / (1 + tanBetaDiv2Sqrt);
      var alpha = Math.atan(tanAlphaHalf) * 2; // 获得alpha后直接根据半径求出交点坐标

      deg2 = Math.PI * 0.5 - alpha;
      cpx2 = ox - Math.cos(alpha) * r / sx;
      cpy2 = oy + Math.sin(alpha) * r;
    } else {
      deg2 = Math.atan(dsx2 / (p2y - oy));
      cpx2 = ox - Math.sin(deg2) * r / sx;
      cpy2 = oy + Math.cos(deg2) * r;
    } // 首尾只有3个点情况下重复了顶点形成4边形，同时圆角x/y相等有inner时
    // 使得交点相同角度相同无法计算，直接返回1个点即可


    if (deg1 === deg2) {
      return [[cpx1, cpy1]];
    } // 根据夹角求贝塞尔拟合圆弧长度


    var h = geom$1.h(Math.abs(deg1 - deg2));
    var d = h * r; // 过交点做切线，知道切线段长度d，求切线上从交点延长d的坐标，即为控制点
    // 圆心交点控制点连成直角三角形，获得斜边即圆心到控制点距离c
    // 求切线角，用上面夹角减去切线角可得控制点和圆心连线的角，从而获得坐标

    var c = Math.sqrt(Math.pow(r, 2) + Math.pow(d, 2));
    var degTg = Math.atan(d / r);
    var degTg1 = deg1 - degTg;
    var cdx1 = Math.sin(degTg1) * c;
    var cdy1 = Math.cos(degTg1) * c;
    var cx1 = ox - cdx1 / sx;
    var cy1 = oy + cdy1;
    var degTg2 = deg2 + degTg;
    var cdx2 = Math.sin(degTg2) * c;
    var cdy2 = Math.cos(degTg2) * c;
    var cx2 = ox - cdx2 / sx;
    var cy2 = oy + cdy2; // window.ctx.fillStyle = '#F90';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx1, cpy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0FF';
    // window.ctx.beginPath();
    // window.ctx.arc(cx1, cy1, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#00F';
    // window.ctx.beginPath();
    // window.ctx.arc(cx2, cy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.fillStyle = '#0F0';
    // window.ctx.beginPath();
    // window.ctx.arc(cpx2, cpy2, 1,0, 2 * Math.PI);
    // window.ctx.fill();
    // window.ctx.closePath();

    return [[cpx2, cpy2], [cx2, cy2], [cx1, cy1], [cpx1, cpy1]];
  }
  /**
   * 简单计算椭圆的圆化坐标控制点，视作重合位置，外面判断backgroundClip并调整坐标
   * @param x 起始x
   * @param y 起始y
   * @param w 宽
   * @param h 高
   * @param btlr borderTopLeftRadius
   * @param btrr borderTopRightRadius
   * @param bbrr borderBottomRightRadius
   * @param bblr borderBottomLeftRadius
   * @returns {[]} 多边形的顶点和曲线控制点
   */


  function calRadius(x, y, w, h, btlr, btrr, bbrr, bblr) {
    var need;

    var _btlr = _slicedToArray(btlr, 2),
        btlx = _btlr[0],
        btly = _btlr[1];

    var _btrr = _slicedToArray(btrr, 2),
        btrx = _btrr[0],
        btry = _btrr[1];

    var _bbrr = _slicedToArray(bbrr, 2),
        bbrx = _bbrr[0],
        bbry = _bbrr[1];

    var _bblr = _slicedToArray(bblr, 2),
        bblx = _bblr[0],
        bbly = _bblr[1];

    btlx = Math.max(btlx, 0);
    btly = Math.max(btly, 0);
    btrx = Math.max(btrx, 0);
    btry = Math.max(btry, 0);
    bbrx = Math.max(bbrx, 0);
    bbry = Math.max(bbry, 0);
    bblx = Math.max(bblx, 0);
    bbly = Math.max(bbly, 0); // 圆角必须x/y都>0才有效，否则视为不绘制

    if (btlx > 0 && btly > 0 || btrx > 0 && btry > 0 || bbrx > 0 && bbry > 0 || bblx > 0 && bbly > 0) {
      need = true;
    }

    if (need) {
      var list = [];

      if (btlx > 0 && btly > 0) {
        list.push([x, y + btly]);
        list.push([x, y + btly * (1 - H), x + btlx * (1 - H), y, x + btlx, y]);
      } else {
        list.push([x, y]);
      }

      if (btrx > 0 && btry > 0) {
        list.push([x + w - btrx, y]);
        list.push([x + w - btrx * (1 - H), y, x + w, y + btry * (1 - H), x + w, y + btry]);
      } else {
        list.push([x + w, y]);
      }

      if (bbrx > 0 && bbry > 0) {
        list.push([x + w, y + h - bbry]);
        list.push([x + w, y + h - bbry * (1 - H), x + w - bbrx * (1 - H), y + h, x + w - bbrx, y + h]);
      } else {
        list.push([x + w, y + h]);
      }

      if (bblx > 0 && bbly > 0) {
        list.push([x + bblx, y + h]);
        list.push([x + bblx * (1 - H), y + h, x, y + h - bbly * (1 - H), x, y + h - bbly]);
      } else {
        list.push([x, y + h]);
      }

      return list;
    }
  }

  function limit(points, x, y, direction) {
    if (direction === 0) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 1) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 2) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 3) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.min(points[1], y);
    } else if (direction === 4) {
      points[0] = Math.max(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 5) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 6) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.max(points[1], y);
    } else if (direction === 7) {
      points[0] = Math.min(points[0], x);
      points[1] = Math.min(points[1], y);
    }
  }

  var BR_KS = [BORDER_TOP_LEFT_RADIUS$4, BORDER_TOP_RIGHT_RADIUS$3, BORDER_BOTTOM_RIGHT_RADIUS$4, BORDER_BOTTOM_LEFT_RADIUS$4];

  function calBorderRadius(w, h, currentStyle, computedStyle, root) {
    var noRadius = true;
    BR_KS.forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        if (item.v > 0) {
          noRadius = false;
        } else {
          return 0;
        }

        if (item.u === PX$a) {
          return Math.max(0, item.v);
        } else if (item.u === PERCENT$9) {
          return Math.max(0, item.v * (i ? h : w) * 0.01);
        } else if (item.u === REM$9) {
          return Math.max(0, item.v * root.computedStyle[FONT_SIZE$b]);
        } else if (item.u === VW$9) {
          return Math.max(0, item.v * root.width * 0.01);
        } else if (item.u === VH$9) {
          return Math.max(0, item.v * root.height * 0.01);
        } else if (item.u === VMAX$9) {
          return Math.max(0, item.v * Math.max(root.width, root.height) * 0.01);
        } else if (item.u === VMIN$9) {
          return Math.max(0, item.v * Math.min(root.width, root.height) * 0.01);
        }

        return 0;
      });
    }); // 优化提前跳出

    if (noRadius) {
      return;
    } // radius限制，相交的2个之和不能超过边长，如果2个都超过中点取中点，只有1个超过取交点，这包含了单个不能超过总长的逻辑


    BR_KS.forEach(function (k, i) {
      var j = i % 2 === 0 ? 0 : 1;
      var target = j ? h : w;
      var prev = computedStyle[k];
      var next = computedStyle[BR_KS[(i + 1) % 4]]; // 相加超过边长则是相交

      if (prev[j] + next[j] > target) {
        var half = target * 0.5; // 都超过一半中点取中点

        if (prev[j] >= half && next[j] >= half) {
          prev[j] = next[j] = half;
        } // 仅1个超过中点，因相交用总长减去另一方即可
        else if (prev[j] > half) {
          prev[j] = target - next[j];
        } else if (next[j] > half) {
          next[j] = target - prev[j];
        }
      }
    });
  }

  function calBorderRadiusInline(contentBoxList, currentStyle, computedStyle) {
    var first, last;

    if (contentBoxList.length) {
      first = contentBoxList[0];
      last = contentBoxList[contentBoxList.length - 1]; // 不用instanceof防止循环依赖

      if (last.isEllipsis) {
        last = contentBoxList[contentBoxList.length - 2];
      }
    } // 先看first的左侧


    var w = first ? first.outerWidth : 0,
        h = first ? first.outerHeight : 0;
    w += computedStyle[BORDER_LEFT_WIDTH$9] + computedStyle[PADDING_LEFT$9];
    h += computedStyle[BORDER_TOP_WIDTH$7] + computedStyle[BORDER_BOTTOM_WIDTH$6] + computedStyle[PADDING_TOP$7] + computedStyle[PADDING_BOTTOM$6];
    [BORDER_TOP_LEFT_RADIUS$4, BORDER_BOTTOM_LEFT_RADIUS$4].forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        var v;

        if (item.u === PX$a) {
          v = Math.max(0, item.v);
          v = Math.min(i ? h : w, v);
        } else {
          v = Math.max(0, item.v * (i ? h : w) * 0.01);
          v = Math.min(i ? h : w, v);
        }

        return v;
      });
    }); // 再看end的右侧

    w = last ? last.outerWidth : 0;
    h = last ? last.outerHeight : 0;
    [BORDER_TOP_RIGHT_RADIUS$3, BORDER_BOTTOM_RIGHT_RADIUS$4].forEach(function (k) {
      computedStyle[k] = currentStyle[k].map(function (item, i) {
        var v;

        if (item.u === PX$a) {
          v = Math.max(0, item.v);
          v = Math.min(i ? h : w, v);
        } else {
          v = Math.max(0, item.v * (i ? h : w) * 0.01);
          v = Math.min(i ? h : w, v);
        }

        return v;
      });
    });
  }

  function renderBorder(xom, renderMode, ctx, points, color, dx, dy) {
    if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
      ctx.beginPath();

      if (ctx.fillStyle !== color) {
        ctx.fillStyle = color;
      }

      points.forEach(function (point) {
        canvasPolygon$6(ctx, point, dx, dy);
      });
      ctx.fill();
      ctx.closePath();
    } else if (renderMode === mode.SVG) {
      var s = '';
      points.forEach(function (point) {
        s += svgPolygon$5(point);
      });
      xom.virtualDom.bb.push({
        type: 'item',
        tagName: 'path',
        props: [['d', s], ['fill', color]]
      });
    }
  }

  var border = {
    calPoints: calPoints,
    calRadius: calRadius,
    calBorderRadius: calBorderRadius,
    calBorderRadiusInline: calBorderRadiusInline,
    renderBorder: renderBorder
  };

  var rgba2int$2 = util.rgba2int,
      isNil$d = util.isNil;
  var PX$9 = o$4.PX,
      PERCENT$8 = o$4.PERCENT,
      DEG$4 = o$4.DEG,
      NUMBER$5 = o$4.NUMBER,
      REM$8 = o$4.REM,
      VW$8 = o$4.VW,
      VH$8 = o$4.VH,
      VMAX$8 = o$4.VMAX,
      VMIN$8 = o$4.VMIN,
      calUnit$2 = o$4.calUnit;
  var d2r$1 = geom$1.d2r;
  var canvasPolygon$5 = painter.canvasPolygon;
  var FONT_SIZE$a = enums.STYLE_KEY.FONT_SIZE;

  function getLinearDeg(v) {
    var deg = 180;

    if (v === 'to top') {
      deg = 0;
    } else if (v === 'to top right') {
      deg = 45;
    } else if (v === 'to right') {
      deg = 90;
    } else if (v === 'to bottom right') {
      deg = 135;
    } else if (v === 'to bottom') ; else if (v === 'to bottom left') {
      deg = 225;
    } else if (v === 'to left') {
      deg = 270;
    } else if (v === 'to top left') {
      deg = 315;
    } // 数字角度，没有的话取默认角度
    else {
      var match = /([-+]?[\d.]+)deg/.exec(v);

      if (match) {
        deg = parseFloat(match[1]);
      }
    }

    return deg % 360;
  }

  function getRadialPosition(data) {
    if (/^[-+]?[\d.]/.test(data)) {
      var v = calUnit$2(data);

      if ([NUMBER$5, DEG$4].indexOf(v.u) > -1) {
        v.v = PX$9;
      }

      return v;
    } else {
      return {
        v: {
          top: 0,
          left: 0,
          center: 50,
          right: 100,
          bottom: 100
        }[data] || 50,
        u: PERCENT$8
      };
    }
  } // 获取color-stop区间范围，去除无用值


  function getColorStop(v, length, root) {
    var list = [];
    var firstColor = v[0][0]; // 先把已经声明距离的换算成[0,1]以数组形式存入，未声明的原样存入

    for (var i = 0, len = v.length; i < len; i++) {
      var item = v[i]; // 考虑是否声明了位置

      if (item.length > 1) {
        var p = item[1];

        if (p.u === PERCENT$8) {
          list.push([item[0], p.v * 0.01]);
        } else if (p.u === REM$8) {
          list.push([item[0], p.v * root.computedStyle[FONT_SIZE$a] / length]);
        } else if (p.u === VW$8) {
          list.push([item[0], p.v * root.width / length]);
        } else if (p.u === VH$8) {
          list.push([item[0], p.v * root.height / length]);
        } else if (p.u === VMAX$8) {
          list.push([item[0], p.v * Math.max(root.width, root.height) / length]);
        } else if (p.u === VMIN$8) {
          list.push([item[0], p.v * Math.min(root.width, root.height) / length]);
        } else {
          list.push([item[0], p.v / length]);
        }
      } else {
        list.push([item[0]]);
      }
    }

    if (list.length === 1) {
      list.push(util.clone(list[0]));
    } // 首尾不声明默认为[0, 1]


    if (list[0].length === 1) {
      list[0].push(0);
    }

    if (list.length > 1) {
      var _i = list.length - 1;

      if (list[_i].length === 1) {
        list[_i].push(1);
      }
    } // 找到未声明位置的，需区间计算，找到连续的未声明的，前后的区间平分


    var start = list[0][1];

    for (var _i2 = 1, _len = list.length; _i2 < _len - 1; _i2++) {
      var _item = list[_i2];

      if (_item.length > 1) {
        start = _item[1];
      } else {
        var j = _i2 + 1;
        var end = list[list.length - 1][1];

        for (; j < _len - 1; j++) {
          var _item2 = list[j];

          if (_item2.length > 1) {
            end = _item2[1];
            break;
          }
        }

        var num = j - _i2 + 1;
        var per = (end - start) / num;

        for (var k = _i2; k < j; k++) {
          var _item3 = list[k];

          _item3.push(start + per * (k + 1 - _i2));
        }

        _i2 = j;
      }
    } // 每个不能小于前面的，canvas/svg不能兼容这种情况，需处理


    for (var _i3 = 1, _len2 = list.length; _i3 < _len2; _i3++) {
      var _item4 = list[_i3];
      var prev = list[_i3 - 1];

      if (_item4[1] < prev[1]) {
        _item4[1] = prev[1];
      }
    } // 0之前的和1之后的要过滤掉


    for (var _i4 = 0, _len3 = list.length; _i4 < _len3; _i4++) {
      var _item5 = list[_i4];

      if (_item5[1] > 1) {
        list.splice(_i4);
        var _prev = list[_i4 - 1];

        if (_prev && _prev[1] < 1) {
          var dr = _item5[0][0] - _prev[0][0];
          var dg = _item5[0][1] - _prev[0][1];
          var db = _item5[0][2] - _prev[0][2];
          var da = _item5[0][3] - _prev[0][3];

          var _p = (1 - _prev[1]) / (_item5[1] - _prev[1]);

          list.push([[_item5[0][0] + dr * _p, _item5[0][1] + dg * _p, _item5[0][2] + db * _p, _item5[0][3] + da * _p], 1]);
        }

        break;
      }
    }

    for (var _i5 = list.length - 1; _i5 >= 0; _i5--) {
      var _item6 = list[_i5];

      if (_item6[1] < 0) {
        list.splice(0, _i5 + 1);
        var next = list[_i5];

        if (next && next[1] > 0) {
          var _dr = next[0][0] - _item6[0][0];

          var _dg = next[0][1] - _item6[0][1];

          var _db = next[0][2] - _item6[0][2];

          var _da = next[0][3] - _item6[0][3];

          var _p2 = -_item6[1] / (next[1] - _item6[1]);

          list.unshift([[_item6[0][0] + _dr * _p2, _item6[0][1] + _dg * _p2, _item6[0][2] + _db * _p2, _item6[0][3] + _da * _p2], 0]);
        }

        break;
      }
    } // 可能存在超限情况，如在使用px单位超过len或<len时，canvas会报错超过[0,1]区间，需手动换算至区间内


    list.forEach(function (item) {
      // item[0] = int2rgba(item[0]);
      if (item[1] < 0) {
        item[1] = 0;
      } else if (item[1] > 1) {
        item[1] = 1;
      }
    }); // 都超限时，第一个颜色兜底

    if (!list.length) {
      list.push([firstColor, 0]);
    }

    return list;
  } // 根据角度和圆心获取渐变的4个点坐标


  function calLinearCoords(deg, length, cx, cy) {
    var x0;
    var y0;
    var x1;
    var y1;

    if (deg >= 270) {
      var r = d2r$1(360 - deg);
      x0 = cx + Math.sin(r) * length;
      y0 = cy + Math.cos(r) * length;
      x1 = cx - Math.sin(r) * length;
      y1 = cy - Math.cos(r) * length;
    } else if (deg >= 180) {
      var _r = d2r$1(deg - 180);

      x0 = cx + Math.sin(_r) * length;
      y0 = cy - Math.cos(_r) * length;
      x1 = cx - Math.sin(_r) * length;
      y1 = cy + Math.cos(_r) * length;
    } else if (deg >= 90) {
      var _r2 = d2r$1(180 - deg);

      x0 = cx - Math.sin(_r2) * length;
      y0 = cy - Math.cos(_r2) * length;
      x1 = cx + Math.sin(_r2) * length;
      y1 = cy + Math.cos(_r2) * length;
    } else {
      var _r3 = d2r$1(deg);

      x0 = cx - Math.sin(_r3) * length;
      y0 = cy + Math.cos(_r3) * length;
      x1 = cx + Math.sin(_r3) * length;
      y1 = cy - Math.cos(_r3) * length;
    }

    return [x0, y0, x1, y1];
  }

  function calCircleCentre(position, x1, y1, iw, ih, root) {
    var cx, cy;
    var positionX = position[0],
        positionY = position[1];

    if (positionX.u === PERCENT$8) {
      cx = x1 + positionX.v * iw * 0.01;
    } else if (positionX.u === REM$8) {
      cx = x1 + positionX.v * root.computedStyle[FONT_SIZE$a];
    } else if (positionX.u === VW$8) {
      cx = x1 + positionX.v * root.width * 0.01;
    } else if (positionX.u === VH$8) {
      cx = x1 + positionX.v * root.height * 0.01;
    } else if (positionX.u === VMAX$8) {
      cx = x1 + positionX.v * Math.max(root.width, root.height) * 0.01;
    } else if (positionX.u === VMIN$8) {
      cx = x1 + positionX.v * Math.min(root.width, root.height) * 0.01;
    } else {
      cx = x1 + positionX.v;
    }

    if (positionY.u === PERCENT$8) {
      cy = y1 + positionY.v * ih * 0.01;
    } else if (positionY.u === REM$8) {
      cy = y1 + positionY.v * root.computedStyle[FONT_SIZE$a];
    } else if (positionY.u === VW$8) {
      cy = y1 + positionY.v * root.width * 0.01;
    } else if (positionY.u === VH$8) {
      cy = y1 + positionY.v * root.height * 0.01;
    } else if (positionY.u === VH$8) {
      cy = y1 + positionY.v * Math.max(root.width, root.height) * 0.01;
    } else if (positionY.u === VH$8) {
      cy = y1 + positionY.v * Math.min(root.width, root.height) * 0.01;
    } else {
      cy = y1 + positionY.v;
    }

    return [cx, cy];
  } // 获取径向渐变圆心半径


  function calRadialRadius(shape, size, position, iw, ih, x1, y1, x2, y2, root) {
    var cx,
        cy,
        xl,
        yl,
        r,
        tx,
        ty,
        d = 0; // 扩展的from to ratio格式，圆心、长轴坐标、短轴缩放比

    if (Array.isArray(size)) {
      cx = x1 + size[0] * iw;
      cy = y1 + size[1] * ih;
      tx = x1 + size[4] * iw;
      ty = y1 + size[5] * ih;

      if (size[6] <= 0) {
        r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
      } else {
        xl = Math.sqrt(Math.pow((size[2] - size[0]) * iw, 2) + Math.pow((size[3] - size[1]) * ih, 2));
        yl = xl * size[6];
        r = Math.max(xl, yl); // 看旋转

        if (xl !== yl) {
          if (size[2] >= size[0]) {
            if (size[3] >= size[1]) {
              d = Math.asin((size[3] - size[1]) * ih / xl);
            } else {
              d = -Math.asin((size[1] - size[3]) * ih / xl);
            }
          } else {
            if (size[3] >= size[1]) {
              d = d2r$1(180) - Math.asin((size[3] - size[1]) * ih / xl);
            } else {
              d = Math.asin((size[1] - size[3]) * ih / xl) - d2r$1(180);
            }
          }
        }
      }
    } else {
      // 默认椭圆a是水平轴，b是垂直轴
      var _calCircleCentre = calCircleCentre(position, x1, y1, iw, ih, root);

      var _calCircleCentre2 = _slicedToArray(_calCircleCentre, 2);

      cx = _calCircleCentre2[0];
      cy = _calCircleCentre2[1];
      tx = cx;
      ty = cy;
      var ratio = 1;

      if (size === 'closest-corner' && shape === 'circle') {
        if (cx <= x1 || cx >= x2 || cy <= y1 || cy >= y2) {
          r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
        } else {
          if (cx < x1 + iw * 0.5) {
            xl = cx - x1;
          } else {
            xl = x2 - cx;
          }

          if (cy < y1 + ih * 0.5) {
            yl = cy - y1;
          } else {
            yl = y2 - cy;
          }

          r = Math.sqrt(Math.pow(xl, 2) + Math.pow(yl, 2));
        }
      } else if (size === 'closest-side' || size === 'closest-corner') {
        // 在边外特殊情况只有end颜色填充
        if (cx <= x1 || cx >= x2 || cy <= y1 || cy >= y2) {
          r = Math.min(Math.abs(cx - x1), Math.min(Math.abs(cy - y1), Math.min(Math.abs(cy - y2), Math.min(Math.abs(cx - y2)))));
        } else {
          var _ratio = 1;

          if (cx < x1 + iw * 0.5) {
            xl = cx - x1;
          } else {
            xl = x2 - cx;
          }

          if (cy < y1 + ih * 0.5) {
            yl = cy - y1;
          } else {
            yl = y2 - cy;
          }

          r = Math.min(xl, yl); // css的角和边有对应关系，即边扩展倍数，计算为固定值

          if (size === 'closest-corner') {
            _ratio = Math.sqrt(2);
          }

          xl *= _ratio;
          yl *= _ratio;
          r *= _ratio;
        }
      } else {
        if (cx <= x1) {
          xl = x1 - cx + iw;
        } else if (cx >= x2) {
          xl = cx - x2 + iw;
        } else if (cx < x1 + iw * 0.5) {
          xl = x2 - cx;
        } else {
          xl = cx - x1;
        }

        if (cy <= y1) {
          yl = y1 - cy + ih;
        } else if (cy >= y2) {
          yl = cy - y2 + ih;
        } else if (cy < y1 + ih * 0.5) {
          yl = y2 - cy;
        } else {
          yl = cy - y1;
        }

        r = Math.max(xl, yl);

        if (size !== 'farthest-side') {
          ratio = Math.sqrt(2);
        }

        xl *= ratio;
        yl *= ratio;
        r *= ratio;
      }
    }

    if (shape === 'circle') {
      xl = yl = r;
    }

    return [cx, cy, r, xl, yl, tx, ty, d];
  }

  function parseGradient(s) {
    var gradient = reg.gradient.exec(s);

    if (gradient) {
      var o = {
        k: gradient[1]
      };

      if (o.k === 'linear') {
        var deg = /([-+]?[\d.]+deg)|(to\s+[toprighbml]+)/i.exec(gradient[2]);

        if (deg) {
          o.d = getLinearDeg(deg[0].toLowerCase());
        } // 扩展支持从a点到b点相对坐标，而不是css角度，sketch等ui软件中用此格式
        else {
          var points = /([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)/.exec(gradient[2]);

          if (points) {
            o.d = [parseFloat(points[1]), parseFloat(points[2]), parseFloat(points[3]), parseFloat(points[4])];
          } else {
            o.d = 180;
          }
        }
      } else if (o.k === 'radial') {
        o.s = gradient[2].indexOf('circle') > -1 ? 'circle' : 'ellipse';
        var size = /(closest|farthest)-(side|corner)/i.exec(gradient[2]);

        if (size) {
          o.z = size[0].toLowerCase();
        } // 扩展支持从a点到b点相对坐标，而不是size，sketch等ui软件中用此格式
        else {
          var _points = /([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)\s+([-+]?[\d.]+)(?:\s+([-+]?[\d.]+))?(?:\s+([-+]?[\d.]+))?(?:\s+([-+]?[\d.]+))?/.exec(gradient[2]);

          if (_points) {
            o.z = [parseFloat(_points[1]), parseFloat(_points[2]), parseFloat(_points[3]), parseFloat(_points[4])];
            var i5 = !isNil$d(_points[5]),
                i6 = !isNil$d(_points[6]),
                i7 = !isNil$d(_points[7]); // 重载，567是偏移x/y和ratio，都可省略即不偏移和半径1，只有5是ratio，只有56是x/y

            if (i5 && i6 && i7) {
              o.z.push(parseFloat(_points[5]));
              o.z.push(parseFloat(_points[6]));
              o.z.push(parseFloat(_points[7]));
            } else if (i5 && i6) {
              o.z.push(parseFloat(_points[5]));
              o.z.push(parseFloat(_points[6]));
              o.z.push(1);
            } else if (i5) {
              o.z.push(o.z[0]);
              o.z.push(o.z[1]);
              o.z.push(parseFloat(_points[5]));
            } else {
              o.z.push(o.z[0]);
              o.z.push(o.z[1]);
              o.z.push(1);
            }
          } else {
            o.z = 'farthest-corner';
          }
        }

        var position = /at\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center))(?:\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center)))?/i.exec(gradient[2]);

        if (position) {
          var x = getRadialPosition(position[1]);
          var y = position[2] ? getRadialPosition(position[2]) : x;
          o.p = [x, y];
        } else {
          o.p = [{
            v: 50,
            u: PERCENT$8
          }, {
            v: 50,
            u: PERCENT$8
          }];
        }
      } else if (o.k === 'conic') {
        var _deg = /([-+]?[\d.]+deg)/i.exec(gradient[2]);

        if (_deg) {
          o.d = parseFloat(_deg[0]) % 360;
        } else {
          o.d = 0;
        }

        var _position = /at\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center))(?:\s+((?:[-+]?[\d.]+[pxremvwhina%]*)|(?:left|top|right|bottom|center)))?/i.exec(gradient[2]);

        if (_position) {
          var _x = getRadialPosition(_position[1]);

          var _y = _position[2] ? getRadialPosition(_position[2]) : _x;

          o.p = [_x, _y];
        } else {
          o.p = [{
            v: 50,
            u: PERCENT$8
          }, {
            v: 50,
            u: PERCENT$8
          }];
        }
      }

      var v = gradient[2].match(/(([-+]?[\d.]+[pxremvwhina%]+)?\s*((#[0-9a-f]{3,8})|(rgba?\s*\(.+?\)))\s*([-+]?[\d.]+[pxremvwhina%]+)?)|(transparent)/ig) || [];
      o.v = v.map(function (item) {
        var color = /(?:#[0-9a-f]{3,8})|(?:rgba?\s*\(.+?\))|(?:transparent)/i.exec(item);
        var arr = [rgba2int$2(color[0])];
        var percent = /[-+]?[\d.]+[pxremvwhina%]+/.exec(item);

        if (percent) {
          var _v = calUnit$2(percent[0]);

          if ([NUMBER$5, DEG$4].indexOf(_v.u) > -1) {
            _v.v = PX$9;
          }

          arr[1] = _v;
        }

        return arr;
      });
      return o;
    }
  }

  function getLinear(v, d, ox, oy, cx, cy, w, h, root) {
    var dx = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var dy = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    ox += dx;
    oy += dy;
    cx += dx;
    cy += dy; // d为数组是2个坐标点，数字是css标准角度

    var x1, y1, x2, y2, stop;

    if (Array.isArray(d)) {
      x1 = ox + d[0] * w;
      y1 = oy + d[1] * h;
      x2 = ox + d[2] * w;
      y2 = oy + d[3] * h;
      var total = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      stop = getColorStop(v, total);
    } else {
      while (d >= 360) {
        d -= 360;
      }

      while (d < 0) {
        d += 360;
      } // 根据角度求直线上2点，设置半径为长宽最大值，这样一定在矩形外，看做一个向量A


      var len = Math.max(w, h);
      var coords = calLinearCoords(d, len, cx, cy);
      len *= 2; // start和4个顶点的向量在A上的投影长度

      var l1 = vector.dotProduct(ox - coords[0], oy - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l2 = vector.dotProduct(ox + w - coords[0], oy - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l3 = vector.dotProduct(ox + w - coords[0], oy + h - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len;
      var l4 = vector.dotProduct(ox - coords[0], oy + h - coords[1], coords[2] - coords[0], coords[3] - coords[1]) / len; // 最小和最大值为0~100%

      var min = l1,
          max = l1;
      min = Math.min(min, Math.min(l2, Math.min(l3, l4)));
      max = Math.max(max, Math.max(l2, Math.max(l3, l4))); // 求得0和100%的长度和坐标

      var _total = max - min;

      var r1 = min / len;

      var _dx = coords[2] - coords[0];

      var _dy = coords[3] - coords[1];

      x1 = coords[0] + _dx * r1;
      y1 = coords[1] + _dy * r1;
      x2 = coords[2] - _dx * r1;
      y2 = coords[3] - _dy * r1;
      stop = getColorStop(v, _total, root);
    }

    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      stop: stop
    };
  }

  function getRadial(v, shape, size, position, x1, y1, x2, y2, root) {
    var dx = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
    var dy = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var w = x2 - x1;
    var h = y2 - y1;
    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;

    var _calRadialRadius = calRadialRadius(shape, size, position, w, h, x1, y1, x2, y2, root),
        _calRadialRadius2 = _slicedToArray(_calRadialRadius, 8),
        cx = _calRadialRadius2[0],
        cy = _calRadialRadius2[1],
        r = _calRadialRadius2[2],
        xl = _calRadialRadius2[3],
        yl = _calRadialRadius2[4],
        tx = _calRadialRadius2[5],
        ty = _calRadialRadius2[6],
        d = _calRadialRadius2[7]; // 圆形取最小值，椭圆根据最小圆进行transform，椭圆其中一边轴和r一样，另一边则大小缩放可能


    var matrix,
        scx = 1,
        scy = 1;

    if (xl !== yl || d) {
      matrix = [1, 0, 0, 1, 0, 0];

      if (d) {
        var sin = Math.sin(d);
        var cos = Math.cos(d);
        matrix = [cos, sin, 0, 0, -sin, cos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      }

      if (xl !== r) {
        scx = xl / r;
        var m = [scx, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        matrix = mx.multiply(matrix, m);
      }

      if (yl !== r) {
        scy = yl / r;
        var _m = [1, 0, 0, 0, 0, scy, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        matrix = mx.multiply(matrix, _m);
      }
    }

    var stop = getColorStop(v, r, root);
    return {
      cx: cx,
      cy: cy,
      tx: tx,
      ty: ty,
      r: r,
      stop: stop,
      scx: scx,
      scy: scy,
      matrix: matrix,
      d: d
    };
  }

  function getConic(v, d, p, x1, y1, x2, y2, ratio, root) {
    var _calConicRadius = calConicRadius(v, d, p, x1, y1, x2, y2, root),
        _calConicRadius2 = _slicedToArray(_calConicRadius, 4),
        cx = _calConicRadius2[0],
        cy = _calConicRadius2[1],
        r = _calConicRadius2[2],
        deg = _calConicRadius2[3];

    var stop = getColorStop(v, 1, root);
    r <<= 1; // 锥形半径*2，这样分割画圆时保证一定会填满原有矩形

    r *= ratio; // 矢量图形比较特殊，有可能超限，传入个倍数扩大半径

    return {
      cx: cx,
      cy: cy,
      w: x2 - x1,
      h: y2 - y1,
      r: r,
      deg: deg,
      stop: stop
    };
  }

  function calConicRadius(v, deg, position, x1, y1, x2, y2, root) {
    var iw = x2 - x1;
    var ih = y2 - y1;

    var _calCircleCentre3 = calCircleCentre(position, x1, y1, iw, ih, root),
        _calCircleCentre4 = _slicedToArray(_calCircleCentre3, 2),
        cx = _calCircleCentre4[0],
        cy = _calCircleCentre4[1];

    var r, a, b;

    if (cx >= x1 + iw * 0.5) {
      a = cx - x1;
    } else {
      a = x2 - cx;
    }

    if (cy >= y1 + ih * 0.5) {
      b = cy - y1;
    } else {
      b = y2 - cy;
    }

    r = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
    return [cx, cy, r, deg];
  }

  function renderConic(xom, renderMode, ctx, res, x, y, w, h, btlr, btrr, bbrr, bblr, isInline) {
    // border-radius使用三次贝塞尔曲线模拟1/4圆角，误差在[0, 0.000273]之间
    var list = border.calRadius(x, y, w, h, btlr, btrr, bbrr, bblr);

    if (!list) {
      list = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
    }

    if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
      var offscreen = inject.getCacheCanvas(w, h, '__$$CONIC_GRADIENT$$__');
      var imgData = offscreen.ctx.getImageData(0, 0, w, h);
      gradient$1.getConicGradientImage(res.cx - x, res.cy - y, res.w, res.h, res.stop, imgData.data);
      offscreen.ctx.putImageData(imgData, 0, 0);
      ctx.save();
      ctx.beginPath();
      canvasPolygon$5(ctx, list);
      ctx.clip();
      ctx.closePath();
      ctx.drawImage(offscreen.canvas, x, y);
      ctx.restore();
      offscreen.ctx.clearRect(0, 0, w, h);
    }
  }

  var gradient = {
    parseGradient: parseGradient,
    getLinear: getLinear,
    getRadial: getRadial,
    getConic: getConic,
    renderConic: renderConic
  };

  var isNil$c = util.isNil;

  function parseFlex(style, grow, shrink, basis) {
    if (isNil$c(style.flexGrow)) {
      style.flexGrow = grow || 0;
    }

    if (isNil$c(style.flexShrink)) {
      style.flexShrink = shrink || 0;
    }

    if (isNil$c(style.flexBasis)) {
      style.flexBasis = basis || 0;
    }
  }

  function parseMarginPadding(style, key, list) {
    var temp = style[key];

    if (!isNil$c(temp)) {
      var match = temp.toString().match(/([-+]?[\d.]+[pxremvwhina%]*)|(auto)/ig);

      if (match) {
        if (match.length === 1) {
          match[3] = match[2] = match[1] = match[0];
        } else if (match.length === 2) {
          match[2] = match[0];
          match[3] = match[1];
        } else if (match.length === 3) {
          match[3] = match[1];
        }

        list.forEach(function (k, i) {
          if (isNil$c(style[k])) {
            style[k] = match[i];
          }
        });
      }
    }
  }

  function parseOneBorder(style, k) {
    var v = style[k];

    if (isNil$c(v)) {
      return;
    } // 后面会统一格式化处理


    if (isNil$c(style[k + 'Width'])) {
      var w = /\b[\d.]+[pxremvwhina%]*\b/i.exec(v);
      style[k + 'Width'] = w ? w[0] : 0;
    }

    if (isNil$c(style[k + 'Style'])) {
      var s = /\b(solid|dashed|dotted)\b/i.exec(v);
      style[k + 'Style'] = s ? s[1] : 'solid';
    }

    if (isNil$c(style[k + 'Color'])) {
      var c = /#[0-9a-f]{3,8}/i.exec(v);

      if (c && [4, 7, 9].indexOf(c[0].length) > -1) {
        style[k + 'Color'] = c[0];
      } else if (/\btransparent\b/i.test(v)) {
        style[k + 'Color'] = 'transparent';
      } else {
        c = /rgba?\s*\(.+\)/i.exec(v);
        style[k + 'Color'] = c ? c[0] : 'transparent';
      }
    }
  }

  var abbr$1 = {
    margin: ['marginTop', 'marginRight', 'marginBottom', 'marginLeft'],
    padding: ['paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
    border: ['borderTop', 'borderRight', 'borderBottom', 'borderLeft'],
    borderTop: ['borderTopWidth', 'borderTopStyle', 'borderTopColor'],
    borderRight: ['borderRightWidth', 'borderRightStyle', 'borderRightColor'],
    borderBottom: ['borderBottomWidth', 'borderBottomStyle', 'borderBottomColor'],
    borderLeft: ['borderLeftWidth', 'borderLeftStyle', 'borderLeftColor'],
    borderWidth: ['borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth'],
    borderColor: ['borderTopColor', 'borderRightColor', 'borderBottomColor', 'borderLeftColor'],
    borderStyle: ['borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle'],
    borderRadius: ['borderTopLeftRadius', 'borderTopRightRadius', 'borderBottomRightRadius', 'borderBottomLeftRadius'],
    background: ['backgroundColor', 'backgroundImage', 'backgroundRepeat', 'backgroundPosition'],
    backgroundPosition: ['backgroundPositionX', 'backgroundPositionY'],
    flex: ['flexGrow', 'flexShrink', 'flexBasis'],
    translate: ['translateX', 'translateY'],
    translate3d: ['translateX', 'translateY', 'translateY'],
    scale: ['scaleX', 'scaleY'],
    scale3d: ['scaleX', 'scaleY', 'scaleZ'],
    rotate: ['rotateZ'],
    skew: ['skewX', 'skewY'],
    textStroke: ['textStrokeWidth', 'textStrokeColor', 'textStrokeOver'],
    toFull: function toFull(style, k) {
      var _this = this;

      var v = style[k];

      if (k === 'background') {
        // bg缩写多个时有color则必须是最后一个
        if (Array.isArray(v)) {
          var length = v.length;

          if (isNil$c(style.backgroundColor)) {
            var bgc = /^\s*((transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\)))/i.exec(v[length - 1]);

            if (bgc) {
              style.backgroundColor = bgc[0];
              v = v.slice(0, length - 1);
            }
          }

          var bgi = [];
          var bgr = [];
          var bgp = [];
          v.forEach(function (item) {
            if (isNil$c(style.backgroundImage)) {
              var gd = reg.gradient.exec(item);

              if (gd) {
                bgi.push(gd[0]);
                item = item.replace(gd[0], '');
              } else {
                var img = reg.img.exec(v);

                if (img) {
                  bgi.push(img[0]);
                  item = item.replace(img[0], '');
                }
              }
            }

            if (isNil$c(style.backgroundRepeat)) {
              var repeat = /(no-?)?repeat(-?[xy])?/i.exec(item);

              if (repeat) {
                bgr.push(repeat[0].toLowerCase());
              }
            }

            if (isNil$c(style.backgroundPosition)) {
              var position = item.match(reg.position);

              if (position) {
                bgp.push(position.join(' '));
              }
            }
          });

          if (bgi.length) {
            style.backgroundImage = bgi;
          }

          if (bgr.length) {
            style.backgroundRepeat = bgr;
          }

          if (bgp.length) {
            style.backgroundPosition = bgp;
            this.toFull(style, 'backgroundPosition');
          }
        } else {
          if (isNil$c(style.backgroundImage)) {
            var gd = reg.gradient.exec(v);

            if (gd) {
              style.backgroundImage = gd[0];
              v = v.replace(gd[0], '');
            } else {
              var img = reg.img.exec(v);

              if (img) {
                style.backgroundImage = img[0];
                v = v.replace(img[0], '');
              }
            }
          }

          if (isNil$c(style.backgroundRepeat)) {
            var repeat = /(no-?)?repeat(-?[xy])?/i.exec(v);

            if (repeat) {
              style.backgroundRepeat = repeat[0].toLowerCase();
            }
          }

          if (isNil$c(style.backgroundColor)) {
            var _bgc = /^(transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\))/i.exec(v);

            if (_bgc) {
              style.backgroundColor = _bgc[0];
              v = v.replace(_bgc[0], '');
            }
          }

          if (isNil$c(style.backgroundPosition)) {
            var position = v.match(reg.position);

            if (position) {
              style.backgroundPosition = position.join(' ');
              this.toFull(style, 'backgroundPosition');
            }
          }
        }
      } else if (k === 'flex') {
        if (v === 'none') {
          parseFlex(style, 0, 0, 'auto');
        } else if (v === 'auto') {
          parseFlex(style, 1, 1, 'auto');
        } else if (/^[\d.]+\s+[\d.]+\s+(auto|none|content)/.test(v) || /^[\d.]+\s+[\d.]+\s+[\d.]+[pxremvwhina%]*/.test(v)) {
          var arr = v.split(/\s+/);
          parseFlex(style, parseFloat(arr[0]), parseFloat(arr[1]), arr[2]);
        } else if (/^[\d.]+\s+[\d.]+$/.test(v)) {
          var _arr = v.split(/\s+/);

          parseFlex(style, parseFloat(_arr[0]), parseFloat(_arr[1]), 0);
        } else if (/^[\d.]+\s+[\d.]+[pxremvwhina%]+/.test(v)) {
          var _arr2 = v.split(/\s+/);

          parseFlex(style, parseFloat(_arr2[0]), 1, _arr2[1]);
        } else if (/^[\d.]+$/.test(v)) {
          parseFlex(style, parseFloat(v), 1, 0);
        } else if (/^[\d.]+[pxremvwhina%]+/i.test(v)) {
          parseFlex(style, 1, 1, v);
        } else {
          parseFlex(style, 0, 1, 'auto');
        }
      } else if (k === 'flexFlow') {
        v = v.toString().split(/\s+/);

        if (v.length) {
          if (isNil$c(style.flexDirection)) ;

          style.flexDirection = v[0];

          if (v.length > 1) {
            style.flexWrap = v[1];
          }
        }
      } else if (k === 'borderRadius') {
        // borderRadius缩写很特殊，/分隔x/y，然后上右下左4个
        v = v.toString().split('/');

        if (v.length === 1) {
          v[1] = v[0];
        }

        for (var i = 0; i < 2; i++) {
          var item = v[i].toString().split(/\s+/);

          if (item.length === 0) {
            v[i] = [0, 0, 0, 0];
          } else if (item.length === 1) {
            v[i] = [item[0], item[0], item[0], item[0]];
          } else if (item.length === 2) {
            v[i] = [item[0], item[1], item[0], item[1]];
          } else if (item.length === 3) {
            v[i] = [item[0], item[1], item[2], item[1]];
          } else {
            v[i] = item.slice(0, 4);
          }
        }

        this[k].forEach(function (k, i) {
          if (isNil$c(style[k])) {
            style[k] = v[0][i] + ' ' + v[1][i];
          }
        });
      } else if (k === 'backgroundPosition') {
        if (!Array.isArray(v)) {
          v = [v];
        }

        var isEmpty = this[k].map(function (k2) {
          return isNil$c(style[k2]);
        });
        v.forEach(function (v2) {
          v2 = v2.toString().split(/\s+/);

          if (v2.length === 1) {
            v2[1] = '50%';
          }

          _this[k].forEach(function (k2, i) {
            if (isEmpty[i]) {
              style[k2] = style[k2] || [];
              style[k2].push(v2[i]);
            }
          });
        });
      } else if (['translate', 'scale', 'skew'].indexOf(k) > -1) {
        var _arr3 = v.toString().split(/\s*,\s*/);

        if (_arr3.length === 1) {
          _arr3[1] = _arr3[0];
        }

        this[k].forEach(function (k, i) {
          if (isNil$c(style[k])) {
            style[k] = _arr3[i];
          }
        });
      } else if (['translate3d', 'scale3d'].indexOf(k) > -1) {
        var _arr4 = v.toString().split(/\s*,\s*/);

        if (_arr4.length === 1) {
          _arr4[2] = _arr4[1] = _arr4[0];
        } else if (_arr4.length === 2) {
          _arr4[2] = k === 'scale3d' ? 1 : 0;
        }

        this[k].forEach(function (k, i) {
          if (isNil$c(style[k])) {
            style[k] = _arr4[i];
          }
        });
      } else if (k === 'margin' || k === 'padding') {
        parseMarginPadding(style, k, this[k]);
      } else if (/^border((Top)|(Right)|(Bottom)|(Left))$/.test(k)) {
        parseOneBorder(style, k);
      } else if (k === 'textStroke') {
        var w = /(?:^|\s)([-+]?[\d.]+[pxremvwhina%]*)/.exec(v);

        if (w) {
          style.textStrokeWidth = w[1];
        }

        var c = /(transparent)|(#[0-9a-f]{3,8})|(rgba?\s*\(.+?\))/i.exec(v);

        if (c) {
          style.textStrokeColor = c[0];
        }

        if (/\bfill\b/i.test(v)) {
          style.textStrokeOver = 'fill';
        } else {
          style.textStrokeOver = 'none';
        }
      } else if (this[k]) {
        this[k].forEach(function (k) {
          if (isNil$c(style[k])) {
            style[k] = v;
          }
        });
      }

      return style;
    }
  };

  var STYLE_KEY$3 = enums.STYLE_KEY;
  var BACKGROUND_COLOR$3 = STYLE_KEY$3.BACKGROUND_COLOR,
      BORDER_BOTTOM_COLOR$2 = STYLE_KEY$3.BORDER_BOTTOM_COLOR,
      BORDER_LEFT_COLOR$2 = STYLE_KEY$3.BORDER_LEFT_COLOR,
      BORDER_RIGHT_COLOR$2 = STYLE_KEY$3.BORDER_RIGHT_COLOR,
      BORDER_TOP_COLOR$2 = STYLE_KEY$3.BORDER_TOP_COLOR,
      COLOR$8 = STYLE_KEY$3.COLOR,
      TEXT_STROKE_COLOR$7 = STYLE_KEY$3.TEXT_STROKE_COLOR,
      FONT_SIZE$9 = STYLE_KEY$3.FONT_SIZE,
      BORDER_BOTTOM_WIDTH$5 = STYLE_KEY$3.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$8 = STYLE_KEY$3.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$7 = STYLE_KEY$3.BORDER_RIGHT_WIDTH,
      BORDER_TOP_WIDTH$6 = STYLE_KEY$3.BORDER_TOP_WIDTH,
      LEFT$3 = STYLE_KEY$3.LEFT,
      TOP$5 = STYLE_KEY$3.TOP,
      RIGHT$3 = STYLE_KEY$3.RIGHT,
      BOTTOM$5 = STYLE_KEY$3.BOTTOM,
      FLEX_BASIS$5 = STYLE_KEY$3.FLEX_BASIS,
      WIDTH$9 = STYLE_KEY$3.WIDTH,
      HEIGHT$9 = STYLE_KEY$3.HEIGHT,
      LINE_HEIGHT$8 = STYLE_KEY$3.LINE_HEIGHT,
      MARGIN_BOTTOM$6 = STYLE_KEY$3.MARGIN_BOTTOM,
      MARGIN_LEFT$8 = STYLE_KEY$3.MARGIN_LEFT,
      MARGIN_TOP$6 = STYLE_KEY$3.MARGIN_TOP,
      MARGIN_RIGHT$7 = STYLE_KEY$3.MARGIN_RIGHT,
      PADDING_TOP$6 = STYLE_KEY$3.PADDING_TOP,
      PADDING_RIGHT$7 = STYLE_KEY$3.PADDING_RIGHT,
      PADDING_BOTTOM$5 = STYLE_KEY$3.PADDING_BOTTOM,
      PADDING_LEFT$8 = STYLE_KEY$3.PADDING_LEFT,
      STROKE_WIDTH$a = STYLE_KEY$3.STROKE_WIDTH,
      STROKE_MITERLIMIT$2 = STYLE_KEY$3.STROKE_MITERLIMIT,
      LETTER_SPACING$4 = STYLE_KEY$3.LETTER_SPACING,
      PERSPECTIVE$5 = STYLE_KEY$3.PERSPECTIVE,
      TEXT_STROKE_WIDTH$6 = STYLE_KEY$3.TEXT_STROKE_WIDTH,
      TRANSLATE_X$5 = STYLE_KEY$3.TRANSLATE_X,
      TRANSLATE_Y$5 = STYLE_KEY$3.TRANSLATE_Y,
      TRANSLATE_Z$5 = STYLE_KEY$3.TRANSLATE_Z,
      SKEW_X$4 = STYLE_KEY$3.SKEW_X,
      SKEW_Y$4 = STYLE_KEY$3.SKEW_Y,
      SCALE_X$5 = STYLE_KEY$3.SCALE_X,
      SCALE_Y$5 = STYLE_KEY$3.SCALE_Y,
      SCALE_Z$4 = STYLE_KEY$3.SCALE_Z,
      ROTATE_X$4 = STYLE_KEY$3.ROTATE_X,
      ROTATE_Y$4 = STYLE_KEY$3.ROTATE_Y,
      ROTATE_Z$6 = STYLE_KEY$3.ROTATE_Z,
      BACKGROUND_IMAGE$3 = STYLE_KEY$3.BACKGROUND_IMAGE,
      FILL$4 = STYLE_KEY$3.FILL,
      STROKE$3 = STYLE_KEY$3.STROKE,
      BORDER_TOP_LEFT_RADIUS$3 = STYLE_KEY$3.BORDER_TOP_LEFT_RADIUS;
      STYLE_KEY$3.BORDER_TOP_RIGHT_RADIUS;
      var BORDER_BOTTOM_RIGHT_RADIUS$3 = STYLE_KEY$3.BORDER_BOTTOM_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$3 = STYLE_KEY$3.BORDER_BOTTOM_LEFT_RADIUS;

  function isColorKey$2(k) {
    return k === BACKGROUND_COLOR$3 || k === BORDER_BOTTOM_COLOR$2 || k === BORDER_LEFT_COLOR$2 || k === BORDER_RIGHT_COLOR$2 || k === BORDER_TOP_COLOR$2 || k === COLOR$8 || k === TEXT_STROKE_COLOR$7;
  }

  function isLengthKey$2(k) {
    return k === FONT_SIZE$9 || k === TEXT_STROKE_WIDTH$6 || k === BORDER_BOTTOM_WIDTH$5 || k === BORDER_LEFT_WIDTH$8 || k === BORDER_RIGHT_WIDTH$7 || k === BORDER_TOP_WIDTH$6 || k === LEFT$3 || k === TOP$5 || k === RIGHT$3 || k === BOTTOM$5 || k === FLEX_BASIS$5 || k === WIDTH$9 || k === HEIGHT$9 || k === LINE_HEIGHT$8 || k === MARGIN_BOTTOM$6 || k === MARGIN_TOP$6 || k === MARGIN_LEFT$8 || k === MARGIN_RIGHT$7 || k === PADDING_TOP$6 || k === PADDING_RIGHT$7 || k === PADDING_LEFT$8 || k === PADDING_BOTTOM$5 || k === STROKE_WIDTH$a || k === STROKE_MITERLIMIT$2 || k === LETTER_SPACING$4 || k === PERSPECTIVE$5;
  }

  function isExpandKey$2(k) {
    return k === TRANSLATE_X$5 || k === TRANSLATE_Y$5 || k === TRANSLATE_Z$5 || k === SKEW_X$4 || k === SKEW_Y$4 || k === SCALE_X$5 || k === SCALE_Y$5 || k === SCALE_Z$4 || k === ROTATE_X$4 || k === ROTATE_Y$4 || k === ROTATE_Z$6;
  }

  function isGradientKey$2(k) {
    return k === BACKGROUND_IMAGE$3 || k === FILL$4 || k === STROKE$3;
  }

  function isRadiusKey$2(k) {
    return k === BORDER_BOTTOM_LEFT_RADIUS$3 || k === BORDER_TOP_LEFT_RADIUS$3 || k === BORDER_TOP_LEFT_RADIUS$3 || k === BORDER_BOTTOM_RIGHT_RADIUS$3;
  }

  var key = {
    isColorKey: isColorKey$2,
    isLengthKey: isLengthKey$2,
    isExpandKey: isExpandKey$2,
    isGradientKey: isGradientKey$2,
    isRadiusKey: isRadiusKey$2
  };

  var RESET_DOM = reset.DOM,
      RESET_GEOM = reset.GEOM;
  var STYLE_KEY$2 = enums.STYLE_KEY;
  var POINTER_EVENTS$3 = STYLE_KEY$2.POINTER_EVENTS,
      COLOR$7 = STYLE_KEY$2.COLOR,
      STROKE_WIDTH$9 = STYLE_KEY$2.STROKE_WIDTH,
      FILL$3 = STYLE_KEY$2.FILL,
      STROKE_DASHARRAY$2 = STYLE_KEY$2.STROKE_DASHARRAY,
      STROKE_LINECAP$1 = STYLE_KEY$2.STROKE_LINECAP,
      STROKE_LINEJOIN$1 = STYLE_KEY$2.STROKE_LINEJOIN,
      STROKE_MITERLIMIT$1 = STYLE_KEY$2.STROKE_MITERLIMIT,
      BACKGROUND_COLOR$2 = STYLE_KEY$2.BACKGROUND_COLOR,
      BACKGROUND_IMAGE$2 = STYLE_KEY$2.BACKGROUND_IMAGE,
      BACKGROUND_POSITION_X$4 = STYLE_KEY$2.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$4 = STYLE_KEY$2.BACKGROUND_POSITION_Y,
      BACKGROUND_REPEAT$1 = STYLE_KEY$2.BACKGROUND_REPEAT,
      BACKGROUND_SIZE$3 = STYLE_KEY$2.BACKGROUND_SIZE,
      STROKE$2 = STYLE_KEY$2.STROKE,
      BORDER_BOTTOM_COLOR$1 = STYLE_KEY$2.BORDER_BOTTOM_COLOR,
      BORDER_LEFT_COLOR$1 = STYLE_KEY$2.BORDER_LEFT_COLOR,
      BORDER_RIGHT_COLOR$1 = STYLE_KEY$2.BORDER_RIGHT_COLOR,
      BORDER_TOP_COLOR$1 = STYLE_KEY$2.BORDER_TOP_COLOR,
      BORDER_TOP_LEFT_RADIUS$2 = STYLE_KEY$2.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$2 = STYLE_KEY$2.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$2 = STYLE_KEY$2.BORDER_BOTTOM_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$2 = STYLE_KEY$2.BORDER_BOTTOM_LEFT_RADIUS,
      VISIBILITY$7 = STYLE_KEY$2.VISIBILITY,
      BOX_SHADOW$3 = STYLE_KEY$2.BOX_SHADOW,
      OVERFLOW$4 = STYLE_KEY$2.OVERFLOW,
      BACKGROUND_CLIP$2 = STYLE_KEY$2.BACKGROUND_CLIP,
      TEXT_STROKE_WIDTH$5 = STYLE_KEY$2.TEXT_STROKE_WIDTH,
      TEXT_STROKE_COLOR$6 = STYLE_KEY$2.TEXT_STROKE_COLOR,
      TEXT_STROKE_OVER$5 = STYLE_KEY$2.TEXT_STROKE_OVER,
      TRANSLATE_PATH$2 = STYLE_KEY$2.TRANSLATE_PATH;
  var GEOM$3 = {};
  var GEOM_KEY_SET$1 = [];
  var o$2 = {
    GEOM: GEOM$3,
    GEOM_KEY_SET: GEOM_KEY_SET$1,
    addGeom: function addGeom(tagName, ks, cb) {
      if (Array.isArray(ks)) {
        ks.forEach(function (k) {
          o$2.addGeom(tagName, k, cb);
        });
      } else if (ks) {
        if (!GEOM$3.hasOwnProperty(ks)) {
          GEOM_KEY_SET$1.push(ks);
        }

        var hash = GEOM$3[ks] = GEOM$3[ks] || {};
        hash[tagName] = cb || true;
      }
    },
    isIgnore: function isIgnore(k) {
      return k === POINTER_EVENTS$3 || k === TRANSLATE_PATH$2;
    },
    isGeom: function isGeom(tagName, k) {
      return tagName && k && GEOM$3.hasOwnProperty(k) && GEOM$3[k].hasOwnProperty(tagName);
    },
    isRepaint: function isRepaint(k, tagName) {
      return k === COLOR$7 || k === STROKE_WIDTH$9 || k === FILL$3 || k === STROKE_DASHARRAY$2 || k === STROKE_LINECAP$1 || k === STROKE_LINEJOIN$1 || k === STROKE_MITERLIMIT$1 || k === BACKGROUND_COLOR$2 || k === BACKGROUND_IMAGE$2 || k === BACKGROUND_POSITION_X$4 || k === BACKGROUND_POSITION_Y$4 || k === BACKGROUND_REPEAT$1 || k === BACKGROUND_SIZE$3 || k === STROKE$2 || k === BORDER_BOTTOM_COLOR$1 || k === BORDER_LEFT_COLOR$1 || k === BORDER_BOTTOM_COLOR$1 || k === BORDER_RIGHT_COLOR$1 || k === BORDER_TOP_COLOR$1 || k === BORDER_TOP_LEFT_RADIUS$2 || k === BORDER_TOP_RIGHT_RADIUS$2 || k === BORDER_BOTTOM_RIGHT_RADIUS$2 || k === BORDER_BOTTOM_LEFT_RADIUS$2 || k === VISIBILITY$7 || k === BOX_SHADOW$3 || k === OVERFLOW$4 || k === BACKGROUND_CLIP$2 || k === TEXT_STROKE_WIDTH$5 || k === TEXT_STROKE_COLOR$6 || k === TEXT_STROKE_OVER$5 || o$2.isGeom(tagName, k);
    },
    isValid: function isValid(tagName, k) {
      if (!k) {
        return false;
      }

      if (RESET_DOM.hasOwnProperty(k)) {
        return true;
      } // geom的fill等矢量才有的样式


      if (tagName.charAt(0) === '$' && RESET_GEOM.hasOwnProperty(k)) {
        return true;
      }

      if (GEOM$3.hasOwnProperty(k)) {
        return GEOM$3[k].hasOwnProperty(tagName);
      }

      if (k === 'translatePath') {
        return true;
      }

      return false;
    }
  };
  o$2.addGeom('$line', ['x1', 'y1', 'x2', 'y2', 'controlA', 'controlB', 'start', 'end']);
  o$2.addGeom('$circle', ['r']);
  o$2.addGeom('$ellipse', ['rx', 'ry']);
  o$2.addGeom('$rect', ['rx', 'ry']);
  o$2.addGeom('$sector', ['begin', 'end', 'edge', 'closure']);
  o$2.addGeom('$polyline', ['points', 'controls', 'start', 'end']);
  o$2.addGeom('$polygon', ['points', 'controls', 'start', 'end', 'booleanOperations']);

  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据模糊参数sigma求卷积核尺寸
   * @param sigma
   * @returns {number}
   */
  function kernelSize(sigma) {
    if (sigma <= 0) {
      return 0;
    }

    var d = Math.floor(sigma * 3 * Math.sqrt(2 * Math.PI) / 4 + 0.5);

    if (d < 2) {
      d = 2;
    }

    if (d % 2 === 0) {
      d++;
    }

    return d;
  }
  /**
   * 根据sigma求模糊扩展尺寸，卷积核求得后为d，再求半径/2，然后因为算法要执行3次，所以*3
   * 比如本来d为5，半径2.5算上自身像素点则各方向扩展2，*3则扩展6
   * @param sigma
   * @returns {number}
   */


  function outerSize(sigma) {
    var d = kernelSize(sigma);
    return outerSizeByD(d);
  }

  function outerSizeByD(d) {
    return Math.floor(d * 0.5) * 3;
  }
  /**
   * 一维高斯正态分布，根据标准差和卷积核尺寸返回一维权重数组
   * @param sigma
   * @param d
   */


  function gaussianWeight(sigma, d) {
    var list = [];
    var len = Math.floor(d * 0.5);
    var total = 0;

    for (var i = len; i >= 0; i--) {
      var n = Math.pow(Math.E, -Math.pow(i, 2) / (2 * Math.pow(sigma, 2))) / (sigma * Math.sqrt(2 * Math.PI));
      list.push(n);
      total += n;
    }

    for (var _i = 1; _i <= len; _i++) {
      var _n = Math.pow(Math.E, -Math.pow(_i, 2) / (2 * Math.pow(sigma, 2))) / (sigma * Math.sqrt(2 * Math.PI));

      list.push(_n);
      total += _n;
    }

    if (total !== 1) {
      for (var _i2 = 0; _i2 < d; _i2++) {
        list[_i2] /= total;
      }
    }

    return list;
  }

  var blur = {
    kernelSize: kernelSize,
    outerSize: outerSize,
    outerSizeByD: outerSizeByD,
    gaussianWeight: gaussianWeight
  };

  var STYLE_KEY$1 = enums.STYLE_KEY,
      style2Upper$1 = enums.style2Upper,
      _enums$STYLE_KEY$i = enums.STYLE_KEY,
      POSITION$5 = _enums$STYLE_KEY$i.POSITION,
      WIDTH$8 = _enums$STYLE_KEY$i.WIDTH,
      HEIGHT$8 = _enums$STYLE_KEY$i.HEIGHT,
      TRANSLATE_X$4 = _enums$STYLE_KEY$i.TRANSLATE_X,
      TRANSLATE_Y$4 = _enums$STYLE_KEY$i.TRANSLATE_Y,
      TRANSLATE_Z$4 = _enums$STYLE_KEY$i.TRANSLATE_Z,
      SCALE_X$4 = _enums$STYLE_KEY$i.SCALE_X,
      SCALE_Y$4 = _enums$STYLE_KEY$i.SCALE_Y,
      SCALE_Z$3 = _enums$STYLE_KEY$i.SCALE_Z,
      SKEW_X$3 = _enums$STYLE_KEY$i.SKEW_X,
      SKEW_Y$3 = _enums$STYLE_KEY$i.SKEW_Y,
      ROTATE_X$3 = _enums$STYLE_KEY$i.ROTATE_X,
      ROTATE_Y$3 = _enums$STYLE_KEY$i.ROTATE_Y,
      ROTATE_Z$5 = _enums$STYLE_KEY$i.ROTATE_Z,
      ROTATE_3D$4 = _enums$STYLE_KEY$i.ROTATE_3D,
      PERSPECTIVE$4 = _enums$STYLE_KEY$i.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$4 = _enums$STYLE_KEY$i.PERSPECTIVE_ORIGIN,
      TRANSFORM$6 = _enums$STYLE_KEY$i.TRANSFORM,
      TRANSFORM_ORIGIN$5 = _enums$STYLE_KEY$i.TRANSFORM_ORIGIN,
      BACKGROUND_IMAGE$1 = _enums$STYLE_KEY$i.BACKGROUND_IMAGE,
      BACKGROUND_COLOR$1 = _enums$STYLE_KEY$i.BACKGROUND_COLOR,
      BACKGROUND_POSITION_X$3 = _enums$STYLE_KEY$i.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$3 = _enums$STYLE_KEY$i.BACKGROUND_POSITION_Y,
      BACKGROUND_SIZE$2 = _enums$STYLE_KEY$i.BACKGROUND_SIZE,
      OPACITY$6 = _enums$STYLE_KEY$i.OPACITY,
      Z_INDEX$5 = _enums$STYLE_KEY$i.Z_INDEX,
      COLOR$6 = _enums$STYLE_KEY$i.COLOR,
      FONT_SIZE$8 = _enums$STYLE_KEY$i.FONT_SIZE,
      FONT_FAMILY$6 = _enums$STYLE_KEY$i.FONT_FAMILY,
      FONT_WEIGHT$6 = _enums$STYLE_KEY$i.FONT_WEIGHT,
      FONT_STYLE$4 = _enums$STYLE_KEY$i.FONT_STYLE,
      LINE_HEIGHT$7 = _enums$STYLE_KEY$i.LINE_HEIGHT,
      TEXT_ALIGN$3 = _enums$STYLE_KEY$i.TEXT_ALIGN,
      FILTER$6 = _enums$STYLE_KEY$i.FILTER,
      VISIBILITY$6 = _enums$STYLE_KEY$i.VISIBILITY,
      BOX_SHADOW$2 = _enums$STYLE_KEY$i.BOX_SHADOW,
      POINTER_EVENTS$2 = _enums$STYLE_KEY$i.POINTER_EVENTS,
      FILL$2 = _enums$STYLE_KEY$i.FILL,
      STROKE$1 = _enums$STYLE_KEY$i.STROKE,
      STROKE_WIDTH$8 = _enums$STYLE_KEY$i.STROKE_WIDTH,
      STROKE_DASHARRAY$1 = _enums$STYLE_KEY$i.STROKE_DASHARRAY,
      FLEX_BASIS$4 = _enums$STYLE_KEY$i.FLEX_BASIS,
      MATRIX$4 = _enums$STYLE_KEY$i.MATRIX,
      LETTER_SPACING$3 = _enums$STYLE_KEY$i.LETTER_SPACING,
      WHITE_SPACE$3 = _enums$STYLE_KEY$i.WHITE_SPACE,
      LINE_CLAMP$2 = _enums$STYLE_KEY$i.LINE_CLAMP,
      ORDER$2 = _enums$STYLE_KEY$i.ORDER,
      TRANSLATE_PATH$1 = _enums$STYLE_KEY$i.TRANSLATE_PATH,
      TEXT_STROKE_COLOR$5 = _enums$STYLE_KEY$i.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$4 = _enums$STYLE_KEY$i.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER$4 = _enums$STYLE_KEY$i.TEXT_STROKE_OVER,
      WRITING_MODE$3 = _enums$STYLE_KEY$i.WRITING_MODE;
  var AUTO$7 = o$4.AUTO,
      PX$8 = o$4.PX,
      PERCENT$7 = o$4.PERCENT,
      NUMBER$4 = o$4.NUMBER,
      INHERIT$3 = o$4.INHERIT,
      DEG$3 = o$4.DEG,
      RGBA$3 = o$4.RGBA,
      STRING$2 = o$4.STRING,
      REM$7 = o$4.REM,
      VW$7 = o$4.VW,
      VH$7 = o$4.VH,
      VMAX$7 = o$4.VMAX,
      VMIN$7 = o$4.VMIN,
      GRADIENT$3 = o$4.GRADIENT,
      calUnit$1 = o$4.calUnit;
  var isNil$b = util.isNil,
      rgba2int$1 = util.rgba2int,
      equalArr$1 = util.equalArr,
      equal = util.equal,
      replaceRgba2Hex = util.replaceRgba2Hex;
  var isGeom$2 = o$2.isGeom,
      GEOM$2 = o$2.GEOM,
      GEOM_KEY_SET = o$2.GEOM_KEY_SET;
  var VALID_STRING_VALUE = reset.VALID_STRING_VALUE;
  var isColorKey$1 = key.isColorKey,
      isExpandKey$1 = key.isExpandKey,
      isLengthKey$1 = key.isLengthKey,
      isGradientKey$1 = key.isGradientKey,
      isRadiusKey$1 = key.isRadiusKey;

  function isGradient(s) {
    if (reg.gradient.test(s)) {
      var _gradient = reg.gradient.exec(s);

      if (_gradient && ['linear', 'radial', 'conic'].indexOf(_gradient[1]) > -1) {
        return true;
      }
    }
  }

  var TRANSFORM_HASH = {
    translateX: TRANSLATE_X$4,
    translateY: TRANSLATE_Y$4,
    translateZ: TRANSLATE_Z$4,
    scaleX: SCALE_X$4,
    scaleY: SCALE_Y$4,
    scaleZ: SCALE_Z$3,
    skewX: SKEW_X$3,
    skewY: SKEW_Y$3,
    rotateX: ROTATE_X$3,
    rotateY: ROTATE_Y$3,
    rotateZ: ROTATE_Z$5,
    rotate: ROTATE_Z$5
  };

  function compatibleTransform(k, arr) {
    if (k === SCALE_X$4 || k === SCALE_Y$4 || k === SCALE_Z$3) {
      arr.u = NUMBER$4;
    } else if (k === TRANSLATE_X$4 || k === TRANSLATE_Y$4 || k === TRANSLATE_Z$4) {
      if (arr.u === NUMBER$4) {
        arr.u = PX$8;
      }
    } else if (k === PERSPECTIVE$4) {
      if ([NUMBER$4, PERCENT$7, DEG$3].indexOf(arr.u) > -1) {
        arr.u = PX$8;
      }
    } else {
      if (arr.u === NUMBER$4) {
        arr.u = DEG$3;
      }
    }
  }

  function camel(v) {
    if (isNil$b(v)) {
      v = '';
    }

    v = v.toString(); //有-才转换，否则可能是写好的驼峰

    if (v.indexOf('-') > -1) {
      return v.toString().toLowerCase().replace(/-([a-z])/ig, function ($0, $1) {
        return $1.toUpperCase();
      });
    }

    return v;
  }

  function convertStringValue(k, v) {
    v = camel(v);
    var list = VALID_STRING_VALUE[k];
    var i = list.indexOf(v);

    if (i > -1) {
      return list[i];
    } // 兜底默认


    return list[0];
  }
  /**
   * 将传入的手写style标准化，并且用resetList默认值覆盖其中为空的
   * @param style 手写的style样式
   * @param resetList 默认样式，可选
   * @returns Object 标准化的枚举数组结构样式
   */


  function normalize$1(style) {
    var resetList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    if (!util.isObject(style)) {
      return {};
    }

    var res = {}; // style只有单层无需深度clone

    style = util.extend({}, style); // 缩写提前处理，因为reset里没有缩写

    var temp = style.border;

    if (temp) {
      abbr$1.toFull(style, 'border');
    }

    ['borderTop', 'borderRight', 'borderBottom', 'borderLeft'].forEach(function (k) {
      abbr$1.toFull(style, k);
    });
    temp = style.borderWidth;

    if (temp) {
      abbr$1.toFull(style, 'borderWidth');
    }

    temp = style.borderColor;

    if (temp) {
      abbr$1.toFull(style, 'borderColor');
    }

    temp = style.borderStyle;

    if (temp) {
      abbr$1.toFull(style, 'borderStyle');
    }

    temp = style.borderRadius;

    if (temp) {
      abbr$1.toFull(style, 'borderRadius');
    }

    temp = style.background; // 处理渐变背景缩写

    if (temp) {
      abbr$1.toFull(style, 'background');
    } // 背景位置


    temp = style.backgroundPosition;

    if (!isNil$b(temp)) {
      abbr$1.toFull(style, 'backgroundPosition');
    } // flex


    temp = style.flex;

    if (temp) {
      abbr$1.toFull(style, 'flex');
    } // flex-flow


    temp = style.flexFlow;

    if (temp) {
      abbr$1.toFull(style, 'flexFlow');
    }

    temp = style.margin;

    if (!isNil$b(temp)) {
      abbr$1.toFull(style, 'margin');
    }

    temp = style.padding;

    if (!isNil$b(temp)) {
      abbr$1.toFull(style, 'padding');
    }

    temp = style.textStroke;

    if (temp) {
      abbr$1.toFull(style, 'textStroke');
    }

    temp = style.rotate3d;

    if (temp) {
      abbr$1.toFull(style, 'rotate3d');
    } // 扩展css，将transform几个值拆分为独立的css为动画准备，同时不能使用transform


    ['translate', 'scale', 'skew', 'translate3d', 'scale3d', 'rotate'].forEach(function (k) {
      temp = style[k];

      if (!isNil$b(temp)) {
        abbr$1.toFull(style, k);
      }
    }); // 扩展的不能和transform混用，给出警告

    ['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY', 'rotateX', 'rotateY', 'rotateZ', 'rotate3d'].forEach(function (k) {
      var v = style[k];

      if (v !== undefined && style.transform) {
        inject.warn("Can not use expand style \"".concat(k, "\" with transform"));
      }
    }); // 默认reset，根据传入不同，当style为空时覆盖

    resetList.forEach(function (item) {
      var k = item.k,
          v = item.v;

      if (isNil$b(style[k])) {
        style[k] = v;
      }
    }); // 背景图

    temp = style.backgroundImage;

    if (temp !== undefined) {
      if (!temp) {
        res[BACKGROUND_IMAGE$1] = [];
      } else if (Array.isArray(temp)) {
        res[BACKGROUND_IMAGE$1] = temp.map(function (item) {
          if (!item) {
            return null;
          }

          if (isGradient(item)) {
            return {
              v: gradient.parseGradient(item),
              u: GRADIENT$3
            };
          }

          if (reg.img.test(item)) {
            return {
              v: reg.img.exec(item)[2],
              u: STRING$2
            };
          }

          return null;
        });
      } // 区分是渐变色还是图
      else if (isGradient(temp)) {
        res[BACKGROUND_IMAGE$1] = [{
          v: gradient.parseGradient(temp),
          u: GRADIENT$3
        }];
      } else if (reg.img.test(temp)) {
        res[BACKGROUND_IMAGE$1] = [{
          v: reg.img.exec(temp)[2],
          u: STRING$2
        }];
      } else {
        res[BACKGROUND_IMAGE$1] = [];
      }
    }

    temp = style.backgroundColor;

    if (temp !== undefined) {
      temp = temp || 'transparent'; // 先赋值默认透明，后续操作有合法值覆盖

      var bgc = /^#[0-9a-f]{3,8}/i.exec(temp);

      if (bgc && [4, 7, 9].indexOf(bgc[0].length) > -1) {
        res[BACKGROUND_COLOR$1] = {
          v: rgba2int$1(bgc[0]),
          u: RGBA$3
        };
      } else {
        bgc = /rgba?\s*\(.+\)/i.exec(temp);
        res[BACKGROUND_COLOR$1] = {
          v: rgba2int$1(bgc ? bgc[0] : [0, 0, 0, 0]),
          u: RGBA$3
        };
      }
    }

    ['backgroundPositionX', 'backgroundPositionY'].forEach(function (k, i) {
      temp = style[k];

      if (temp !== undefined) {
        temp = temp || 0;
        k = i ? BACKGROUND_POSITION_Y$3 : BACKGROUND_POSITION_X$3;

        if (!Array.isArray(temp)) {
          temp = [temp];
        }

        res[k] = temp.map(function (item) {
          if (/^[-+]?[\d.]/.test(item)) {
            var v = calUnit$1(item);

            if ([NUMBER$4, DEG$3].indexOf(v.u) > -1) {
              v.u = PX$8;
            }

            return v;
          } else {
            return {
              v: {
                top: 0,
                left: 0,
                center: 50,
                right: 100,
                bottom: 100
              }[item] || 0,
              u: PERCENT$7
            };
          }
        });
      }
    }); // 背景尺寸

    temp = style.backgroundSize;

    if (temp !== undefined) {
      if (!Array.isArray(temp)) {
        temp = [temp];
      }

      res[BACKGROUND_SIZE$2] = temp.map(function (item) {
        if (!item) {
          return [{
            u: AUTO$7
          }, {
            u: AUTO$7
          }];
        }

        var match = item.toString().match(/\b(?:([-+]?[\d.]+[pxremvwhina%]*)|(contain|cover|auto))/ig);

        if (match) {
          if (match.length === 1) {
            if (match[0].toLowerCase() === 'contain' || match[0].toLowerCase() === 'cover') {
              match[1] = match[0].toLowerCase();
            } else {
              match[1] = 'auto';
            }
          }

          var v = [];

          for (var i = 0; i < 2; i++) {
            var _item = match[i].toLowerCase();

            if (/^[-+]?[\d.]/.test(_item)) {
              var n = calUnit$1(_item);

              if ([NUMBER$4, DEG$3].indexOf(n.u) > -1) {
                n.u = PX$8;
              }

              v.push(n);
            } else if (_item === 'contain' || _item === 'cover') {
              v.push({
                v: _item,
                u: STRING$2
              });
            } else {
              v.push({
                u: AUTO$7
              });
            }
          }

          return v;
        } else {
          return [{
            u: AUTO$7
          }, {
            u: AUTO$7
          }];
        }
      });
    } // border-color


    ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
      k = 'border' + k + 'Color';
      var v = style[k];

      if (v !== undefined) {
        res[STYLE_KEY$1[style2Upper$1(k)]] = {
          v: rgba2int$1(v || 'transparent'),
          u: RGBA$3
        };
      }
    }); // border-radius

    ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'].forEach(function (k) {
      k = 'border' + k + 'Radius';
      var v = style[k];

      if (v !== undefined) {
        v = v || 0;
        var arr = v.toString().split(/\s+/);

        if (arr.length === 1) {
          arr[1] = arr[0];
        }

        for (var i = 0; i < 2; i++) {
          var item = arr[i];

          if (/^[-+]?[\d.]/.test(item)) {
            var n = calUnit$1(item);

            if ([NUMBER$4, DEG$3].indexOf(n.u) > -1) {
              n.u = PX$8;
            }

            if (n.v < 0) {
              n.v = 0;
            }

            arr[i] = n;
          } else {
            arr[i] = {
              u: 0,
              v: PX$8
            };
          }
        }

        res[STYLE_KEY$1[style2Upper$1(k)]] = arr;
      }
    });
    temp = style.transform;

    if (temp !== undefined) {
      var transform = res[TRANSFORM$6] = [];
      var match = (temp || '').toString().match(/\w+\(.+?\)/g);

      if (match) {
        match.forEach(function (item) {
          var i = item.indexOf('(');
          var k = item.slice(0, i);
          var v = item.slice(i + 1, item.length - 1);

          if (k === 'matrix') {
            var arr = v.toString().split(/\s*,\s*/);
            arr = arr.map(function (item) {
              return parseFloat(item);
            });

            if (arr.length > 6) {
              arr = arr.slice(0, 6);
            }

            if (arr.length === 6) {
              transform.push({
                k: MATRIX$4,
                v: [arr[0], arr[1], 0, 0, arr[2], arr[3], 0, 0, 0, 0, 1, 0, arr[4], arr[5], 0, 1]
              });
            }
          } else if (k === 'matrix3d') {
            var _arr = v.toString().split(/\s*,\s*/);

            _arr = _arr.map(function (item) {
              return parseFloat(item);
            });

            if (_arr.length > 16) {
              _arr = _arr.slice(0, 16);
            }

            if (_arr.length === 16) {
              transform.push({
                k: MATRIX$4,
                v: _arr
              });
            }
          } else if (k === 'perspective') {
            var _arr2 = calUnit$1(v);

            if (_arr2.v < 0) {
              _arr2.v = 0;
            }

            compatibleTransform(PERSPECTIVE$4, _arr2);
            transform.push({
              k: PERSPECTIVE$4,
              v: _arr2
            });
          } else if (k === 'rotate3d') {
            var _arr3 = v.toString().split(/\s*,\s*/);

            if (_arr3.length === 4) {
              var deg = calUnit$1(_arr3[3]);
              compatibleTransform(ROTATE_3D$4, deg);
              _arr3[0] = parseFloat(_arr3[0].replace('(', ''));
              _arr3[1] = parseFloat(_arr3[1]);
              _arr3[2] = parseFloat(_arr3[2]);
              _arr3[3] = deg;
              transform.push({
                k: ROTATE_3D$4,
                v: _arr3
              });
            }
          } else if (TRANSFORM_HASH.hasOwnProperty(k)) {
            var k2 = TRANSFORM_HASH[k];

            var _arr4 = calUnit$1(v);

            compatibleTransform(k2, _arr4);
            transform.push({
              k: k2,
              v: _arr4
            });
          } else if ({
            translate: true,
            scale: true,
            skew: true
          }.hasOwnProperty(k)) {
            var _arr5 = v.toString().split(/\s*,\s*/);

            if (_arr5.length === 1) {
              _arr5[1] = k === 'scale' ? _arr5[0] : [0];
            }

            if (_arr5.length === 2) {
              var k1 = STYLE_KEY$1[style2Upper$1(k + 'X')];
              var _k = STYLE_KEY$1[style2Upper$1(k + 'Y')];
              var arr1 = calUnit$1(_arr5[0]);
              var arr2 = calUnit$1(_arr5[1]);
              compatibleTransform(k1, arr1);
              compatibleTransform(_k, arr2);
              transform.push({
                k: k1,
                v: arr1
              });
              transform.push({
                k: _k,
                v: arr2
              });
            }
          } else if ({
            translate3d: true,
            scale3d: true
          }.hasOwnProperty(k)) {
            var _arr6 = v.toString().split(/\s*,\s*/);

            if (_arr6.length === 1) {
              _arr6[1] = k === 'scale3d' ? [1] : [0];
              _arr6[2] = k === 'scale3d' ? [1] : [0];
            } else if (_arr6.length === 2) {
              _arr6[2] = k === 'scale3d' ? [1] : [0];
            }

            if (_arr6.length === 3) {
              var _k2 = STYLE_KEY$1[style2Upper$1(k + 'X')];
              var _k3 = STYLE_KEY$1[style2Upper$1(k + 'Y')];
              var k3 = STYLE_KEY$1[style2Upper$1(k + 'Z')];

              var _arr7 = calUnit$1(_arr6[0]);

              var _arr8 = calUnit$1(_arr6[1]);

              var arr3 = calUnit$1(_arr6[2]);
              compatibleTransform(_k2, _arr7);
              compatibleTransform(_k3, _arr8);
              compatibleTransform(k3, arr3);
              transform.push({
                k: _k2,
                v: _arr7
              });
              transform.push({
                k: _k3,
                v: _arr8
              });
              transform.push({
                k: k3,
                v: arr3
              });
            }
          }
        });
      }
    }

    temp = style.perspective;

    if (temp !== undefined) {
      var arr = calUnit$1(temp || 0);

      if (arr.v < 0) {
        arr.v = 0;
      }

      compatibleTransform(PERSPECTIVE$4, arr);
      res[PERSPECTIVE$4] = arr;
    }

    ['perspectiveOrigin', 'transformOrigin'].forEach(function (k) {
      temp = style[k];

      if (temp !== undefined) {
        if (temp === null) {
          temp = '';
        }

        var _arr9 = res[STYLE_KEY$1[style2Upper$1(k)]] = [];

        var _match = temp.toString().match(reg.position);

        if (_match) {
          if (_match.length === 1) {
            _match[1] = _match[0];
          }

          for (var i = 0; i < 2; i++) {
            var item = _match[i];

            if (/^[-+]?[\d.]/.test(item)) {
              var n = calUnit$1(item);

              if ([NUMBER$4, DEG$3].indexOf(n.u) > -1) {
                n.u = PX$8;
              }

              _arr9.push(n);
            } else {
              _arr9.push({
                v: {
                  top: 0,
                  left: 0,
                  center: 50,
                  right: 100,
                  bottom: 100
                }[item],
                u: PERCENT$7
              }); // 不规范的写法变默认值50%


              if (isNil$b(_arr9[i].v)) {
                _arr9[i].v = 50;
              }
            }
          }
        } else {
          _arr9.push({
            v: 50,
            u: PERCENT$7
          });

          _arr9.push({
            v: 50,
            u: PERCENT$7
          });
        }
      }
    });
    ['translateX', 'translateY', 'translateZ', 'scaleX', 'scaleY', 'scaleZ', 'skewX', 'skewY', 'rotateX', 'rotateY', 'rotateZ', 'rotate'].forEach(function (k) {
      var v = style[k];

      if (v === undefined) {
        return;
      }

      if (v === null) {
        if (k.indexOf('scale') === 0) {
          v = 1;
        } else {
          v = 0;
        }
      }

      var k2 = TRANSFORM_HASH[k];
      var n = calUnit$1(v); // 没有单位或默认值处理单位

      compatibleTransform(k2, n);
      res[k2] = n;
    });
    temp = style.rotate3d;

    if (temp !== undefined) {
      var _arr10 = (temp || '').toString().split(/\s*,\s*/);

      if (_arr10.length === 4) {
        var deg = calUnit$1(_arr10[3]);
        compatibleTransform(ROTATE_3D$4, deg);
        _arr10[0] = parseFloat(_arr10[0].replace('(', ''));
        _arr10[1] = parseFloat(_arr10[1]);
        _arr10[2] = parseFloat(_arr10[2]);
        _arr10[3] = deg;
      }

      res[ROTATE_3D$4] = _arr10;
    }

    temp = style.opacity;

    if (temp !== undefined) {
      if (temp === null) {
        temp = 1;
      }

      temp = parseFloat(temp);

      if (!isNaN(temp)) {
        temp = Math.max(temp, 0);
        temp = Math.min(temp, 1);
        res[OPACITY$6] = temp;
      } else {
        res[OPACITY$6] = 1;
      }
    }

    temp = style.zIndex;

    if (temp !== undefined) {
      res[Z_INDEX$5] = parseInt(temp) || 0;
    } // 转化不同单位值为对象标准化，不写单位的变成number单位转化为px


    ['marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'borderTopWidth', 'borderRightWidth', 'borderBottomWidth', 'borderLeftWidth', 'top', 'right', 'bottom', 'left', 'width', 'height'].forEach(function (k) {
      var v = style[k];

      if (v === undefined) {
        return;
      }

      if (v === 'auto') {
        v = {
          v: 0,
          u: AUTO$7
        };
      } else {
        v = calUnit$1(v || 0); // 无单位视为px

        if ([NUMBER$4, DEG$3].indexOf(v.u) > -1) {
          v.u = PX$8;
        }
      }

      var k2 = STYLE_KEY$1[style2Upper$1(k)];
      res[k2] = v; // 限制padding/border为正数

      if ({
        paddingTop: true,
        paddingRight: true,
        paddingBottom: true,
        paddingLeft: true,
        borderTopWidth: true,
        borderRightWidth: true,
        borderBottomWidth: true,
        borderLeftWidth: true,
        width: true,
        height: true
      }.hasOwnProperty(k) && v.v < 0) {
        v.v = 0;
      }
    });
    temp = style.flexBasis;

    if (temp !== undefined) {
      if (/content/i.test(temp)) {
        res[FLEX_BASIS$4] = {
          v: temp.toLowerCase(),
          u: STRING$2
        };
      } else if (/^[\d.]/.test(temp)) {
        var v = res[FLEX_BASIS$4] = calUnit$1(temp);
        v.v = Math.max(v.v, 0); // 无单位视为px

        if ([NUMBER$4, DEG$3].indexOf(v.u) > -1) {
          v.u = PX$8;
        }
      } else {
        res[FLEX_BASIS$4] = {
          v: 0,
          u: AUTO$7
        };
      }
    }

    temp = style.order;

    if (temp !== undefined) {
      res[ORDER$2] = parseInt(temp) || 0;
    }

    temp = style.color;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[COLOR$6] = {
          u: INHERIT$3
        };
      } else if (isGradient(temp)) {
        res[COLOR$6] = {
          v: gradient.parseGradient(temp),
          u: GRADIENT$3
        };
      } else {
        res[COLOR$6] = {
          v: rgba2int$1(temp),
          u: RGBA$3
        };
      }
    }

    temp = style.textStrokeColor;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[TEXT_STROKE_COLOR$5] = {
          u: INHERIT$3
        };
      } else if (isGradient(temp)) {
        res[TEXT_STROKE_COLOR$5] = {
          v: gradient.parseGradient(temp),
          u: GRADIENT$3
        };
      } else {
        res[TEXT_STROKE_COLOR$5] = {
          v: rgba2int$1(temp),
          u: RGBA$3
        };
      }
    }

    temp = style.fontSize;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[FONT_SIZE$8] = {
          u: INHERIT$3
        };
      } else {
        var _v = calUnit$1(temp); // fontSize不能为负数，否则为继承


        if (_v < 0) {
          res[FONT_SIZE$8] = {
            u: INHERIT$3
          };
        } else {
          if ([NUMBER$4, DEG$3].indexOf(_v.u) > -1) {
            _v.u = PX$8;
          }

          res[FONT_SIZE$8] = _v;
        }
      }
    }

    temp = style.textStrokeWidth;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[TEXT_STROKE_WIDTH$4] = {
          u: INHERIT$3
        };
      } else {
        var _v2 = calUnit$1(temp); // textStrokeWidth不能为负数，否则为继承


        if (_v2 < 0) {
          res[TEXT_STROKE_WIDTH$4] = {
            u: INHERIT$3
          };
        } else {
          if ([NUMBER$4, DEG$3, PERCENT$7].indexOf(_v2.u) > -1) {
            _v2.u = PX$8;
          }

          res[TEXT_STROKE_WIDTH$4] = _v2;
        }
      }
    }

    temp = style.textStrokeOver;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[TEXT_STROKE_OVER$4] = {
          u: INHERIT$3
        };
      } else {
        var _v3 = reset.INHERIT.textStrokeOver;

        if (/fill/i.test(temp)) {
          _v3 = 'fill';
        }

        res[TEXT_STROKE_OVER$4] = {
          v: _v3,
          u: STRING$2
        };
      }
    }

    temp = style.fontWeight;

    if (temp !== undefined) {
      if (/bold/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          v: 700,
          u: NUMBER$4
        };
      } else if (/normal/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          v: 400,
          u: NUMBER$4
        };
      } else if (/lighter/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          v: 200,
          u: NUMBER$4
        };
      } else if (/inherit/i.test(temp)) {
        res[FONT_WEIGHT$6] = {
          u: INHERIT$3
        };
      } else {
        res[FONT_WEIGHT$6] = {
          v: Math.max(0, parseInt(temp)) || 400,
          u: NUMBER$4
        };
      }
    }

    temp = style.fontStyle;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[FONT_STYLE$4] = {
          u: INHERIT$3
        };
      } else {
        var _v4 = reset.INHERIT.fontStyle;

        if (/italic/i.test(temp)) {
          _v4 = 'italic';
        } else if (/oblique/i.test(temp)) {
          _v4 = 'oblique';
        }

        res[FONT_STYLE$4] = {
          v: _v4,
          u: STRING$2
        };
      }
    }

    temp = style.fontFamily;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[FONT_FAMILY$6] = {
          u: INHERIT$3
        };
      } else {
        // 统一文字声明格式
        res[FONT_FAMILY$6] = {
          v: temp.toString().toLowerCase().replace(/['"]/, '').replace(/\s*,\s*/g, ','),
          u: STRING$2
        };
      }
    }

    temp = style.writingMode;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[WRITING_MODE$3] = {
          u: INHERIT$3
        };
      } else {
        var _v5 = reset.INHERIT.writingMode;

        if (/vertical-?rl/i.test(temp)) {
          _v5 = 'verticalRl';
        } else if (/vertical-?lr/i.test(temp)) {
          _v5 = 'verticalLr';
        }

        res[WRITING_MODE$3] = {
          v: _v5,
          u: STRING$2
        };
      }
    }

    temp = style.textAlign;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[TEXT_ALIGN$3] = {
          u: INHERIT$3
        };
      } else {
        var _v6 = 'left';

        if (/center/i.test(temp)) {
          _v6 = 'center';
        } else if (/right/i.test(temp)) {
          _v6 = 'right';
        }

        res[TEXT_ALIGN$3] = {
          v: _v6,
          u: STRING$2
        };
      }
    }

    temp = style.lineHeight;

    if (temp !== undefined) {
      if (/inherit/i.test(temp)) {
        res[LINE_HEIGHT$7] = {
          u: INHERIT$3
        };
      } else if (/normal/i.test(temp)) {
        res[LINE_HEIGHT$7] = {
          u: AUTO$7
        };
      } // lineHeight默认数字，想要px必须强制带单位
      else if (/^[\d.]+/i.test(temp)) {
        var _v7 = calUnit$1(temp);

        if ([DEG$3].indexOf(_v7.u) > -1) {
          _v7.u = NUMBER$4;
        }

        res[LINE_HEIGHT$7] = _v7;
      } else {
        var n = Math.max(0, parseFloat(temp)) || 'normal'; // 非法数字

        if (n === 'normal') {
          res[LINE_HEIGHT$7] = {
            u: AUTO$7
          };
        } else {
          res[LINE_HEIGHT$7] = {
            v: n,
            u: NUMBER$4
          };
        }
      }
    }

    temp = style.letterSpacing;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[LETTER_SPACING$3] = {
          u: INHERIT$3
        };
      } else if (/normal/i.test(temp)) {
        res[LETTER_SPACING$3] = {
          v: 0,
          u: PX$8
        };
      } else if (/^[-+]?[\d.]/.test(temp)) {
        var _v8 = calUnit$1(temp);

        if ([NUMBER$4, DEG$3].indexOf(_v8.u) > -1) {
          _v8.u = PX$8;
        }

        res[LETTER_SPACING$3] = _v8;
      } else {
        res[LETTER_SPACING$3] = {
          v: parseFloat(temp) || 0,
          u: PX$8
        };
      }
    }

    temp = style.whiteSpace;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[WHITE_SPACE$3] = {
          u: INHERIT$3
        };
      } else {
        res[WHITE_SPACE$3] = {
          v: temp,
          u: STRING$2
        };
      }
    }

    temp = style.lineClamp;

    if (temp !== undefined) {
      temp = parseInt(temp) || 0;
      res[LINE_CLAMP$2] = Math.max(0, temp);
    } // fill和stroke为渐变时特殊处理，fillRule无需处理字符串


    ['fill', 'stroke'].forEach(function (k, i) {
      temp = style[k];

      if (temp !== undefined) {
        k = i ? STROKE$1 : FILL$2;

        if (!Array.isArray(temp)) {
          temp = [temp];
        }

        res[k] = temp.map(function (item) {
          if (!item) {
            return {
              v: 'none',
              u: STRING$2
            };
          } else if (isGradient(item)) {
            return {
              v: gradient.parseGradient(item),
              u: GRADIENT$3
            };
          } else {
            return {
              v: rgba2int$1(item),
              u: RGBA$3
            };
          }
        });
      }
    });
    temp = style.strokeWidth;

    if (temp !== undefined) {
      if (!Array.isArray(temp)) {
        temp = [temp];
      }

      res[STROKE_WIDTH$8] = temp.map(function (item) {
        var v = calUnit$1(item);

        if ([NUMBER$4, DEG$3].indexOf(v.u) > -1) {
          v.u = PX$8;
        }

        v.v = Math.max(v.v, 0);
        return v;
      });
    }

    temp = style.strokeDasharray;

    if (temp !== undefined) {
      if (Array.isArray(temp)) {
        res[STROKE_DASHARRAY$1] = temp.map(function (item) {
          var match = (item || '').toString().match(/[\d.]+/g);

          if (match) {
            match = match.map(function (item) {
              return parseFloat(item);
            });

            if (match.length % 2 === 1) {
              match.push(match[match.length - 1]);
            }

            return match;
          }

          return [];
        });
      } else {
        var _match2 = (temp || '').toString().match(/[\d.]+/g);

        if (_match2) {
          _match2 = _match2.map(function (item) {
            return parseFloat(item);
          });

          if (_match2.length % 2 === 1) {
            _match2.push(_match2[_match2.length - 1]);
          }

          res[STROKE_DASHARRAY$1] = [_match2];
        } else {
          res[STROKE_DASHARRAY$1] = [[]];
        }
      }
    }

    temp = style.filter;

    if (temp !== undefined) {
      var f = []; // 先替换掉rgba为#RGBA格式，然后分割

      var _arr11 = (replaceRgba2Hex(temp) || '').match(/[\w-]+\s*\(.+?\)/ig);

      if (_arr11) {
        _arr11.forEach(function (item) {
          var match = /([\w-]+)\s*\((\s*.+\s*)\)/i.exec(item);

          if (match) {
            var k = match[1].toLowerCase(),
                _v9 = match[2];

            if (k === 'drop-shadow' || k === 'dropshadow') {
              var coords = /([-+]?[\d.]+[pxremvwhina%]*)[\s,]+([-+]?[\d.]+[pxremvwhina%]*)[\s,]+(?:([-+]?[\d.]+[pxremvwhina%]*)[\s,])?([-+]?[\d.]+[pxremvwhina%]*\s*)?/ig.exec(item);

              if (coords) {
                var _res = []; // v,h,blur,spread，其中v和h是必须，其余没有为0

                for (var i = 1; i <= 4; i++) {
                  var item2 = coords[i];

                  if (item2) {
                    var _v10 = calUnit$1(item2);

                    if ([NUMBER$4, DEG$3].indexOf(_v10.u) > -1) {
                      _v10.u = PX$8;
                    } // x/y可以负，blur和spread不行


                    if (i > 2 && _v10.v < 0) {
                      _v10.v = 0;
                    }

                    _res.push(_v10);
                  } else {
                    _res.push({
                      v: 0,
                      u: PX$8
                    });
                  }
                }

                var color = /#[a-f\d]{3,8}/i.exec(item);

                if (color) {
                  _res.push(rgba2int$1(color[0]));
                } else {
                  _res.push([0, 0, 0, 1]);
                }

                f.push({
                  k: 'dropShadow',
                  v: _res
                });
              }
            } else {
              var m2 = /([-+]?[\d.]+\s*[pxremvwhdg%]*)/i.exec(_v9);

              if (m2) {
                var _v11 = calUnit$1(m2[0]);

                if (k === 'blur') {
                  if ([DEG$3, PERCENT$7].indexOf(_v11.u) > -1) {
                    return;
                  }

                  if (_v11.u === NUMBER$4) {
                    _v11.u = PX$8;
                  }

                  _v11.v = Math.max(_v11.v, 0);
                  f.push({
                    k: k,
                    v: _v11
                  });
                } else if (k === 'hue-rotate' || k === 'huerotate') {
                  if ([NUMBER$4, DEG$3].indexOf(_v11.u) === -1) {
                    return;
                  }

                  _v11.u = DEG$3;
                  f.push({
                    k: 'hueRotate',
                    v: _v11
                  });
                } else if (k === 'saturate' || k === 'brightness' || k === 'grayscale' || k === 'contrast' || k === 'sepia' || k === 'invert') {
                  if ([NUMBER$4, PERCENT$7].indexOf(_v11.u) === -1) {
                    return;
                  }

                  _v11.v = Math.max(_v11.v, 0);
                  _v11.u = PERCENT$7;
                  f.push({
                    k: k,
                    v: _v11
                  });
                }
              }
            }
          }
        });
      }

      res[FILTER$6] = f;
    }

    temp = style.visibility;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[VISIBILITY$6] = {
          u: INHERIT$3
        };
      } else {
        var _v12 = reset.INHERIT.visibility;

        if (/hidden/i.test(temp)) {
          _v12 = 'hidden';
        }

        res[VISIBILITY$6] = {
          v: _v12,
          u: STRING$2
        };
      }
    }

    temp = style.pointerEvents;

    if (temp !== undefined) {
      if (temp === null || /inherit/i.test(temp)) {
        res[POINTER_EVENTS$2] = {
          u: INHERIT$3
        };
      } else {
        var _v13 = reset.INHERIT.pointerEvents;

        if (/none/i.test(temp)) {
          _v13 = 'none';
        }

        res[POINTER_EVENTS$2] = {
          v: _v13,
          u: STRING$2
        };
      }
    }

    temp = style.boxShadow;

    if (temp !== undefined) {
      var bs = []; // 先替换掉rgba为#RGBA格式，然后按逗号分割

      var _arr12 = (replaceRgba2Hex(temp) || '').split(',');

      if (_arr12) {
        _arr12.forEach(function (item) {
          var coords = /([-+]?[\d.]+[pxremvwhina%]*)\s*([-+]?[\d.]+[pxremvwhina%]*)\s*([-+]?[\d.]+[pxremvwhina%]*\s*)?([-+]?[\d.]+[pxremvwhina%]*\s*)?/i.exec(item);

          if (coords) {
            var _res2 = []; // v,h,blur,spread，其中v和h是必须，其余没有为0

            for (var i = 1; i <= 4; i++) {
              var item2 = coords[i];

              if (item2) {
                var _v14 = calUnit$1(item2);

                if ([NUMBER$4, DEG$3].indexOf(_v14.u) > -1) {
                  _v14.u = PX$8;
                } // x/y可以负，blur和spread不行


                if (i > 2 && _v14.v < 0) {
                  _v14.v = 0;
                }

                _res2.push(_v14);
              } else {
                _res2.push({
                  v: 0,
                  u: PX$8
                });
              }
            }

            var color = /#[a-f\d]{3,8}/i.exec(item);

            if (color) {
              _res2.push(rgba2int$1(color[0]));
            } else {
              _res2.push([0, 0, 0, 1]);
            }

            _res2.push(/inset/i.test(item) ? 'inset' : 'outset');

            bs.push(_res2);
          }
        });
      }

      res[BOX_SHADOW$2] = bs;
    } // 直接赋值的string类型


    ['position', 'display', 'flexDirection', 'flexWrap', 'justifyContent', 'alignItems', 'alignSelf', 'alignContent', 'overflow', 'mixBlendMode', 'borderTopStyle', 'borderRightStyle', 'borderBottomStyle', 'borderLeftStyle', 'backgroundClip', 'textOverflow'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[STYLE_KEY$1[style2Upper$1(k)]] = convertStringValue(k, style[k]);
      }
    }); // 直接赋值的number类型

    ['flexGrow', 'flexShrink'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[STYLE_KEY$1[style2Upper$1(k)]] = Math.max(parseFloat(style[k]) || 0, 0);
      }
    });
    temp = style.zIndex;

    if (temp !== undefined) {
      res[Z_INDEX$5] = parseFloat(temp) || 0;
    } // 这些支持多个的用数组表示


    ['backgroundRepeat', 'strokeLinecap', 'strokeLinejoin', 'strokeMiterlimit', 'fillRule'].forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        var _v15 = style[k];

        if (!Array.isArray(_v15)) {
          _v15 = [_v15];
        }

        if (k === 'backgroundRepeat') {
          _v15.forEach(function (item, i) {
            if (item) {
              _v15[i] = camel(item);
            }
          });
        }

        res[STYLE_KEY$1[style2Upper$1(k)]] = _v15;
      }
    });
    GEOM_KEY_SET.forEach(function (k) {
      if (style.hasOwnProperty(k)) {
        res[k] = style[k];
      }
    });
    return res;
  }

  function setFontStyle(style) {
    var fontSize = style[FONT_SIZE$8] || 0;
    var fontFamily = style[FONT_FAMILY$6] || inject.defaultFontFamily || 'arial';

    if (/\s/.test(fontFamily)) {
      fontFamily = '"' + fontFamily.replace(/"/g, '\\"') + '"';
    }

    return (style[FONT_STYLE$4] || 'normal') + ' ' + (style[FONT_WEIGHT$6] || '400') + ' ' + fontSize + 'px/' + fontSize + 'px ' + fontFamily;
  }
  /**
   * https://zhuanlan.zhihu.com/p/25808995
   * 根据字形信息计算baseline的正确值，差值上下均分
   * @param style computedStyle
   * @returns {number}
   */


  function getBaseline$1(style) {
    var fontSize = style[FONT_SIZE$8];
    var ff = calFontFamily$1(style[FONT_FAMILY$6]);
    var normal = calNormalLineHeight$1(style, ff);
    return (style[LINE_HEIGHT$7] - normal) * 0.5 + fontSize * (o$3.info[ff] || o$3.info[inject.defaultFontFamily] || o$3.info.arial).blr;
  } // 垂直排版的baseline和水平类似，只是原点坐标系不同，删除加本身高度变为加gap高度


  function getVerticalBaseline$1(style) {
    return style[LINE_HEIGHT$7] - getBaseline$1(style);
  }

  function calNormalLineHeight$1(style, ff) {
    if (!ff) {
      ff = calFontFamily$1(style[FONT_FAMILY$6]);
    }

    return style[FONT_SIZE$8] * (o$3.info[ff] || o$3.info[inject.defaultFontFamily] || o$3.info.arial).lhr;
  }

  function calFontFamily$1(fontFamily) {
    var ff = fontFamily.split(/\s*,\s*/);

    for (var i = 0, len = ff.length; i < len; i++) {
      var item = ff[i].replace(/^['"]/, '').replace(/['"]$/, '');

      if (o$3.hasLoaded(item) || inject.checkSupportFontFamily(item)) {
        return item;
      }
    }

    return inject.defaultFontFamily;
  }

  function calRelativePercent(n, parent, k) {
    n *= 0.01;

    while (parent) {
      var style = parent.currentStyle[k];

      if (style.u === AUTO$7) {
        if (k === WIDTH$8) {
          parent = parent.domParent;
        } else {
          break;
        }
      } else if (style.u === PX$8) {
        return n * style.v;
      } else if (style.u === PERCENT$7) {
        n *= style.v * 0.01;
        parent = parent.domParent;
      } else if (style.u === REM$7) {
        return n * style.v * parent.root.computedStyle[FONT_SIZE$8];
      } else if (style.u === VW$7) {
        return n * style.v * parent.root.width * 0.01;
      } else if (style.u === VH$7) {
        return n * style.v * parent.root.height * 0.01;
      } else if (style.u === VMAX$7) {
        return n * style.v * Math.max(parent.root.width, parent.root.height) * 0.01;
      } else if (style.u === VMIN$7) {
        return n * style.v * Math.min(parent.root.width, parent.root.height) * 0.01;
      }
    }

    return n;
  }

  function calRelative$1(currentStyle, k, v, parent, isWidth) {
    if (v.u === AUTO$7) {
      v = 0;
    } else if ([PX$8, NUMBER$4].indexOf(v.u) > -1) {
      v = v.v;
    } else if (v.u === PERCENT$7) {
      if (isWidth) {
        v = calRelativePercent(v.v, parent, WIDTH$8);
      } else {
        v = calRelativePercent(v.v, parent, HEIGHT$8);
      }
    } else if (v.u === REM$7) {
      v = v.v * parent.root.computedStyle[FONT_SIZE$8];
    } else if (v.u === VW$7) {
      v = v.v * parent.root.width * 0.01;
    } else if (v.u === VH$7) {
      v = v.v * parent.root.height * 0.01;
    } else if (v.u === VMAX$7) {
      v = v.v * Math.max(parent.root.width, parent.root.height) * 0.01;
    } else if (v.u === VMIN$7) {
      v = v.v * Math.min(parent.root.width, parent.root.height) * 0.01;
    }

    return v;
  }

  function isRelativeOrAbsolute$2(node) {
    var position = node.currentStyle[POSITION$5];
    return position === 'relative' || position === 'absolute';
  }

  function equalStyle$2(k, a, b, target) {
    if (!a || !b) {
      return a === b;
    }

    if (k === TRANSFORM$6) {
      if (a.length !== b.length) {
        return false;
      }

      for (var i = 0, len = a.length; i < len; i++) {
        var oa = a[i];
        var ob = b[i];

        if (oa.k !== ob.k) {
          return false;
        }

        var av = oa.v,
            bv = ob.v;

        if (oa.k === MATRIX$4) {
          if (!equalArr$1(av, bv)) {
            return false;
          }
        } else if (av.u !== bv.u || av.v !== bv.v) {
          return false;
        }
      }

      return true;
    }

    if (k === ROTATE_3D$4) {
      return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3].v === b[3].v && a[3].u === b[3].u;
    }

    if (k === FILTER$6) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i = 0, _len = a.length; _i < _len; _i++) {
        var _oa = a[_i];
        var _ob = b[_i];

        if (_oa.k !== _ob.k) {
          return false;
        }

        var _av = _oa.v,
            _bv = _ob.v;

        if (_oa.k === 'dropShadow' || _oa.k === 'drop-shadow') {
          if (_av.length !== _bv.length) {
            return false;
          }

          for (var j = 0; j < 4; j++) {
            var avj = _av[j],
                bvj = _bv[j];

            if (avj.u !== bvj.u || avj.v !== bvj.v) {
              return false;
            }
          }
        } else if (_av.u !== _bv.u || _av.v !== _bv.v) {
          return false;
        }
      }

      return true;
    }

    if (k === TRANSFORM_ORIGIN$5 || k === PERSPECTIVE_ORIGIN$4 || isRadiusKey$1(k)) {
      return a[0].v === b[0].v && a[0].u === b[0].u && a[1].v === b[1].v && a[1].u === b[1].u;
    }

    if (k === BACKGROUND_POSITION_X$3 || k === BACKGROUND_POSITION_Y$3 || k === STROKE_WIDTH$8) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i2 = 0, _len2 = a.length; _i2 < _len2; _i2++) {
        var aa = a[_i2],
            bb = b[_i2];

        if (aa.v !== bb.v || aa.u !== bb.u || aa.v !== bb.v || aa.u !== bb.u) {
          return false;
        }
      }

      return true;
    }

    if (k === BOX_SHADOW$2) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i3 = 0, _len3 = a.length; _i3 < _len3; _i3++) {
        var _aa = a[_i3],
            _bb = b[_i3];

        if ((!_aa || !_bb) && _aa !== _bb) {
          return false;
        }

        for (var _j = 0; _j < 4; _j++) {
          if (_aa[_j].v !== _bb[_j].v || _aa[_j].u !== _bb[_j].u) {
            return false;
          }
        }

        for (var _j2 = 0; _j2 < 4; _j2++) {
          if (_aa[4][_j2] !== _bb[4][_j2]) {
            return false;
          }
        }

        if (_aa[5] !== _bb[5]) {
          return false;
        }
      }

      return true;
    }

    if (k === BACKGROUND_SIZE$2 || k === BACKGROUND_POSITION_X$3 || k === BACKGROUND_POSITION_Y$3) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i4 = 0, _len4 = a.length; _i4 < _len4; _i4++) {
        var _aa2 = a[_i4],
            _bb2 = b[_i4];

        if (_aa2[0].v !== _bb2[0].v || _aa2[0].u !== _bb2[0].u || _aa2[1].v !== _bb2[1].v || _aa2[1].u !== _bb2[1].u) {
          return false;
        }
      }

      return true;
    } // if(k === OPACITY || k === Z_INDEX) {} 原始数字无需判断


    if (isLengthKey$1(k) || isExpandKey$1(k)) {
      return a.v === b.v && a.u === b.u;
    }

    if (isGradientKey$1(k)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var _i5 = 0, _len5 = a.length; _i5 < _len5; _i5++) {
        var ai = a[_i5],
            bi = b[_i5];

        if (ai.u !== bi.u) {
          return false;
        }

        var _av2 = ai.v,
            _bv2 = bi.v;

        if (ai.u === GRADIENT$3) {
          if (_av2.k !== _bv2.k || _av2.d !== _bv2.d || _av2.s !== _bv2.s || _av2.z !== _bv2.z) {
            return false;
          }

          if (_av2.k === 'linear') {
            var ad = _av2.d,
                bd = _bv2.d;
            var isArrayD1 = Array.isArray(ad);
            var isArrayD2 = Array.isArray(bd);

            if (isArrayD1 !== isArrayD2) {
              return false;
            }

            if (isArrayD1) {
              if (ad[0] !== bd[0] || ad[1] !== bd[1] || ad[2] !== bd[2] || ad[3] !== bd[3]) {
                return false;
              }
            } else if (ad !== bd) {
              return false;
            }
          } else if (_av2.k === 'conic' && _av2.d !== _bv2.d) {
            return false;
          }

          if (_av2.k === 'radial' || _av2.k === 'conic') {
            var ap = _av2.p,
                bp = _bv2.p;

            if (ap[0].u !== bp[0].u || ap[0].v !== bp[0].v || ap[1].u !== bp[1].u || ap[1].v !== bp[1].v) {
              return false;
            }
          }

          for (var _j3 = 0; _j3 < 2; _j3++) {
            var aj = _av2.v[_j3],
                bj = _bv2.v[_j3];
            var ac = aj[0],
                bc = bj[0];

            if (ac[0] !== bc[0] || ac[1] !== bc[1] || ac[2] !== bc[2] || ac[3] !== bc[3]) {
              return false;
            }

            if (aj[1] && bj[1]) {
              if (aj[1].u !== bj[1].u || aj[1].v !== bj[1].v) {
                return false;
              }
            } else if (aj[1] || bj[1]) {
              return false;
            }
          }
        } else if (ai.u === RGBA$3) {
          if (!equalArr$1(_av2, _bv2)) {
            return false;
          }
        } else if (_av2 !== _bv2) {
          return false;
        }
      }

      return true;
    }

    if (isColorKey$1(k)) {
      if (a.u !== b.u) {
        return false;
      }

      if (a.u === GRADIENT$3) ; else if (a.u === RGBA$3) {
        return equalArr$1(a.v, b.v);
      }
    } // multi都是纯值数组，equalArr本身即递归，非multi根据类型判断


    if (isGeom$2(target.tagName, k) && (target.isMulti || Array.isArray(a) && Array.isArray(b))) {
      return equal(a, b);
    }

    return a === b;
  }

  function cloneStyle$1(style, keys) {
    if (!keys) {
      keys = Object.keys(style).map(function (i) {
        if (!GEOM$2.hasOwnProperty(i)) {
          i = parseInt(i);
        }

        return i;
      });
    }

    var res = {};

    for (var i = 0, len = keys.length; i < len; i++) {
      var k = keys[i];
      var v = style[k];

      if (k === TRANSFORM$6) {
        if (v) {
          var _len6 = v.length;
          var n = new Array(_len6);

          for (var _i6 = 0; _i6 < _len6; _i6++) {
            var o = v[_i6];

            if (o.k === MATRIX$4) {
              n[_i6] = {
                k: o.k,
                v: o.v.slice(0)
              };
            } else {
              n[_i6] = {
                k: o.k,
                v: {
                  v: o.v.v,
                  u: o.v.u
                }
              };
            }
          }

          res[k] = n;
        }
      } else if (k === ROTATE_3D$4) {
        res[k] = [v[0], v[1], v[2], {
          v: v[3].v,
          u: v[3].u
        }];
      } else if (k === FILTER$6) {
        if (v) {
          var _len7 = v.length;

          var _n = new Array(_len7);

          for (var _i7 = 0; _i7 < _len7; _i7++) {
            var _o = v[_i7];
            var _k4 = _o.k,
                vv = _o.v;

            if (_k4 === 'dropShadow') {
              var arr = new Array(5);
              _n[_i7] = {
                k: _k4,
                v: arr
              };

              for (var j = 0; j < 4; j++) {
                var temp = vv[j];
                arr[j] = {
                  v: temp.v,
                  u: temp.u
                };
              }

              arr[4] = vv[4].slice(0);
            } else {
              _n[_i7] = {
                k: _k4,
                v: {
                  v: vv.v,
                  u: vv.u
                }
              };
            }
          }

          res[k] = _n;
        }
      } else if (k === TRANSFORM_ORIGIN$5 || k === PERSPECTIVE_ORIGIN$4 || isRadiusKey$1(k)) {
        if (v) {
          var _n2 = new Array(2);

          for (var _i8 = 0; _i8 < 2; _i8++) {
            var _o2 = v[_i8];
            _n2[_i8] = {
              v: _o2.v,
              u: _o2.u
            };
          }

          res[k] = _n2;
        }
      } else if (k === BACKGROUND_POSITION_X$3 || k === BACKGROUND_POSITION_Y$3 || k === STROKE_WIDTH$8) {
        res[k] = v.map(function (item) {
          return {
            v: item.v,
            u: item.u
          };
        });
      } else if (k === BOX_SHADOW$2) {
        if (v) {
          v = v.map(function (item) {
            var n = new Array(6);

            for (var _i9 = 0; _i9 < 4; _i9++) {
              var _o3 = item[_i9];
              n[_i9] = {
                v: _o3.v,
                u: _o3.u
              }; // x/y/blur/spread
            }

            n[4] = item[4].slice(0); //rgba

            n[5] = item[5]; // outset/inset

            return n;
          });
          res[k] = v;
        }
      } else if (k === BACKGROUND_SIZE$2) {
        if (v) {
          res[k] = v.map(function (item) {
            return [{
              v: item[0].v,
              u: item[0].u
            }, {
              v: item[1].v,
              u: item[1].u
            }];
          });
        }
      } else if (k === OPACITY$6 || k === Z_INDEX$5) {
        res[k] = v;
      } else if (k === TRANSLATE_PATH$1) {
        if (v) {
          res[k] = v.map(function (item) {
            return {
              v: item.v,
              u: item.u
            };
          });
        }
      } else if (isLengthKey$1(k) || isExpandKey$1(k)) {
        res[k] = {
          v: v.v,
          u: v.u
        };
      } // 渐变特殊处理
      else if (isGradientKey$1(k)) {
        res[k] = v.map(function (item) {
          if (!item) {
            return null;
          }

          if (item.u === GRADIENT$3) {
            return {
              v: util.clone(item.v),
              u: GRADIENT$3
            };
          } // 颜色
          else if (item.u === RGBA$3) {
            return {
              v: item.v.slice(0),
              u: RGBA$3
            };
          } // string和none
          else {
            return {
              v: item.v,
              u: item.u
            };
          }
        });
      } else if (isColorKey$1(k)) {
        // 特殊增加支持有gradient的先判断，仅color和textStrokeColor支持
        if (v.u === GRADIENT$3) {
          res[k] = {
            v: util.clone(v.v),
            u: GRADIENT$3
          };
        } else if (v.u === RGBA$3) {
          res[k] = {
            v: v.v.slice(0),
            u: RGBA$3
          };
        } // inherit
        else {
          res[k] = {
            u: INHERIT$3
          };
        }
      } // geom自定义属性
      else if (GEOM$2.hasOwnProperty(k)) {
        res[k] = util.clone(v);
      } // position等直接值类型赋值
      else {
        res[k] = v;
      }
    }

    return res;
  }

  function spreadBoxShadow$1(bbox, boxShadow) {
    var _bbox = _slicedToArray(bbox, 4),
        x1 = _bbox[0],
        y1 = _bbox[1],
        x2 = _bbox[2],
        y2 = _bbox[3];

    if (Array.isArray(boxShadow)) {
      var xl = 0,
          yt = 0,
          xr = 0,
          yb = 0;
      boxShadow.forEach(function (item) {
        var _item2 = _slicedToArray(item, 6),
            x = _item2[0],
            y = _item2[1],
            sigma = _item2[2],
            spread = _item2[3],
            color = _item2[4],
            inset = _item2[5];

        if (inset !== 'inset' && color[3] > 0) {
          var d = blur.outerSize(sigma);
          d += spread;
          xl = Math.min(xl, x - d);
          yt = Math.min(yt, x - d);
          xr = Math.max(xr, x + d);
          yb = Math.max(yb, y + d);
        }
      });
      x1 += xl;
      y1 += yt;
      x2 += xr;
      y2 += yb;
    }

    return [x1, y1, x2, y2];
  }

  function spreadFilter$2(bbox, filter) {
    var _bbox2 = _slicedToArray(bbox, 4),
        x1 = _bbox2[0],
        y1 = _bbox2[1],
        x2 = _bbox2[2],
        y2 = _bbox2[3]; // filter对整体有影响，且filter子项可以先后多次重复出现，上面计算完后，依次处理


    if (Array.isArray(filter)) {
      filter.forEach(function (item) {
        var k = item.k,
            v = item.v;

        if (k === 'blur' && v > 0) {
          var d = blur.kernelSize(v);
          var spread = blur.outerSizeByD(d);

          if (spread) {
            x1 -= spread;
            y1 -= spread;
            x2 += spread;
            y2 += spread;
          }
        } else if (k === 'dropShadow') {
          var _d = blur.kernelSize(v[2]);

          var _spread = blur.outerSizeByD(_d); // x/y/blur，3个一起影响，要考虑正负号，spread一定为非负


          if (v[0] || v[1] || _spread) {
            if (v[0] <= 0 || v[0] > 0 && v[0] < _spread) {
              x1 += v[0] - _spread;
            }

            if (v[1] <= 0 || v[1] > 0 && v[1] < _spread) {
              y1 += v[1] - _spread;
            }

            if (v[0] < 0 && -v[0] < _spread || v[0] >= 0) {
              x2 += v[0] + _spread;
            }

            if (v[1] < 0 && -v[1] < _spread || v[1] >= 0) {
              y2 += v[1] + _spread;
            }
          }
        }
      });
    }

    return [x1, y1, x2, y2];
  }

  var css = {
    normalize: normalize$1,
    setFontStyle: setFontStyle,
    getBaseline: getBaseline$1,
    getVerticalBaseline: getVerticalBaseline$1,
    calRelative: calRelative$1,
    equalStyle: equalStyle$2,
    isRelativeOrAbsolute: isRelativeOrAbsolute$2,
    cloneStyle: cloneStyle$1,
    calNormalLineHeight: calNormalLineHeight$1,
    calFontFamily: calFontFamily$1,
    spreadBoxShadow: spreadBoxShadow$1,
    spreadFilter: spreadFilter$2
  };

  function calDeg(x1, y1, x2, y2) {
    var dx = x2 - x1;
    var dy = y2 - y1;
    var atan = Math.atan(Math.abs(dy) / Math.abs(dx)); // 2象限

    if (dx < 0 && dy >= 0) {
      return Math.PI - atan;
    } // 3象限


    if (dx < 0 && dy < 0) {
      return atan - Math.PI;
    } // 1象限


    if (dx >= 0 && dy >= 0) {
      return atan;
    } // 4象限，顺时针正好


    return -atan;
  }

  function rotate(theta) {
    var sin = Math.sin(theta);
    var cos = Math.cos(theta);
    var t = mx.identity();
    t[0] = t[5] = cos;
    t[1] = sin;
    t[4] = -sin;
    return t;
  }
  /**
   * 确保3个点中，a点在三角形左上方，b/c在右方，同时ab到ac要顺时针旋转
   * @param points
   */


  function pointIndex(points) {
    var _points = _slicedToArray(points, 6),
        x1 = _points[0],
        y1 = _points[1],
        x2 = _points[2],
        y2 = _points[3],
        x3 = _points[4],
        y3 = _points[5];

    var index = [0, 1, 2]; // 将a点放入最左

    if (x2 < x1 && x2 < x3) {
      var _ref = [x2, y2, x1, y1];
      x1 = _ref[0];
      y1 = _ref[1];
      x2 = _ref[2];
      y2 = _ref[3];
      index[0] = 1;
      index[1] = 0;
    } else if (x3 < x2 && x3 < x1) {
      var _ref2 = [x3, y3, x1, y1];
      x1 = _ref2[0];
      y1 = _ref2[1];
      x3 = _ref2[2];
      y3 = _ref2[3];
      index[0] = 2;
      index[2] = 0;
    } // 有可能出现2个并列的情况，判断取上面那个


    if (x1 === x2) {
      if (y1 > y2) {
        var _ref3 = [x2, y2, x1, y1];
        x1 = _ref3[0];
        y1 = _ref3[1];
        x2 = _ref3[2];
        y2 = _ref3[3];
        var t = index[0];
        index[0] = index[1];
        index[1] = t;
      }
    } else if (x1 === x3) {
      if (y1 > y3) {
        var _ref4 = [x3, y3, x1, y1];
        x1 = _ref4[0];
        y1 = _ref4[1];
        x3 = _ref4[2];
        y3 = _ref4[3];
        var _t = index[0];
        index[0] = index[2];
        index[2] = _t;
      }
    } // ab到ac要顺时针旋转，即2个向量夹角为正，用向量叉乘判断正负


    var cross = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);

    if (cross < 0) {
      var _ref5 = [x3, y3, x2, y2];
      x2 = _ref5[0];
      y2 = _ref5[1];
      x3 = _ref5[2];
      y3 = _ref5[3];
      var _t2 = index[1];
      index[1] = index[2];
      index[2] = _t2;
    }

    return [x1, y1, x2, y2, x3, y3, index];
  }
  /**
   * 第2个点根据第一个点的交换顺序交换
   * @param points
   * @param index
   * @returns {[]}
   */


  function pointByIndex(points, index) {
    var res = [];

    for (var i = 0, len = index.length; i < len; i++) {
      var j = index[i];
      res.push(points[j * 2]);
      res.push(points[j * 2 + 1]);
    }

    return res;
  }
  /**
   * 确保3个点中，a点在三角形左上方，b/c在右方，同时ab到ac要顺时针旋转
   * @param source 源3个点
   * @param target 目标3个点
   * @returns 交换顺序后的点坐标
   */


  function exchangeOrder(source, target) {
    var _pointIndex = pointIndex(source),
        _pointIndex2 = _slicedToArray(_pointIndex, 7),
        sx1 = _pointIndex2[0],
        sy1 = _pointIndex2[1],
        sx2 = _pointIndex2[2],
        sy2 = _pointIndex2[3],
        sx3 = _pointIndex2[4],
        sy3 = _pointIndex2[5],
        index = _pointIndex2[6];

    var _pointByIndex = pointByIndex(target, index),
        _pointByIndex2 = _slicedToArray(_pointByIndex, 6),
        tx1 = _pointByIndex2[0],
        ty1 = _pointByIndex2[1],
        tx2 = _pointByIndex2[2],
        ty2 = _pointByIndex2[3],
        tx3 = _pointByIndex2[4],
        ty3 = _pointByIndex2[5];

    return [[sx1, sy1, sx2, sy2, sx3, sy3], [tx1, ty1, tx2, ty2, tx3, ty3]];
  }
  /**
   * 存在一种情况，变换结果使得三角形镜像相反了，即顶点a越过bc线，判断是否溢出
   * @param source
   * @param target
   * @returns {boolean}是否溢出
   */


  function isOverflow(source, target) {
    var _source = _slicedToArray(source, 6),
        sx1 = _source[0],
        sy1 = _source[1],
        sx2 = _source[2],
        sy2 = _source[3],
        sx3 = _source[4],
        sy3 = _source[5];

    var _target = _slicedToArray(target, 6),
        tx1 = _target[0],
        ty1 = _target[1],
        tx2 = _target[2],
        ty2 = _target[3],
        tx3 = _target[4],
        ty3 = _target[5];

    var cross1 = (sx2 - sx1) * (sy3 - sy1) - (sx3 - sx1) * (sy2 - sy1);
    var cross2 = (tx2 - tx1) * (ty3 - ty1) - (tx3 - tx1) * (ty2 - ty1);
    return cross1 > 0 && cross2 < 0 || cross1 < 0 && cross2 > 0;
  }

  function transform$1(source, target) {
    var _source2 = _slicedToArray(source, 6),
        sx1 = _source2[0],
        sy1 = _source2[1],
        sx2 = _source2[2],
        sy2 = _source2[3],
        sx3 = _source2[4],
        sy3 = _source2[5];

    var _target2 = _slicedToArray(target, 6),
        tx1 = _target2[0],
        ty1 = _target2[1],
        tx2 = _target2[2],
        ty2 = _target2[3],
        tx3 = _target2[4],
        ty3 = _target2[5]; // 记录翻转


    var overflow = isOverflow(source, target); // 第0步，将源三角第1个a点移到原点

    var m = mx.identity();
    m[12] = -sx1;
    m[13] = -sy1;
    var t; // 第1步，以第1条边ab为基准，将其贴合x轴上，为后续倾斜不干扰做准备

    var theta = calDeg(sx1, sy1, sx2, sy2);

    if (theta !== 0) {
      t = rotate(-theta);
      m = mx.multiply(t, m);
    } // 第2步，以第1条边AB为基准，缩放x轴ab至目标相同长度，可与4步合并


    var ls = geom$1.pointsDistance(sx1, sy1, sx2, sy2);
    var lt = geom$1.pointsDistance(tx1, ty1, tx2, ty2); // if(ls !== lt) {
    // let scale = lt / ls;
    // t = matrix.identity();
    // t[0] = scale;
    // m = matrix.multiply(t, m);
    // }
    // 第3步，缩放y，先将目标三角形旋转到x轴平行，再变换坐标计算

    var n = mx.identity();
    n[12] = -tx1;
    n[13] = -ty1;
    theta = calDeg(tx1, ty1, tx2, ty2); // 记录下这个旋转角度，后面源三角形要反向旋转

    var alpha = theta;

    if (theta !== 0) {
      t = rotate(-theta);
      n = mx.multiply(t, n);
    } // 目标三角反向旋转至x轴后的坐标
    // 源三角目前的第3点坐标y值即为长度，因为a点在原点0无需减去


    var ls2 = Math.abs(mx.calPoint([sx3, sy3], m)[1]);
    var lt2 = Math.abs(mx.calPoint([tx3, ty3], n)[1]); // 缩放y
    // if(ls2 !== lt2) {
    // let scale = lt / ls;
    // t = matrix.identity();
    // t[3] = scale;
    // m = matrix.multiply(t, m);
    // }

    if (ls !== lt || ls2 !== lt2) {
      t = mx.identity();

      if (ls !== lt) {
        t[0] = lt / ls;
      }

      if (ls2 !== lt2) {
        t[5] = lt2 / ls2;
      }

      m = mx.multiply(t, m);
    } // 第4步，x轴倾斜，用余弦定理求目前a和A的夹角


    n = m;

    var _matrix$calPoint = mx.calPoint([sx1, sy1], n),
        _matrix$calPoint2 = _slicedToArray(_matrix$calPoint, 2),
        ax1 = _matrix$calPoint2[0],
        ay1 = _matrix$calPoint2[1];

    var _matrix$calPoint3 = mx.calPoint([sx2, sy2], n),
        _matrix$calPoint4 = _slicedToArray(_matrix$calPoint3, 2),
        ax2 = _matrix$calPoint4[0],
        ay2 = _matrix$calPoint4[1];

    var _matrix$calPoint5 = mx.calPoint([sx3, sy3], n),
        _matrix$calPoint6 = _slicedToArray(_matrix$calPoint5, 2),
        ax3 = _matrix$calPoint6[0],
        ay3 = _matrix$calPoint6[1];

    var ab = geom$1.pointsDistance(ax1, ay1, ax2, ay2);
    var ac = geom$1.pointsDistance(ax1, ay1, ax3, ay3);
    var bc = geom$1.pointsDistance(ax3, ay3, ax2, ay2);
    var AB = geom$1.pointsDistance(tx1, ty1, tx2, ty2);
    var AC = geom$1.pointsDistance(tx1, ty1, tx3, ty3);
    var BC = geom$1.pointsDistance(tx3, ty3, tx2, ty2);
    var a = geom$1.angleBySide(bc, ab, ac);
    var A = geom$1.angleBySide(BC, AB, AC); // 先至90°，再旋转至目标角，可以合并成tan相加，不知道为什么不能直接tan倾斜差值角度

    if (a !== A) {
      t = mx.identity();
      t[4] = Math.tan(a - Math.PI * 0.5) + Math.tan(Math.PI * 0.5 - A);
      m = mx.multiply(t, m);
    } // 发生翻转时特殊处理按x轴垂直翻转


    if (overflow) {
      m[1] = -m[1];
      m[5] = -m[5];
      m[13] = -m[13];
    } // 第5步，再次旋转，角度为目标旋转到x轴的负值，可与下步合并


    if (alpha !== 0) {
      t = rotate(alpha); // m = matrix.multiply(t, m);
    } else {
      t = mx.identity();
    } // 第6步，移动第一个点的差值
    // t = matrix.identity();


    t[12] = tx1;
    t[13] = ty1;
    return mx.multiply(t, m);
  }

  var tar = {
    exchangeOrder: exchangeOrder,
    isOverflow: isOverflow,
    transform: transform$1
  };

  var TOLERANCE$1 = 1e-6;
  /**
   * 计算线性方程的根
   * y = ax + b
   * root = -b / a
   * @param {Array<Number>} coefs 系数 [b, a] 本文件代码中的系数数组都是从阶次由低到高排列
   */

  function getLinearRoot(coefs) {
    var result = [];
    var a = coefs[1];

    if (a !== 0) {
      result.push(-coefs[0] / a);
    }

    return result;
  }
  /**
   * 计算二次方程的根，一元二次方程求根公式
   * y = ax^2 + bx + c
   * root = (-b ± sqrt(b^2 - 4ac)) / 2a
   * @param {Array<Number>} coefs 系数，系数 [c, b, a]
   */


  function getQuadraticRoots(coefs) {
    var results = [];
    var a = coefs[2];
    var b = coefs[1] / a;
    var c = coefs[0] / a;
    var d = b * b - 4 * c;

    if (d > 0) {
      var e = Math.sqrt(d);
      results.push(0.5 * (-b + e));
      results.push(0.5 * (-b - e));
    } else if (d === 0) {
      // 两个相同的根，只要返回一个
      results.push(0.5 * -b);
    }

    return results;
  }
  /**
   * 计算一元三次方程的根
   * y = ax^3 + bx^2 + cx + d
   * 求根公式参见: https://baike.baidu.com/item/%E4%B8%80%E5%85%83%E4%B8%89%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E5%85%AC%E5%BC%8F/10721952?fr=aladdin
   * @param {Array<Number>} coefs 系数
   */


  function getCubicRoots(coefs) {
    var results = [];
    var c3 = coefs[3];
    var c2 = coefs[2] / c3;
    var c1 = coefs[1] / c3;
    var c0 = coefs[0] / c3;
    var a = (3 * c1 - c2 * c2) / 3;
    var b = (2 * c2 * c2 * c2 - 9 * c1 * c2 + 27 * c0) / 27;
    var offset = c2 / 3;
    var discrim = b * b / 4 + a * a * a / 27;
    var halfB = b / 2;

    if (Math.abs(discrim) <= TOLERANCE$1) {
      discrim = 0;
    }

    if (discrim > 0) {
      var e = Math.sqrt(discrim);
      var tmp;
      var root;
      tmp = -halfB + e;
      if (tmp >= 0) root = Math.pow(tmp, 1 / 3);else root = -Math.pow(-tmp, 1 / 3);
      tmp = -halfB - e;
      if (tmp >= 0) root += Math.pow(tmp, 1 / 3);else root -= Math.pow(-tmp, 1 / 3);
      results.push(root - offset);
    } else if (discrim < 0) {
      var distance = Math.sqrt(-a / 3);
      var angle = Math.atan2(Math.sqrt(-discrim), -halfB) / 3;
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var sqrt3 = Math.sqrt(3);
      results.push(2 * distance * cos - offset);
      results.push(-distance * (cos + sqrt3 * sin) - offset);
      results.push(-distance * (cos - sqrt3 * sin) - offset);
    } else {
      var _tmp;

      if (halfB >= 0) _tmp = -Math.pow(halfB, 1 / 3);else _tmp = Math.pow(-halfB, 1 / 3);
      results.push(2 * _tmp - offset); // really should return next root twice, but we return only one

      results.push(-_tmp - offset);
    }

    return results;
  }
  /**
   * 计算一元四次方程的根
   * 求根公式: https://baike.baidu.com/item/%E4%B8%80%E5%85%83%E4%B8%89%E6%AC%A1%E6%96%B9%E7%A8%8B%E6%B1%82%E6%A0%B9%E5%85%AC%E5%BC%8F/10721952?fr=aladdin
   * @param {Array<Number>} coefs 系数
   */


  function getQuarticRoots(coefs) {
    var results = [];
    var c4 = coefs[4];
    var c3 = coefs[3] / c4;
    var c2 = coefs[2] / c4;
    var c1 = coefs[1] / c4;
    var c0 = coefs[0] / c4;
    var resolveRoots = getCubicRoots([1, -c2, c3 * c1 - 4 * c0, -c3 * c3 * c0 + 4 * c2 * c0 - c1 * c1].reverse());
    var y = resolveRoots[0];
    var discrim = c3 * c3 / 4 - c2 + y;
    if (Math.abs(discrim) <= TOLERANCE$1) discrim = 0;

    if (discrim > 0) {
      var e = Math.sqrt(discrim);
      var t1 = 3 * c3 * c3 / 4 - e * e - 2 * c2;
      var t2 = (4 * c3 * c2 - 8 * c1 - c3 * c3 * c3) / (4 * e);
      var plus = t1 + t2;
      var minus = t1 - t2;
      if (Math.abs(plus) <= TOLERANCE$1) plus = 0;
      if (Math.abs(minus) <= TOLERANCE$1) minus = 0;

      if (plus >= 0) {
        var f = Math.sqrt(plus);
        results.push(-c3 / 4 + (e + f) / 2);
        results.push(-c3 / 4 + (e - f) / 2);
      }

      if (minus >= 0) {
        var _f = Math.sqrt(minus);

        results.push(-c3 / 4 + (_f - e) / 2);
        results.push(-c3 / 4 - (_f + e) / 2);
      }
    } else if (discrim < 0) ; else {
      var _t = y * y - 4 * c0;

      if (_t >= -TOLERANCE$1) {
        if (_t < 0) _t = 0;
        _t = 2 * Math.sqrt(_t);

        var _t2 = 3 * c3 * c3 / 4 - 2 * c2;

        if (_t2 + _t >= TOLERANCE$1) {
          var d = Math.sqrt(_t2 + _t);
          results.push(-c3 / 4 + d / 2);
          results.push(-c3 / 4 - d / 2);
        }

        if (_t2 - _t >= TOLERANCE$1) {
          var _d = Math.sqrt(_t2 - _t);

          results.push(-c3 / 4 + _d / 2);
          results.push(-c3 / 4 - _d / 2);
        }
      }
    }

    return results;
  }
  /**
   * 计算方程的根
   * @param {Array<Number>} coefs 系数按幂次方倒序
   */


  function getRoots$1(coefs) {
    var degree = coefs.length - 1;

    for (var i = degree; i >= 0; i--) {
      if (Math.abs(coefs[i]) < 1e-12) {
        degree--;
      } else {
        break;
      }
    }

    var result = [];

    switch (degree) {
      case 1:
        result = getLinearRoot(coefs);
        break;

      case 2:
        result = getQuadraticRoots(coefs);
        break;

      case 3:
        result = getCubicRoots(coefs);
        break;

      case 4:
        result = getQuarticRoots(coefs);
    }

    return result;
  }

  var equation = {
    getRoots: getRoots$1
  };

  /**
   * 二阶贝塞尔曲线范围框
   * @param x0
   * @param y0
   * @param x1
   * @param y1
   * @param x2
   * @param y2
   * @returns {number[]}
   * https://www.iquilezles.org/www/articles/bezierbbox/bezierbbox.htm
   */

  function bboxBezier2(x0, y0, x1, y1, x2, y2) {
    var minX = Math.min(x0, x2);
    var minY = Math.min(y0, y2);
    var maxX = Math.max(x0, x2);
    var maxY = Math.max(y0, y2); // 控制点位于边界内部时，边界就是范围框，否则计算导数获取极值

    if (x1 < minX || y1 < minY || x1 > maxX || y1 > maxY) {
      var tx = (x0 - x1) / (x0 - 2 * x1 + x2);

      if (tx < 0) {
        tx = 0;
      } else if (tx > 1) {
        tx = 1;
      }

      var ty = (y0 - y1) / (y0 - 2 * y1 + y2);

      if (ty < 0) {
        ty = 0;
      } else if (ty > 1) {
        ty = 1;
      }

      var sx = 1 - tx;
      var sy = 1 - ty;
      var qx = sx * sx * x0 + 2 * sx * tx * x1 + tx * tx * x2;
      var qy = sy * sy * y0 + 2 * sy * ty * y1 + ty * ty * y2;
      minX = Math.min(minX, qx);
      minY = Math.min(minY, qy);
      maxX = Math.max(maxX, qx);
      maxY = Math.max(maxY, qy);
    }

    return [minX, minY, maxX, maxY];
  }
  /**
   * 同上三阶的
   */


  function bboxBezier3(x0, y0, x1, y1, x2, y2, x3, y3) {
    var minX = Math.min(x0, x3);
    var minY = Math.min(y0, y3);
    var maxX = Math.max(x0, x3);
    var maxY = Math.max(y0, y3);

    if (x1 < minX || y1 < minY || x1 > maxX || y1 > maxY || x2 < minX || y2 < minY || x2 > maxX || y2 > maxY) {
      var cx = -x0 + x1;
      var cy = -y0 + y1;
      var bx = x0 - 2 * x1 + x2;
      var by = y0 - 2 * y1 + y2;
      var ax = -x0 + 3 * x1 - 3 * x2 + x3;
      var ay = -y0 + 3 * y1 - 3 * y2 + y3;
      var hx = bx * bx - ax * cx;
      var hy = by * by - ay * cy;

      if (hx > 0) {
        hx = Math.sqrt(hx);
        var t = (-bx - hx) / ax; // 2次项系数为0注意降级为一元一次方程

        if (ax && t > 0 && t < 1) {
          var s = 1 - t;
          var q = s * s * s * x0 + 3 * s * s * t * x1 + 3 * s * t * t * x2 + t * t * t * x3;
          minX = Math.min(minX, q);
          maxX = Math.max(maxX, q);
        }

        t = ax ? (-bx + hx) / ax : -cx * 0.5 / bx;

        if (t > 0 && t < 1) {
          var _s = 1 - t;

          var _q = _s * _s * _s * x0 + 3 * _s * _s * t * x1 + 3 * _s * t * t * x2 + t * t * t * x3;

          minX = Math.min(minX, _q);
          maxX = Math.max(maxX, _q);
        }
      }

      if (hy > 0) {
        hy = Math.sqrt(hy);

        var _t = (-by - hy) / ay;

        if (ay && _t > 0 && _t < 1) {
          var _s2 = 1 - _t;

          var _q2 = _s2 * _s2 * _s2 * y0 + 3 * _s2 * _s2 * _t * y1 + 3 * _s2 * _t * _t * y2 + _t * _t * _t * y3;

          minY = Math.min(minY, _q2);
          maxY = Math.max(maxY, _q2);
        }

        _t = ay ? (-by + hy) / ay : -cy * 0.5 / by;

        if (_t > 0 && _t < 1) {
          var _s3 = 1 - _t;

          var _q3 = _s3 * _s3 * _s3 * y0 + 3 * _s3 * _s3 * _t * y1 + 3 * _s3 * _t * _t * y2 + _t * _t * _t * y3;

          minY = Math.min(minY, _q3);
          maxY = Math.max(maxY, _q3);
        }
      }
    }

    return [minX, minY, maxX, maxY];
  }

  function bboxBezier(x0, y0, x1, y1, x2, y2, x3, y3) {
    var len = arguments.length;

    if (Array.isArray(x0)) {
      var l = x0.length;
      var arr = x0;

      var _arr$ = _slicedToArray(arr[0], 2);

      x0 = _arr$[0];
      y0 = _arr$[1];

      var _arr$2 = _slicedToArray(arr[1], 2);

      x1 = _arr$2[0];
      y1 = _arr$2[1];
      len = 4;

      if (l >= 3) {
        var _arr$3 = _slicedToArray(arr[2], 2);

        x2 = _arr$3[0];
        y2 = _arr$3[1];
        len = 6;
      }

      if (l >= 4) {
        var _arr$4 = _slicedToArray(arr[3], 2);

        x3 = _arr$4[0];
        y3 = _arr$4[1];
        len = 8;
      }
    }

    if (len === 4) {
      var a = Math.min(x0, x1);
      var b = Math.min(y0, y1);
      var c = Math.max(x0, x1);
      var d = Math.max(y0, y1);
      return [a, b, c, d];
    }

    if (len === 6) {
      return bboxBezier2(x0, y0, x1, y1, x2, y2);
    }

    if (len === 8) {
      return bboxBezier3(x0, y0, x1, y1, x2, y2, x3, y3);
    }
  }
  /**
   * 范数 or 模
   */


  function norm(v) {
    var order = v.length;
    var sum = v.reduce(function (a, b) {
      return Math.pow(a, order) + Math.pow(b, order);
    });
    return Math.pow(sum, 1 / order);
  } // https://zhuanlan.zhihu.com/p/130247362


  function simpson38(derivativeFunc, l, r) {
    var f = derivativeFunc;
    var middleL = (2 * l + r) / 3;
    var middleR = (l + 2 * r) / 3;
    return (f(l) + 3 * f(middleL) + 3 * f(middleR) + f(r)) * (r - l) / 8;
  }
  /**
   * bezier 曲线的长度
   * @param derivativeFunc 微分函数
   * @param l 左点
   * @param r 右点
   * @param eps 精度
   * @return {*} number
   */


  function adaptiveSimpson38(derivativeFunc, l, r) {
    var eps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.001;
    var f = derivativeFunc;
    var mid = (l + r) / 2;
    var st = simpson38(f, l, r);
    var sl = simpson38(f, l, mid);
    var sr = simpson38(f, mid, r);
    var ans = sl + sr - st;

    if (Math.abs(ans) <= 15 * eps) {
      return sl + sr + ans / 15;
    }

    return adaptiveSimpson38(f, l, mid, eps / 2) + adaptiveSimpson38(f, mid, r, eps / 2);
  }
  /**
   * bezier 曲线的长度
   * @param points 曲线的起止点 和 控制点
   * @param startT 计算长度的起点，满足 0 <= startT <= endT <= 1
   * @param endT 计算长度的终点
   * @return {*} number
   */


  function bezierLength(points) {
    var startT = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var endT = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    if (points.length === 6) {
      points = [[points[0], points[1]], [points[2], points[3]], [points[4], points[5]]];
    } else if (points.length === 8) {
      points = [[points[0], points[1]], [points[2], points[3]], [points[4], points[5]], [points[6], points[7]]];
    }

    if (points.length === 2) {
      var _points$ = _slicedToArray(points[0], 2),
          x1 = _points$[0],
          y1 = _points$[1],
          _points$2 = _slicedToArray(points[1], 2),
          x2 = _points$2[0],
          y2 = _points$2[1];

      return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }

    var derivativeFunc = function derivativeFunc(t) {
      return norm(at(t, points));
    };

    return adaptiveSimpson38(derivativeFunc, startT, endT);
  }
  /**
   * 3 阶 bezier 曲线的 order 阶导数在 t 位置时候的 (x, y) 的值
   */


  function at3(t, points) {
    var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    var _points = _slicedToArray(points, 4),
        p0 = _points[0],
        p1 = _points[1],
        p2 = _points[2],
        p3 = _points[3];

    var _p = _slicedToArray(p0, 2),
        x0 = _p[0],
        y0 = _p[1];

    var _p2 = _slicedToArray(p1, 2),
        x1 = _p2[0],
        y1 = _p2[1];

    var _p3 = _slicedToArray(p2, 2),
        x2 = _p3[0],
        y2 = _p3[1];

    var _p4 = _slicedToArray(p3, 2),
        x3 = _p4[0],
        y3 = _p4[1];

    var x = 0;
    var y = 0; // 3阶导数就是常数了，大于3阶的都是0

    if (order === 0) {
      x = Math.pow(1 - t, 3) * x0 + 3 * t * Math.pow(1 - t, 2) * x1 + 3 * (1 - t) * Math.pow(t, 2) * x2 + Math.pow(t, 3) * x3;
      y = Math.pow(1 - t, 3) * y0 + 3 * t * Math.pow(1 - t, 2) * y1 + 3 * (1 - t) * Math.pow(t, 2) * y2 + Math.pow(t, 3) * y3;
    } else if (order === 1) {
      x = 3 * ((1 - t) * (1 - t) * (x1 - x0) + 2 * (1 - t) * t * (x2 - x1) + t * t * (x3 - x2));
      y = 3 * ((1 - t) * (1 - t) * (y1 - y0) + 2 * (1 - t) * t * (y2 - y1) + t * t * (y3 - y2));
    } else if (order === 2) {
      x = 6 * (x2 - 2 * x1 + x0) * (1 - t) + 6 * (x3 - 2 * x2 + x1) * t;
      y = 6 * (y2 - 2 * y1 + y0) * (1 - t) + 6 * (y3 - 2 * y2 + y1) * t;
    } else if (order === 3) {
      x = 6 * (x3 - 3 * x2 + 3 * x1 - x0);
      y = 6 * (y3 - 3 * y2 + 3 * y1 - y0);
    }

    return [x, y];
  }
  /**
   * 2 阶 bezier 曲线的 order 阶导数在 t 位置时候的 (x, y) 的值
   */


  function at2(t, points) {
    var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    var _points2 = _slicedToArray(points, 3),
        p0 = _points2[0],
        p1 = _points2[1],
        p2 = _points2[2];

    var _p5 = _slicedToArray(p0, 2),
        x0 = _p5[0],
        y0 = _p5[1];

    var _p6 = _slicedToArray(p1, 2),
        x1 = _p6[0],
        y1 = _p6[1];

    var _p7 = _slicedToArray(p2, 2),
        x2 = _p7[0],
        y2 = _p7[1];

    var x = 0;
    var y = 0;

    if (order === 0) {
      x = Math.pow(1 - t, 2) * x0 + 2 * t * (1 - t) * x1 + Math.pow(t, 2) * x2;
      y = Math.pow(1 - t, 2) * y0 + 2 * t * (1 - t) * y1 + Math.pow(t, 2) * y2;
    } else if (order === 1) {
      x = 2 * (1 - t) * (x1 - x0) + 2 * t * (x2 - x1);
      y = 2 * (1 - t) * (y1 - y0) + 2 * t * (y2 - y1);
    } else if (order === 2) {
      x = 2 * (x2 - 2 * x1 + x0);
      y = 2 * (y2 - 2 * y1 + y0);
    }

    return [x, y];
  }

  function at(t, points) {
    var derivativeOrder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

    if (points.length === 4) {
      return at3(t, points, derivativeOrder);
    } else if (points.length === 3) {
      return at2(t, points, derivativeOrder);
    }
  }

  function pointAtBezier(points, percent, maxIteration, eps) {
    var length = bezierLength(points, 0, 1);
    return pointAtBezierWithLength(points, length, percent, maxIteration, eps);
  }

  function pointAtBezierWithLength(points, length) {
    var percent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var maxIteration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20;
    var eps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.001;

    var derivativeFunc = function derivativeFunc(t) {
      return norm(at(t, points));
    };

    var targetLen = length * percent;
    var approachLen = length;
    var approachT = percent;
    var preApproachT = approachT;

    for (var i = 0; i < maxIteration; i++) {
      approachLen = simpson38(derivativeFunc, 0, approachT);
      var d = approachLen - targetLen;

      if (Math.abs(d) < eps) {
        break;
      } // Newton 法


      var derivative1 = norm(at(approachT, points, 1)); // 1 阶导数

      var derivative2 = norm(at(approachT, points, 2)); // 2 阶导数

      var numerator = d * derivative1;
      var denominator = d * derivative2 + derivative1 * derivative1;
      approachT = approachT - numerator / denominator;

      if (Math.abs(approachT - preApproachT) < eps) {
        break;
      } else {
        preApproachT = approachT;
      }
    }

    return at(approachT, points, 0);
  }

  function sliceBezier(points, t) {
    var _points3 = _slicedToArray(points, 4),
        _points3$ = _slicedToArray(_points3[0], 2),
        x1 = _points3$[0],
        y1 = _points3$[1],
        _points3$2 = _slicedToArray(_points3[1], 2),
        x2 = _points3$2[0],
        y2 = _points3$2[1],
        _points3$3 = _slicedToArray(_points3[2], 2),
        x3 = _points3$3[0],
        y3 = _points3$3[1],
        p4 = _points3[3];

    var x12 = (x2 - x1) * t + x1;
    var y12 = (y2 - y1) * t + y1;
    var x23 = (x3 - x2) * t + x2;
    var y23 = (y3 - y2) * t + y2;
    var x123 = (x23 - x12) * t + x12;
    var y123 = (y23 - y12) * t + y12;

    if (points.length === 4) {
      var _p8 = _slicedToArray(p4, 2),
          x4 = _p8[0],
          y4 = _p8[1];

      var x34 = (x4 - x3) * t + x3;
      var y34 = (y4 - y3) * t + y3;
      var x234 = (x34 - x23) * t + x23;
      var y234 = (y34 - y23) * t + y23;
      var x1234 = (x234 - x123) * t + x123;
      var y1234 = (y234 - y123) * t + y123;
      return [[x1, y1], [x12, y12], [x123, y123], [x1234, y1234]];
    } else if (points.length === 3) {
      return [[x1, y1], [x12, y12], [x123, y123]];
    }
  }

  function sliceBezier2Both(points) {
    var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    start = Math.max(start, 0);
    end = Math.min(end, 1);

    if (start === 0 && end === 1) {
      return points;
    }

    if (end < 1) {
      points = sliceBezier(points, end);
    }

    if (start > 0) {
      if (end < 1) {
        start = start / end;
      }

      points = sliceBezier(points.slice(0).reverse(), 1 - start).reverse();
    }

    return points;
  }

  function pointAtByT(points) {
    var t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (points.length === 4) {
      return pointAtByT3(points, t);
    } else if (points.length === 3) {
      return pointAtByT2(points, t);
    }
  }

  function pointAtByT2(points, t) {
    var x = points[0][0] * (1 - t) * (1 - t) + 2 * points[1][0] * t * (1 - t) + points[2][0] * t * t;
    var y = points[0][1] * (1 - t) * (1 - t) + 2 * points[1][1] * t * (1 - t) + points[2][1] * t * t;
    return [x, y];
  }

  function pointAtByT3(points, t) {
    var x = points[0][0] * (1 - t) * (1 - t) * (1 - t) + 3 * points[1][0] * t * (1 - t) * (1 - t) + 3 * points[2][0] * t * t * (1 - t) + points[3][0] * t * t * t;
    var y = points[0][1] * (1 - t) * (1 - t) * (1 - t) + 3 * points[1][1] * t * (1 - t) * (1 - t) + 3 * points[2][1] * t * t * (1 - t) + points[3][1] * t * t * t;
    return [x, y];
  } // 已知曲线和上面一点获得t


  function getPointT(points, x, y) {
    if (points.length === 4) {
      return getPointT3(points, x, y);
    } else if (points.length === 3) {
      return getPointT2(points, x, y);
    }
  }

  function getPointT2(points, x, y) {
    // x/y都需要求，以免其中一个无解，过滤掉[0, 1]之外的
    var tx = equation.getRoots([points[0][0] - x, 2 * (points[1][0] - points[0][0]), points[2][0] + points[0][0] - 2 * points[1][0]]).filter(function (i) {
      return i >= 0 && i <= 1;
    });
    var ty = equation.getRoots([points[0][1] - y, 2 * (points[1][1] - points[0][1]), points[2][1] + points[0][1] - 2 * points[1][1]]).filter(function (i) {
      return i >= 0 && i <= 1;
    }); // 可能有多个解，x和y要匹配上，这里最多x和y各2个总共4个解

    var t = [];

    for (var i = 0, len = tx.length; i < len; i++) {
      var _x = tx[i];

      for (var j = 0, _len = ty.length; j < _len; j++) {
        var _y = ty[j];
        var diff = Math.abs(_x - _y); // 必须小于一定误差

        if (diff < 1e-10) {
          t.push({
            x: _x,
            y: _y,
            diff: diff
          });
        }
      }
    }

    t.sort(function (a, b) {
      return a.diff - b.diff;
    });

    if (t.length > 2) {
      t.splice(2);
    } // 取均数


    t = t.map(function (item) {
      return (item.x + item.y) * 0.5;
    });
    var res = [];
    t.forEach(function (t) {
      var xt = points[0][0] * Math.pow(1 - t, 2) + 2 * points[1][0] * t * (1 - t) + points[2][0] * t * t;
      var yt = points[0][1] * Math.pow(1 - t, 2) + 2 * points[1][1] * t * (1 - t) + points[2][1] * t * t; // 计算误差忽略

      if (Math.abs(xt - x) < 1e-10 && Math.abs(yt - y) < 1e-10) {
        res.push(t);
      }
    });
    return res;
  }

  function getPointT3(points, x, y) {
    var tx = equation.getRoots([points[0][0] - x, 3 * (points[1][0] - points[0][0]), 3 * (points[2][0] + points[0][0] - 2 * points[1][0]), points[3][0] - points[0][0] + 3 * points[1][0] - 3 * points[2][0]]).filter(function (i) {
      return i >= 0 && i <= 1;
    });
    var ty = equation.getRoots([points[0][1] - y, 3 * (points[1][1] - points[0][1]), 3 * (points[2][1] + points[0][1] - 2 * points[1][1]), points[3][1] - points[0][1] + 3 * points[1][1] - 3 * points[2][1]]).filter(function (i) {
      return i >= 0 && i <= 1;
    }); // 可能有多个解，x和y要匹配上，这里最多x和y各3个总共9个解

    var t = [];

    for (var i = 0, len = tx.length; i < len; i++) {
      var _x2 = tx[i];

      for (var j = 0, _len2 = ty.length; j < _len2; j++) {
        var _y2 = ty[j];
        var diff = Math.abs(_x2 - _y2); // 必须小于一定误差

        if (diff < 1e-10) {
          t.push({
            x: _x2,
            y: _y2,
            diff: diff
          });
        }
      }
    }

    t.sort(function (a, b) {
      return a.diff - b.diff;
    });

    if (t.length > 3) {
      t.splice(3);
    } // 取均数


    t = t.map(function (item) {
      return (item.x + item.y) * 0.5;
    });
    var res = [];
    t.forEach(function (t) {
      var xt = points[0][0] * Math.pow(1 - t, 3) + 3 * points[1][0] * t * Math.pow(1 - t, 2) + 3 * points[2][0] * t * t * (1 - t) + points[3][0] * Math.pow(t, 3);
      var yt = points[0][1] * Math.pow(1 - t, 3) + 3 * points[1][1] * t * Math.pow(1 - t, 2) + 3 * points[2][1] * t * t * (1 - t) + points[3][1] * Math.pow(t, 3); // 计算误差忽略

      if (Math.abs(xt - x) < 1e-10 && Math.abs(yt - y) < 1e-10) {
        res.push(t);
      }
    });
    return res;
  }

  function bezierSlope(points, t) {
    if (points.length === 2) {
      var _points$3 = _slicedToArray(points[0], 2),
          x1 = _points$3[0],
          y1 = _points$3[1];

      var _points$4 = _slicedToArray(points[1], 2),
          x2 = _points$4[0],
          y2 = _points$4[1];

      if (x1 === x2) {
        return Infinity;
      }

      return (y2 - y1) / (x2 - x1);
    }

    if (points.length === 3) {
      return bezier2Slope(points, t);
    }

    if (points.length === 4) {
      return bezier3Slope(points, t);
    }
  }

  function bezier2Slope(points, t) {
    var _points4 = _slicedToArray(points, 3),
        _points4$ = _slicedToArray(_points4[0], 2),
        x0 = _points4$[0],
        y0 = _points4$[1],
        _points4$2 = _slicedToArray(_points4[1], 2),
        x1 = _points4$2[0],
        y1 = _points4$2[1],
        _points4$3 = _slicedToArray(_points4[2], 2),
        x2 = _points4$3[0],
        y2 = _points4$3[1];

    var x = 2 * (x0 - 2 * x1 + x2) * t + 2 * x1 - 2 * x0;

    if (x === 0) {
      return Infinity;
    }

    return (2 * (y0 - 2 * y1 + y2) * t + 2 * y1 - 2 * y0) / x;
  }

  function bezier3Slope(points, t) {
    var _points5 = _slicedToArray(points, 4),
        _points5$ = _slicedToArray(_points5[0], 2),
        x0 = _points5$[0],
        y0 = _points5$[1],
        _points5$2 = _slicedToArray(_points5[1], 2),
        x1 = _points5$2[0],
        y1 = _points5$2[1],
        _points5$3 = _slicedToArray(_points5[2], 2),
        x2 = _points5$3[0],
        y2 = _points5$3[1],
        _points5$4 = _slicedToArray(_points5[3], 2),
        x3 = _points5$4[0],
        y3 = _points5$4[1];

    var x = 3 * (-x0 + 3 * x1 - 3 * x2 + x3) * t * t + 2 * (3 * x0 - 6 * x1 + 3 * x2) * t + 3 * x1 - 3 * x0;

    if (x === 0) {
      return Infinity;
    }

    return (3 * (-y0 + 3 * y1 - 3 * y2 + y3) * t * t + 2 * (3 * y0 - 6 * y1 + 3 * y2) * t + 3 * y1 - 3 * y0) / x;
  }

  var bezier$1 = {
    bboxBezier: bboxBezier,
    bezierLength: bezierLength,
    pointAtBezier: pointAtBezier,
    pointAtBezierWithLength: pointAtBezierWithLength,
    sliceBezier: sliceBezier,
    sliceBezier2Both: sliceBezier2Both,
    pointAtByT: pointAtByT,
    getPointT: getPointT,
    bezierSlope: bezierSlope
  };

  var getRoots = equation.getRoots; // 两个三次方程组的数值解.9阶的多项式方程,可以最多有9个实根(两个S形曲线的情况)
  // 两个三次方程组无法解析表示，只能数值计算
  // 参考：https://mat.polsl.pl/sjpam/zeszyty/z6/Silesian_J_Pure_Appl_Math_v6_i1_str_155-176.pdf

  var TOLERANCE = 1e-6;
  var ACCURACY = 6;
  /**
   * 获取求导之后的系数
   * @param coefs
   */

  function getDerivativeCoefs(coefs) {
    var derivative = [];

    for (var i = 1; i < coefs.length; i++) {
      derivative.push(i * coefs[i]);
    }

    return derivative;
  }
  /**
   * 评估函数
   * @param x
   * @param coefs
   * @return {number}
   */


  function evaluate(x, coefs) {
    var result = 0;

    for (var i = coefs.length - 1; i >= 0; i--) {
      result = result * x + coefs[i];
    }

    return result;
  }

  function bisection(min, max, coefs) {
    var minValue = evaluate(min, coefs);
    var maxValue = evaluate(max, coefs);
    var result;

    if (Math.abs(minValue) <= TOLERANCE) {
      result = min;
    } else if (Math.abs(maxValue) <= TOLERANCE) {
      result = max;
    } else if (minValue * maxValue <= 0) {
      var tmp1 = Math.log(max - min);
      var tmp2 = Math.LN10 * ACCURACY;
      var iters = Math.ceil((tmp1 + tmp2) / Math.LN2);

      for (var i = 0; i < iters; i++) {
        result = 0.5 * (min + max);
        var value = evaluate(result, coefs);

        if (Math.abs(value) <= TOLERANCE) {
          break;
        }

        if (value * minValue < 0) {
          max = result;
          maxValue = value;
        } else {
          min = result;
          minValue = value;
        }
      }
    }

    return result;
  }

  function getRootsInInterval(min, max, coefs) {
    // console.log('getRootsInInterval', coefs);
    var roots = [];
    var root;
    var degree = coefs.length - 1;

    if (degree === 1) {
      root = bisection(min, max, coefs);

      if (root != null) {
        roots.push(root);
      }
    } else {
      var derivativeCoefs = getDerivativeCoefs(coefs);
      var droots = getRootsInInterval(min, max, derivativeCoefs);

      if (droots.length > 0) {
        // find root on [min, droots[0]]
        root = bisection(min, droots[0], coefs);

        if (root != null) {
          roots.push(root);
        } // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2


        for (var i = 0; i <= droots.length - 2; i++) {
          root = bisection(droots[i], droots[i + 1], coefs);

          if (root != null) {
            roots.push(root);
          }
        } // find root on [droots[count-1],xmax]


        root = bisection(droots[droots.length - 1], max, coefs);

        if (root != null) {
          roots.push(root);
        }
      } else {
        // polynomial is monotone on [min,max], has at most one root
        root = bisection(min, max, coefs);

        if (root != null) {
          roots.push(root);
        }
      }
    }

    return roots;
  }
  /**
   * 二阶贝塞尔曲线 与 二阶贝塞尔曲线 交点
   * @return {[]}
   */


  function intersectBezier2Bezier2(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3) {
    var c12, c11, c10;
    var c22, c21, c20;
    var result = [];
    c12 = {
      x: ax1 - 2 * ax2 + ax3,
      y: ay1 - 2 * ay2 + ay3
    };
    c11 = {
      x: 2 * ax2 - 2 * ax1,
      y: 2 * ay2 - 2 * ay1
    };
    c10 = {
      x: ax1,
      y: ay1
    };
    c22 = {
      x: bx1 - 2 * bx2 + bx3,
      y: by1 - 2 * by2 + by3
    };
    c21 = {
      x: 2 * bx2 - 2 * bx1,
      y: 2 * by2 - 2 * by1
    };
    c20 = {
      x: bx1,
      y: by1
    };
    var coefs;

    if (c12.y === 0) {
      var v0 = c12.x * (c10.y - c20.y);
      var v1 = v0 - c11.x * c11.y;
      var v3 = c11.y * c11.y;
      coefs = [c12.x * c22.y * c22.y, 2 * c12.x * c21.y * c22.y, c12.x * c21.y * c21.y - c22.x * v3 - c22.y * v0 - c22.y * v1, -c21.x * v3 - c21.y * v0 - c21.y * v1, (c10.x - c20.x) * v3 + (c10.y - c20.y) * v1].reverse();
    } else {
      var _v = c12.x * c22.y - c12.y * c22.x;

      var _v2 = c12.x * c21.y - c21.x * c12.y;

      var _v3 = c11.x * c12.y - c11.y * c12.x;

      var _v4 = c10.y - c20.y;

      var v4 = c12.y * (c10.x - c20.x) - c12.x * _v4;
      var v5 = -c11.y * _v3 + c12.y * v4;
      var v6 = _v3 * _v3;
      coefs = [_v * _v, 2 * _v * _v2, (-c22.y * v6 + c12.y * _v2 * _v2 + c12.y * _v * v4 + _v * v5) / c12.y, (-c21.y * v6 + c12.y * _v2 * v4 + _v2 * v5) / c12.y, (_v4 * v6 + v4 * v5) / c12.y].reverse();
    }

    var roots = getRoots(coefs);

    for (var i = 0; i < roots.length; i++) {
      var s = roots[i];

      if (0 <= s && s <= 1) {
        var xRoots = getRoots([c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x].reverse());
        var yRoots = getRoots([c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y].reverse());

        if (xRoots.length > 0 && yRoots.length > 0) {
          var _TOLERANCE = 1e-4;

          checkRoots: for (var j = 0; j < xRoots.length; j++) {
            var xRoot = xRoots[j];

            if (0 <= xRoot && xRoot <= 1) {
              for (var k = 0; k < yRoots.length; k++) {
                if (Math.abs(xRoot - yRoots[k]) < _TOLERANCE) {
                  var x = c22.x * s * s + c21.x * s + c20.x;
                  var y = c22.y * s * s + c21.y * s + c20.y;
                  result.push({
                    x: x,
                    y: y,
                    t: xRoot
                  }); // result.push(c22.multiply(s * s).add(c21.multiply(s).add(c20)));

                  break checkRoots;
                }
              }
            }
          }
        }
      }
    }

    return result;
  }

  function intersectBezier3Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2, bx3, by3, bx4, by4) {
    var c13, c12, c11, c10; // 三阶系数

    var c23, c22, c21, c20;
    var result = [];
    c13 = {
      x: -ax1 + 3 * ax2 - 3 * ax3 + ax4,
      y: -ay1 + 3 * ay2 - 3 * ay3 + ay4
    };
    c12 = {
      x: 3 * ax1 - 6 * ax2 + 3 * ax3,
      y: 3 * ay1 - 6 * ay2 + 3 * ay3
    };
    c11 = {
      x: -3 * ax1 + 3 * ax2,
      y: -3 * ay1 + 3 * ay2
    };
    c10 = {
      x: ax1,
      y: ay1
    };
    c23 = {
      x: -bx1 + 3 * bx2 - 3 * bx3 + bx4,
      y: -by1 + 3 * by2 - 3 * by3 + by4
    };
    c22 = {
      x: 3 * bx1 - 6 * bx2 + 3 * bx3,
      y: 3 * by1 - 6 * by2 + 3 * by3
    };
    c21 = {
      x: -3 * bx1 + 3 * bx2,
      y: -3 * by1 + 3 * by2
    };
    c20 = {
      x: bx1,
      y: by1
    };
    var c10x2 = c10.x * c10.x;
    var c10x3 = c10.x * c10.x * c10.x;
    var c10y2 = c10.y * c10.y;
    var c10y3 = c10.y * c10.y * c10.y;
    var c11x2 = c11.x * c11.x;
    var c11x3 = c11.x * c11.x * c11.x;
    var c11y2 = c11.y * c11.y;
    var c11y3 = c11.y * c11.y * c11.y;
    var c12x2 = c12.x * c12.x;
    var c12x3 = c12.x * c12.x * c12.x;
    var c12y2 = c12.y * c12.y;
    var c12y3 = c12.y * c12.y * c12.y;
    var c13x2 = c13.x * c13.x;
    var c13x3 = c13.x * c13.x * c13.x;
    var c13y2 = c13.y * c13.y;
    var c13y3 = c13.y * c13.y * c13.y;
    var c20x2 = c20.x * c20.x;
    var c20x3 = c20.x * c20.x * c20.x;
    var c20y2 = c20.y * c20.y;
    var c20y3 = c20.y * c20.y * c20.y;
    var c21x2 = c21.x * c21.x;
    var c21x3 = c21.x * c21.x * c21.x;
    var c21y2 = c21.y * c21.y;
    var c22x2 = c22.x * c22.x;
    var c22x3 = c22.x * c22.x * c22.x;
    var c22y2 = c22.y * c22.y;
    var c23x2 = c23.x * c23.x;
    var c23x3 = c23.x * c23.x * c23.x;
    var c23y2 = c23.y * c23.y;
    var c23y3 = c23.y * c23.y * c23.y;
    var coefs = [-c13x3 * c23y3 + c13y3 * c23x3 - 3 * c13.x * c13y2 * c23x2 * c23.y + 3 * c13x2 * c13.y * c23.x * c23y2, -6 * c13.x * c22.x * c13y2 * c23.x * c23.y + 6 * c13x2 * c13.y * c22.y * c23.x * c23.y + 3 * c22.x * c13y3 * c23x2 - 3 * c13x3 * c22.y * c23y2 - 3 * c13.x * c13y2 * c22.y * c23x2 + 3 * c13x2 * c22.x * c13.y * c23y2, -6 * c21.x * c13.x * c13y2 * c23.x * c23.y - 6 * c13.x * c22.x * c13y2 * c22.y * c23.x + 6 * c13x2 * c22.x * c13.y * c22.y * c23.y + 3 * c21.x * c13y3 * c23x2 + 3 * c22x2 * c13y3 * c23.x + 3 * c21.x * c13x2 * c13.y * c23y2 - 3 * c13.x * c21.y * c13y2 * c23x2 - 3 * c13.x * c22x2 * c13y2 * c23.y + c13x2 * c13.y * c23.x * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-c21.y * c23y2 - 2 * c22y2 * c23.y - c23.y * (2 * c21.y * c23.y + c22y2)), c11.x * c12.y * c13.x * c13.y * c23.x * c23.y - c11.y * c12.x * c13.x * c13.y * c23.x * c23.y + 6 * c21.x * c22.x * c13y3 * c23.x + 3 * c11.x * c12.x * c13.x * c13.y * c23y2 + 6 * c10.x * c13.x * c13y2 * c23.x * c23.y - 3 * c11.x * c12.x * c13y2 * c23.x * c23.y - 3 * c11.y * c12.y * c13.x * c13.y * c23x2 - 6 * c10.y * c13x2 * c13.y * c23.x * c23.y - 6 * c20.x * c13.x * c13y2 * c23.x * c23.y + 3 * c11.y * c12.y * c13x2 * c23.x * c23.y - 2 * c12.x * c12y2 * c13.x * c23.x * c23.y - 6 * c21.x * c13.x * c22.x * c13y2 * c23.y - 6 * c21.x * c13.x * c13y2 * c22.y * c23.x - 6 * c13.x * c21.y * c22.x * c13y2 * c23.x + 6 * c21.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.y * c23.x * c23.y + c22x3 * c13y3 - 3 * c10.x * c13y3 * c23x2 + 3 * c10.y * c13x3 * c23y2 + 3 * c20.x * c13y3 * c23x2 + c12y3 * c13.x * c23x2 - c12x3 * c13.y * c23y2 - 3 * c10.x * c13x2 * c13.y * c23y2 + 3 * c10.y * c13.x * c13y2 * c23x2 - 2 * c11.x * c12.y * c13x2 * c23y2 + c11.x * c12.y * c13y2 * c23x2 - c11.y * c12.x * c13x2 * c23y2 + 2 * c11.y * c12.x * c13y2 * c23x2 + 3 * c20.x * c13x2 * c13.y * c23y2 - c12.x * c12y2 * c13.y * c23x2 - 3 * c20.y * c13.x * c13y2 * c23x2 + c12x2 * c12.y * c13.x * c23y2 - 3 * c13.x * c22x2 * c13y2 * c22.y + c13x2 * c13.y * c23.x * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c22.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c21.y * c22.y * c23.y - c20.y * c23y2 - c22.y * (2 * c21.y * c23.y + c22y2) - c23.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), 6 * c11.x * c12.x * c13.x * c13.y * c22.y * c23.y + c11.x * c12.y * c13.x * c22.x * c13.y * c23.y + c11.x * c12.y * c13.x * c13.y * c22.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c23.y - c11.y * c12.x * c13.x * c13.y * c22.y * c23.x - 6 * c11.y * c12.y * c13.x * c22.x * c13.y * c23.x - 6 * c10.x * c22.x * c13y3 * c23.x + 6 * c20.x * c22.x * c13y3 * c23.x + 6 * c10.y * c13x3 * c22.y * c23.y + 2 * c12y3 * c13.x * c22.x * c23.x - 2 * c12x3 * c13.y * c22.y * c23.y + 6 * c10.x * c13.x * c22.x * c13y2 * c23.y + 6 * c10.x * c13.x * c13y2 * c22.y * c23.x + 6 * c10.y * c13.x * c22.x * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c23.y - 3 * c11.x * c12.x * c13y2 * c22.y * c23.x + 2 * c11.x * c12.y * c22.x * c13y2 * c23.x + 4 * c11.y * c12.x * c22.x * c13y2 * c23.x - 6 * c10.x * c13x2 * c13.y * c22.y * c23.y - 6 * c10.y * c13x2 * c22.x * c13.y * c23.y - 6 * c10.y * c13x2 * c13.y * c22.y * c23.x - 4 * c11.x * c12.y * c13x2 * c22.y * c23.y - 6 * c20.x * c13.x * c22.x * c13y2 * c23.y - 6 * c20.x * c13.x * c13y2 * c22.y * c23.x - 2 * c11.y * c12.x * c13x2 * c22.y * c23.y + 3 * c11.y * c12.y * c13x2 * c22.x * c23.y + 3 * c11.y * c12.y * c13x2 * c22.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c23.y - 2 * c12.x * c12y2 * c13.x * c22.y * c23.x - 2 * c12.x * c12y2 * c22.x * c13.y * c23.x - 6 * c20.y * c13.x * c22.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c13y2 * c23.x - 6 * c21.x * c13.x * c22.x * c13y2 * c22.y + 6 * c20.x * c13x2 * c13.y * c22.y * c23.y + 2 * c12x2 * c12.y * c13.x * c22.y * c23.y + 2 * c12x2 * c12.y * c22.x * c13.y * c23.y + 2 * c12x2 * c12.y * c13.y * c22.y * c23.x + 3 * c21.x * c22x2 * c13y3 + 3 * c21x2 * c13y3 * c23.x - 3 * c13.x * c21.y * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c23.y + c13x2 * c22.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c13x2 * c13.y * c23.x * (6 * c20.y * c22.y + 3 * c21y2) + c21.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c22.y * c23.y - c23.y * (2 * c20.y * c22.y + c21y2) - c21.y * (2 * c21.y * c23.y + c22y2) - c22.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), c11.x * c21.x * c12.y * c13.x * c13.y * c23.y + c11.x * c12.y * c13.x * c21.y * c13.y * c23.x + c11.x * c12.y * c13.x * c22.x * c13.y * c22.y - c11.y * c12.x * c21.x * c13.x * c13.y * c23.y - c11.y * c12.x * c13.x * c21.y * c13.y * c23.x - c11.y * c12.x * c13.x * c22.x * c13.y * c22.y - 6 * c11.y * c21.x * c12.y * c13.x * c13.y * c23.x - 6 * c10.x * c21.x * c13y3 * c23.x + 6 * c20.x * c21.x * c13y3 * c23.x + 2 * c21.x * c12y3 * c13.x * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c23.y + 6 * c10.x * c13.x * c21.y * c13y2 * c23.x + 6 * c10.x * c13.x * c22.x * c13y2 * c22.y + 6 * c10.y * c21.x * c13.x * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c23.y - 3 * c11.x * c12.x * c21.y * c13y2 * c23.x - 3 * c11.x * c12.x * c22.x * c13y2 * c22.y + 2 * c11.x * c21.x * c12.y * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c13y2 * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c23.y - 6 * c10.y * c13x2 * c21.y * c13.y * c23.x - 6 * c10.y * c13x2 * c22.x * c13.y * c22.y - 6 * c20.x * c21.x * c13.x * c13y2 * c23.y - 6 * c20.x * c13.x * c21.y * c13y2 * c23.x - 6 * c20.x * c13.x * c22.x * c13y2 * c22.y + 3 * c11.y * c21.x * c12.y * c13x2 * c23.y - 3 * c11.y * c12.y * c13.x * c22x2 * c13.y + 3 * c11.y * c12.y * c13x2 * c21.y * c23.x + 3 * c11.y * c12.y * c13x2 * c22.x * c22.y - 2 * c12.x * c21.x * c12y2 * c13.x * c23.y - 2 * c12.x * c21.x * c12y2 * c13.y * c23.x - 2 * c12.x * c12y2 * c13.x * c21.y * c23.x - 2 * c12.x * c12y2 * c13.x * c22.x * c22.y - 6 * c20.y * c21.x * c13.x * c13y2 * c23.x - 6 * c21.x * c13.x * c21.y * c22.x * c13y2 + 6 * c20.y * c13x2 * c21.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c23.y + 2 * c12x2 * c12.y * c21.y * c13.y * c23.x + 2 * c12x2 * c12.y * c22.x * c13.y * c22.y - 3 * c10.x * c22x2 * c13y3 + 3 * c20.x * c22x2 * c13y3 + 3 * c21x2 * c22.x * c13y3 + c12y3 * c13.x * c22x2 + 3 * c10.y * c13.x * c22x2 * c13y2 + c11.x * c12.y * c22x2 * c13y2 + 2 * c11.y * c12.x * c22x2 * c13y2 - c12.x * c12y2 * c22x2 * c13.y - 3 * c20.y * c13.x * c22x2 * c13y2 - 3 * c21x2 * c13.x * c13y2 * c22.y + c12x2 * c12.y * c13.x * (2 * c21.y * c23.y + c22y2) + c11.x * c12.x * c13.x * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c21.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c21.y * c23.y - c22y2) + c10.y * c13x3 * (6 * c21.y * c23.y + 3 * c22y2) + c11.y * c12.x * c13x2 * (-2 * c21.y * c23.y - c22y2) + c11.x * c12.y * c13x2 * (-4 * c21.y * c23.y - 2 * c22y2) + c10.x * c13x2 * c13.y * (-6 * c21.y * c23.y - 3 * c22y2) + c13x2 * c22.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c21.y * c23.y + 3 * c22y2) + c13x3 * (-2 * c20.y * c21.y * c23.y - c22.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c21.y * c23.y + c22y2) - c21.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c23.y + c10.x * c11.y * c12.x * c13.x * c13.y * c23.y + 6 * c10.x * c11.y * c12.y * c13.x * c13.y * c23.x - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c23.y - c10.y * c11.x * c12.y * c13.x * c13.y * c23.x + c10.y * c11.y * c12.x * c13.x * c13.y * c23.x + c11.x * c11.y * c12.x * c12.y * c13.x * c23.y - c11.x * c11.y * c12.x * c12.y * c13.y * c23.x + c11.x * c20.x * c12.y * c13.x * c13.y * c23.y + c11.x * c20.y * c12.y * c13.x * c13.y * c23.x + c11.x * c21.x * c12.y * c13.x * c13.y * c22.y + c11.x * c12.y * c13.x * c21.y * c22.x * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c23.y - 6 * c20.x * c11.y * c12.y * c13.x * c13.y * c23.x - c11.y * c12.x * c20.y * c13.x * c13.y * c23.x - c11.y * c12.x * c21.x * c13.x * c13.y * c22.y - c11.y * c12.x * c13.x * c21.y * c22.x * c13.y - 6 * c11.y * c21.x * c12.y * c13.x * c22.x * c13.y - 6 * c10.x * c20.x * c13y3 * c23.x - 6 * c10.x * c21.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c23.x + 6 * c20.x * c21.x * c22.x * c13y3 + 2 * c20.x * c12y3 * c13.x * c23.x + 2 * c21.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c23.y - 6 * c10.x * c10.y * c13.x * c13y2 * c23.x + 3 * c10.x * c11.x * c12.x * c13y2 * c23.y - 2 * c10.x * c11.x * c12.y * c13y2 * c23.x - 4 * c10.x * c11.y * c12.x * c13y2 * c23.x + 3 * c10.y * c11.x * c12.x * c13y2 * c23.x + 6 * c10.x * c10.y * c13x2 * c13.y * c23.y + 6 * c10.x * c20.x * c13.x * c13y2 * c23.y - 3 * c10.x * c11.y * c12.y * c13x2 * c23.y + 2 * c10.x * c12.x * c12y2 * c13.x * c23.y + 2 * c10.x * c12.x * c12y2 * c13.y * c23.x + 6 * c10.x * c20.y * c13.x * c13y2 * c23.x + 6 * c10.x * c21.x * c13.x * c13y2 * c22.y + 6 * c10.x * c13.x * c21.y * c22.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c23.y + 6 * c10.y * c20.x * c13.x * c13y2 * c23.x + 2 * c10.y * c11.y * c12.x * c13x2 * c23.y - 3 * c10.y * c11.y * c12.y * c13x2 * c23.x + 2 * c10.y * c12.x * c12y2 * c13.x * c23.x + 6 * c10.y * c21.x * c13.x * c22.x * c13y2 - 3 * c11.x * c20.x * c12.x * c13y2 * c23.y + 2 * c11.x * c20.x * c12.y * c13y2 * c23.x + c11.x * c11.y * c12y2 * c13.x * c23.x - 3 * c11.x * c12.x * c20.y * c13y2 * c23.x - 3 * c11.x * c12.x * c21.x * c13y2 * c22.y - 3 * c11.x * c12.x * c21.y * c22.x * c13y2 + 2 * c11.x * c21.x * c12.y * c22.x * c13y2 + 4 * c20.x * c11.y * c12.x * c13y2 * c23.x + 4 * c11.y * c12.x * c21.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c23.y - 6 * c10.y * c20.x * c13x2 * c13.y * c23.y - 6 * c10.y * c20.y * c13x2 * c13.y * c23.x - 6 * c10.y * c21.x * c13x2 * c13.y * c22.y - 2 * c10.y * c12x2 * c12.y * c13.x * c23.y - 2 * c10.y * c12x2 * c12.y * c13.y * c23.x - 6 * c10.y * c13x2 * c21.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c23.y - 2 * c11.x * c11y2 * c13.x * c13.y * c23.x + 3 * c20.x * c11.y * c12.y * c13x2 * c23.y - 2 * c20.x * c12.x * c12y2 * c13.x * c23.y - 2 * c20.x * c12.x * c12y2 * c13.y * c23.x - 6 * c20.x * c20.y * c13.x * c13y2 * c23.x - 6 * c20.x * c21.x * c13.x * c13y2 * c22.y - 6 * c20.x * c13.x * c21.y * c22.x * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c23.x + 3 * c11.y * c21.x * c12.y * c13x2 * c22.y + 3 * c11.y * c12.y * c13x2 * c21.y * c22.x - 2 * c12.x * c20.y * c12y2 * c13.x * c23.x - 2 * c12.x * c21.x * c12y2 * c13.x * c22.y - 2 * c12.x * c21.x * c12y2 * c22.x * c13.y - 2 * c12.x * c12y2 * c13.x * c21.y * c22.x - 6 * c20.y * c21.x * c13.x * c22.x * c13y2 - c11y2 * c12.x * c12.y * c13.x * c23.x + 2 * c20.x * c12x2 * c12.y * c13.y * c23.y + 6 * c20.y * c13x2 * c21.y * c22.x * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c23.y + c11x2 * c12.x * c12.y * c13.y * c23.y + 2 * c12x2 * c20.y * c12.y * c13.y * c23.x + 2 * c12x2 * c21.x * c12.y * c13.y * c22.y + 2 * c12x2 * c12.y * c21.y * c22.x * c13.y + c21x3 * c13y3 + 3 * c10x2 * c13y3 * c23.x - 3 * c10y2 * c13x3 * c23.y + 3 * c20x2 * c13y3 * c23.x + c11y3 * c13x2 * c23.x - c11x3 * c13y2 * c23.y - c11.x * c11y2 * c13x2 * c23.y + c11x2 * c11.y * c13y2 * c23.x - 3 * c10x2 * c13.x * c13y2 * c23.y + 3 * c10y2 * c13x2 * c13.y * c23.x - c11x2 * c12y2 * c13.x * c23.y + c11y2 * c12x2 * c13.y * c23.x - 3 * c21x2 * c13.x * c21.y * c13y2 - 3 * c20x2 * c13.x * c13y2 * c23.y + 3 * c20y2 * c13x2 * c13.y * c23.x + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c12x3 * c13.y * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c10.y * c13x3 * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c11.y * c12.x * c13x2 * (-2 * c20.y * c23.y - 2 * c21.y * c22.y) + c12x2 * c12.y * c13.x * (2 * c20.y * c23.y + 2 * c21.y * c22.y) + c11.x * c12.y * c13x2 * (-4 * c20.y * c23.y - 4 * c21.y * c22.y) + c10.x * c13x2 * c13.y * (-6 * c20.y * c23.y - 6 * c21.y * c22.y) + c20.x * c13x2 * c13.y * (6 * c20.y * c23.y + 6 * c21.y * c22.y) + c21.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21.y * c22.y - c20y2 * c23.y - c21.y * (2 * c20.y * c22.y + c21y2) - c20.y * (2 * c20.y * c23.y + 2 * c21.y * c22.y)), -c10.x * c11.x * c12.y * c13.x * c13.y * c22.y + c10.x * c11.y * c12.x * c13.x * c13.y * c22.y + 6 * c10.x * c11.y * c12.y * c13.x * c22.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c13.y * c22.y - c10.y * c11.x * c12.y * c13.x * c22.x * c13.y + c10.y * c11.y * c12.x * c13.x * c22.x * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c22.y - c11.x * c11.y * c12.x * c12.y * c22.x * c13.y + c11.x * c20.x * c12.y * c13.x * c13.y * c22.y + c11.x * c20.y * c12.y * c13.x * c22.x * c13.y + c11.x * c21.x * c12.y * c13.x * c21.y * c13.y - c20.x * c11.y * c12.x * c13.x * c13.y * c22.y - 6 * c20.x * c11.y * c12.y * c13.x * c22.x * c13.y - c11.y * c12.x * c20.y * c13.x * c22.x * c13.y - c11.y * c12.x * c21.x * c13.x * c21.y * c13.y - 6 * c10.x * c20.x * c22.x * c13y3 - 2 * c10.x * c12y3 * c13.x * c22.x + 2 * c20.x * c12y3 * c13.x * c22.x + 2 * c10.y * c12x3 * c13.y * c22.y - 6 * c10.x * c10.y * c13.x * c22.x * c13y2 + 3 * c10.x * c11.x * c12.x * c13y2 * c22.y - 2 * c10.x * c11.x * c12.y * c22.x * c13y2 - 4 * c10.x * c11.y * c12.x * c22.x * c13y2 + 3 * c10.y * c11.x * c12.x * c22.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c13.y * c22.y + 6 * c10.x * c20.x * c13.x * c13y2 * c22.y - 3 * c10.x * c11.y * c12.y * c13x2 * c22.y + 2 * c10.x * c12.x * c12y2 * c13.x * c22.y + 2 * c10.x * c12.x * c12y2 * c22.x * c13.y + 6 * c10.x * c20.y * c13.x * c22.x * c13y2 + 6 * c10.x * c21.x * c13.x * c21.y * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c22.y + 6 * c10.y * c20.x * c13.x * c22.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c22.y - 3 * c10.y * c11.y * c12.y * c13x2 * c22.x + 2 * c10.y * c12.x * c12y2 * c13.x * c22.x - 3 * c11.x * c20.x * c12.x * c13y2 * c22.y + 2 * c11.x * c20.x * c12.y * c22.x * c13y2 + c11.x * c11.y * c12y2 * c13.x * c22.x - 3 * c11.x * c12.x * c20.y * c22.x * c13y2 - 3 * c11.x * c12.x * c21.x * c21.y * c13y2 + 4 * c20.x * c11.y * c12.x * c22.x * c13y2 - 2 * c10.x * c12x2 * c12.y * c13.y * c22.y - 6 * c10.y * c20.x * c13x2 * c13.y * c22.y - 6 * c10.y * c20.y * c13x2 * c22.x * c13.y - 6 * c10.y * c21.x * c13x2 * c21.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c22.y - 2 * c10.y * c12x2 * c12.y * c22.x * c13.y - c11.x * c11.y * c12x2 * c13.y * c22.y - 2 * c11.x * c11y2 * c13.x * c22.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c22.y - 2 * c20.x * c12.x * c12y2 * c13.x * c22.y - 2 * c20.x * c12.x * c12y2 * c22.x * c13.y - 6 * c20.x * c20.y * c13.x * c22.x * c13y2 - 6 * c20.x * c21.x * c13.x * c21.y * c13y2 + 3 * c11.y * c20.y * c12.y * c13x2 * c22.x + 3 * c11.y * c21.x * c12.y * c13x2 * c21.y - 2 * c12.x * c20.y * c12y2 * c13.x * c22.x - 2 * c12.x * c21.x * c12y2 * c13.x * c21.y - c11y2 * c12.x * c12.y * c13.x * c22.x + 2 * c20.x * c12x2 * c12.y * c13.y * c22.y - 3 * c11.y * c21x2 * c12.y * c13.x * c13.y + 6 * c20.y * c21.x * c13x2 * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c13.y * c22.y + c11x2 * c12.x * c12.y * c13.y * c22.y + 2 * c12x2 * c20.y * c12.y * c22.x * c13.y + 2 * c12x2 * c21.x * c12.y * c21.y * c13.y - 3 * c10.x * c21x2 * c13y3 + 3 * c20.x * c21x2 * c13y3 + 3 * c10x2 * c22.x * c13y3 - 3 * c10y2 * c13x3 * c22.y + 3 * c20x2 * c22.x * c13y3 + c21x2 * c12y3 * c13.x + c11y3 * c13x2 * c22.x - c11x3 * c13y2 * c22.y + 3 * c10.y * c21x2 * c13.x * c13y2 - c11.x * c11y2 * c13x2 * c22.y + c11.x * c21x2 * c12.y * c13y2 + 2 * c11.y * c12.x * c21x2 * c13y2 + c11x2 * c11.y * c22.x * c13y2 - c12.x * c21x2 * c12y2 * c13.y - 3 * c20.y * c21x2 * c13.x * c13y2 - 3 * c10x2 * c13.x * c13y2 * c22.y + 3 * c10y2 * c13x2 * c22.x * c13.y - c11x2 * c12y2 * c13.x * c22.y + c11y2 * c12x2 * c22.x * c13.y - 3 * c20x2 * c13.x * c13y2 * c22.y + 3 * c20y2 * c13x2 * c22.x * c13.y + c12x2 * c12.y * c13.x * (2 * c20.y * c22.y + c21y2) + c11.x * c12.x * c13.x * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c12x3 * c13.y * (-2 * c20.y * c22.y - c21y2) + c10.y * c13x3 * (6 * c20.y * c22.y + 3 * c21y2) + c11.y * c12.x * c13x2 * (-2 * c20.y * c22.y - c21y2) + c11.x * c12.y * c13x2 * (-4 * c20.y * c22.y - 2 * c21y2) + c10.x * c13x2 * c13.y * (-6 * c20.y * c22.y - 3 * c21y2) + c20.x * c13x2 * c13.y * (6 * c20.y * c22.y + 3 * c21y2) + c13x3 * (-2 * c20.y * c21y2 - c20y2 * c22.y - c20.y * (2 * c20.y * c22.y + c21y2)), -c10.x * c11.x * c12.y * c13.x * c21.y * c13.y + c10.x * c11.y * c12.x * c13.x * c21.y * c13.y + 6 * c10.x * c11.y * c21.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c13.x * c21.y * c13.y - c10.y * c11.x * c21.x * c12.y * c13.x * c13.y + c10.y * c11.y * c12.x * c21.x * c13.x * c13.y - c11.x * c11.y * c12.x * c21.x * c12.y * c13.y + c11.x * c11.y * c12.x * c12.y * c13.x * c21.y + c11.x * c20.x * c12.y * c13.x * c21.y * c13.y + 6 * c11.x * c12.x * c20.y * c13.x * c21.y * c13.y + c11.x * c20.y * c21.x * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c13.x * c21.y * c13.y - 6 * c20.x * c11.y * c21.x * c12.y * c13.x * c13.y - c11.y * c12.x * c20.y * c21.x * c13.x * c13.y - 6 * c10.x * c20.x * c21.x * c13y3 - 2 * c10.x * c21.x * c12y3 * c13.x + 6 * c10.y * c20.y * c13x3 * c21.y + 2 * c20.x * c21.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c21.y * c13.y - 2 * c12x3 * c20.y * c21.y * c13.y - 6 * c10.x * c10.y * c21.x * c13.x * c13y2 + 3 * c10.x * c11.x * c12.x * c21.y * c13y2 - 2 * c10.x * c11.x * c21.x * c12.y * c13y2 - 4 * c10.x * c11.y * c12.x * c21.x * c13y2 + 3 * c10.y * c11.x * c12.x * c21.x * c13y2 + 6 * c10.x * c10.y * c13x2 * c21.y * c13.y + 6 * c10.x * c20.x * c13.x * c21.y * c13y2 - 3 * c10.x * c11.y * c12.y * c13x2 * c21.y + 2 * c10.x * c12.x * c21.x * c12y2 * c13.y + 2 * c10.x * c12.x * c12y2 * c13.x * c21.y + 6 * c10.x * c20.y * c21.x * c13.x * c13y2 + 4 * c10.y * c11.x * c12.y * c13x2 * c21.y + 6 * c10.y * c20.x * c21.x * c13.x * c13y2 + 2 * c10.y * c11.y * c12.x * c13x2 * c21.y - 3 * c10.y * c11.y * c21.x * c12.y * c13x2 + 2 * c10.y * c12.x * c21.x * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c21.y * c13y2 + 2 * c11.x * c20.x * c21.x * c12.y * c13y2 + c11.x * c11.y * c21.x * c12y2 * c13.x - 3 * c11.x * c12.x * c20.y * c21.x * c13y2 + 4 * c20.x * c11.y * c12.x * c21.x * c13y2 - 6 * c10.x * c20.y * c13x2 * c21.y * c13.y - 2 * c10.x * c12x2 * c12.y * c21.y * c13.y - 6 * c10.y * c20.x * c13x2 * c21.y * c13.y - 6 * c10.y * c20.y * c21.x * c13x2 * c13.y - 2 * c10.y * c12x2 * c21.x * c12.y * c13.y - 2 * c10.y * c12x2 * c12.y * c13.x * c21.y - c11.x * c11.y * c12x2 * c21.y * c13.y - 4 * c11.x * c20.y * c12.y * c13x2 * c21.y - 2 * c11.x * c11y2 * c21.x * c13.x * c13.y + 3 * c20.x * c11.y * c12.y * c13x2 * c21.y - 2 * c20.x * c12.x * c21.x * c12y2 * c13.y - 2 * c20.x * c12.x * c12y2 * c13.x * c21.y - 6 * c20.x * c20.y * c21.x * c13.x * c13y2 - 2 * c11.y * c12.x * c20.y * c13x2 * c21.y + 3 * c11.y * c20.y * c21.x * c12.y * c13x2 - 2 * c12.x * c20.y * c21.x * c12y2 * c13.x - c11y2 * c12.x * c21.x * c12.y * c13.x + 6 * c20.x * c20.y * c13x2 * c21.y * c13.y + 2 * c20.x * c12x2 * c12.y * c21.y * c13.y + 2 * c11x2 * c11.y * c13.x * c21.y * c13.y + c11x2 * c12.x * c12.y * c21.y * c13.y + 2 * c12x2 * c20.y * c21.x * c12.y * c13.y + 2 * c12x2 * c20.y * c12.y * c13.x * c21.y + 3 * c10x2 * c21.x * c13y3 - 3 * c10y2 * c13x3 * c21.y + 3 * c20x2 * c21.x * c13y3 + c11y3 * c21.x * c13x2 - c11x3 * c21.y * c13y2 - 3 * c20y2 * c13x3 * c21.y - c11.x * c11y2 * c13x2 * c21.y + c11x2 * c11.y * c21.x * c13y2 - 3 * c10x2 * c13.x * c21.y * c13y2 + 3 * c10y2 * c21.x * c13x2 * c13.y - c11x2 * c12y2 * c13.x * c21.y + c11y2 * c12x2 * c21.x * c13.y - 3 * c20x2 * c13.x * c21.y * c13y2 + 3 * c20y2 * c21.x * c13x2 * c13.y, c10.x * c10.y * c11.x * c12.y * c13.x * c13.y - c10.x * c10.y * c11.y * c12.x * c13.x * c13.y + c10.x * c11.x * c11.y * c12.x * c12.y * c13.y - c10.y * c11.x * c11.y * c12.x * c12.y * c13.x - c10.x * c11.x * c20.y * c12.y * c13.x * c13.y + 6 * c10.x * c20.x * c11.y * c12.y * c13.x * c13.y + c10.x * c11.y * c12.x * c20.y * c13.x * c13.y - c10.y * c11.x * c20.x * c12.y * c13.x * c13.y - 6 * c10.y * c11.x * c12.x * c20.y * c13.x * c13.y + c10.y * c20.x * c11.y * c12.x * c13.x * c13.y - c11.x * c20.x * c11.y * c12.x * c12.y * c13.y + c11.x * c11.y * c12.x * c20.y * c12.y * c13.x + c11.x * c20.x * c20.y * c12.y * c13.x * c13.y - c20.x * c11.y * c12.x * c20.y * c13.x * c13.y - 2 * c10.x * c20.x * c12y3 * c13.x + 2 * c10.y * c12x3 * c20.y * c13.y - 3 * c10.x * c10.y * c11.x * c12.x * c13y2 - 6 * c10.x * c10.y * c20.x * c13.x * c13y2 + 3 * c10.x * c10.y * c11.y * c12.y * c13x2 - 2 * c10.x * c10.y * c12.x * c12y2 * c13.x - 2 * c10.x * c11.x * c20.x * c12.y * c13y2 - c10.x * c11.x * c11.y * c12y2 * c13.x + 3 * c10.x * c11.x * c12.x * c20.y * c13y2 - 4 * c10.x * c20.x * c11.y * c12.x * c13y2 + 3 * c10.y * c11.x * c20.x * c12.x * c13y2 + 6 * c10.x * c10.y * c20.y * c13x2 * c13.y + 2 * c10.x * c10.y * c12x2 * c12.y * c13.y + 2 * c10.x * c11.x * c11y2 * c13.x * c13.y + 2 * c10.x * c20.x * c12.x * c12y2 * c13.y + 6 * c10.x * c20.x * c20.y * c13.x * c13y2 - 3 * c10.x * c11.y * c20.y * c12.y * c13x2 + 2 * c10.x * c12.x * c20.y * c12y2 * c13.x + c10.x * c11y2 * c12.x * c12.y * c13.x + c10.y * c11.x * c11.y * c12x2 * c13.y + 4 * c10.y * c11.x * c20.y * c12.y * c13x2 - 3 * c10.y * c20.x * c11.y * c12.y * c13x2 + 2 * c10.y * c20.x * c12.x * c12y2 * c13.x + 2 * c10.y * c11.y * c12.x * c20.y * c13x2 + c11.x * c20.x * c11.y * c12y2 * c13.x - 3 * c11.x * c20.x * c12.x * c20.y * c13y2 - 2 * c10.x * c12x2 * c20.y * c12.y * c13.y - 6 * c10.y * c20.x * c20.y * c13x2 * c13.y - 2 * c10.y * c20.x * c12x2 * c12.y * c13.y - 2 * c10.y * c11x2 * c11.y * c13.x * c13.y - c10.y * c11x2 * c12.x * c12.y * c13.y - 2 * c10.y * c12x2 * c20.y * c12.y * c13.x - 2 * c11.x * c20.x * c11y2 * c13.x * c13.y - c11.x * c11.y * c12x2 * c20.y * c13.y + 3 * c20.x * c11.y * c20.y * c12.y * c13x2 - 2 * c20.x * c12.x * c20.y * c12y2 * c13.x - c20.x * c11y2 * c12.x * c12.y * c13.x + 3 * c10y2 * c11.x * c12.x * c13.x * c13.y + 3 * c11.x * c12.x * c20y2 * c13.x * c13.y + 2 * c20.x * c12x2 * c20.y * c12.y * c13.y - 3 * c10x2 * c11.y * c12.y * c13.x * c13.y + 2 * c11x2 * c11.y * c20.y * c13.x * c13.y + c11x2 * c12.x * c20.y * c12.y * c13.y - 3 * c20x2 * c11.y * c12.y * c13.x * c13.y - c10x3 * c13y3 + c10y3 * c13x3 + c20x3 * c13y3 - c20y3 * c13x3 - 3 * c10.x * c20x2 * c13y3 - c10.x * c11y3 * c13x2 + 3 * c10x2 * c20.x * c13y3 + c10.y * c11x3 * c13y2 + 3 * c10.y * c20y2 * c13x3 + c20.x * c11y3 * c13x2 + c10x2 * c12y3 * c13.x - 3 * c10y2 * c20.y * c13x3 - c10y2 * c12x3 * c13.y + c20x2 * c12y3 * c13.x - c11x3 * c20.y * c13y2 - c12x3 * c20y2 * c13.y - c10.x * c11x2 * c11.y * c13y2 + c10.y * c11.x * c11y2 * c13x2 - 3 * c10.x * c10y2 * c13x2 * c13.y - c10.x * c11y2 * c12x2 * c13.y + c10.y * c11x2 * c12y2 * c13.x - c11.x * c11y2 * c20.y * c13x2 + 3 * c10x2 * c10.y * c13.x * c13y2 + c10x2 * c11.x * c12.y * c13y2 + 2 * c10x2 * c11.y * c12.x * c13y2 - 2 * c10y2 * c11.x * c12.y * c13x2 - c10y2 * c11.y * c12.x * c13x2 + c11x2 * c20.x * c11.y * c13y2 - 3 * c10.x * c20y2 * c13x2 * c13.y + 3 * c10.y * c20x2 * c13.x * c13y2 + c11.x * c20x2 * c12.y * c13y2 - 2 * c11.x * c20y2 * c12.y * c13x2 + c20.x * c11y2 * c12x2 * c13.y - c11.y * c12.x * c20y2 * c13x2 - c10x2 * c12.x * c12y2 * c13.y - 3 * c10x2 * c20.y * c13.x * c13y2 + 3 * c10y2 * c20.x * c13x2 * c13.y + c10y2 * c12x2 * c12.y * c13.x - c11x2 * c20.y * c12y2 * c13.x + 2 * c20x2 * c11.y * c12.x * c13y2 + 3 * c20.x * c20y2 * c13x2 * c13.y - c20x2 * c12.x * c12y2 * c13.y - 3 * c20x2 * c20.y * c13.x * c13y2 + c12x2 * c20y2 * c12.y * c13.x].reverse();
    var roots = getRootsInInterval(0, 1, coefs);

    for (var i = 0; i < roots.length; i++) {
      var s = roots[i];
      var xRoots = getRoots([c13.x, c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x].reverse());
      var yRoots = getRoots([c13.y, c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y].reverse());

      if (xRoots.length > 0 && yRoots.length > 0) {
        var _TOLERANCE2 = 1e-4;

        checkRoots: for (var j = 0; j < xRoots.length; j++) {
          var xRoot = xRoots[j];

          if (0 <= xRoot && xRoot <= 1) {
            for (var k = 0; k < yRoots.length; k++) {
              if (Math.abs(xRoot - yRoots[k]) < _TOLERANCE2) {
                var x = c23.x * s * s * s + c22.x * s * s + c21.x * s + c20.x;
                var y = c23.y * s * s * s + c22.y * s * s + c21.y * s + c20.y;
                result.push({
                  x: x,
                  y: y,
                  t: xRoot
                });
                break checkRoots;
              }
            }
          }
        }
      }
    }

    return result;
  }

  function intersectBezier2Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3, bx4, by4) {
    var c12, c11, c10;
    var c23, c22, c21, c20;
    var result = [];
    c12 = {
      x: ax1 - 2 * ax2 + ax3,
      y: ay1 - 2 * ay2 + ay3
    };
    c11 = {
      x: 2 * ax2 - 2 * ax1,
      y: 2 * ay2 - 2 * ay1
    };
    c10 = {
      x: ax1,
      y: ay1
    };
    c23 = {
      x: -bx1 + 3 * bx2 - 3 * bx3 + bx4,
      y: -by1 + 3 * by2 - 3 * by3 + by4
    };
    c22 = {
      x: 3 * bx1 - 6 * bx2 + 3 * bx3,
      y: 3 * by1 - 6 * by2 + 3 * by3
    };
    c21 = {
      x: -3 * bx1 + 3 * bx2,
      y: -3 * by1 + 3 * by2
    };
    c20 = {
      x: bx1,
      y: by1
    };
    var c10x2 = c10.x * c10.x;
    var c10y2 = c10.y * c10.y;
    var c11x2 = c11.x * c11.x;
    var c11y2 = c11.y * c11.y;
    var c12x2 = c12.x * c12.x;
    var c12y2 = c12.y * c12.y;
    var c20x2 = c20.x * c20.x;
    var c20y2 = c20.y * c20.y;
    var c21x2 = c21.x * c21.x;
    var c21y2 = c21.y * c21.y;
    var c22x2 = c22.x * c22.x;
    var c22y2 = c22.y * c22.y;
    var c23x2 = c23.x * c23.x;
    var c23y2 = c23.y * c23.y;
    var coefs = [-2 * c12.x * c12.y * c23.x * c23.y + c12x2 * c23y2 + c12y2 * c23x2, -2 * c12.x * c12.y * c22.x * c23.y - 2 * c12.x * c12.y * c22.y * c23.x + 2 * c12y2 * c22.x * c23.x + 2 * c12x2 * c22.y * c23.y, -2 * c12.x * c21.x * c12.y * c23.y - 2 * c12.x * c12.y * c21.y * c23.x - 2 * c12.x * c12.y * c22.x * c22.y + 2 * c21.x * c12y2 * c23.x + c12y2 * c22x2 + c12x2 * (2 * c21.y * c23.y + c22y2), 2 * c10.x * c12.x * c12.y * c23.y + 2 * c10.y * c12.x * c12.y * c23.x + c11.x * c11.y * c12.x * c23.y + c11.x * c11.y * c12.y * c23.x - 2 * c20.x * c12.x * c12.y * c23.y - 2 * c12.x * c20.y * c12.y * c23.x - 2 * c12.x * c21.x * c12.y * c22.y - 2 * c12.x * c12.y * c21.y * c22.x - 2 * c10.x * c12y2 * c23.x - 2 * c10.y * c12x2 * c23.y + 2 * c20.x * c12y2 * c23.x + 2 * c21.x * c12y2 * c22.x - c11y2 * c12.x * c23.x - c11x2 * c12.y * c23.y + c12x2 * (2 * c20.y * c23.y + 2 * c21.y * c22.y), 2 * c10.x * c12.x * c12.y * c22.y + 2 * c10.y * c12.x * c12.y * c22.x + c11.x * c11.y * c12.x * c22.y + c11.x * c11.y * c12.y * c22.x - 2 * c20.x * c12.x * c12.y * c22.y - 2 * c12.x * c20.y * c12.y * c22.x - 2 * c12.x * c21.x * c12.y * c21.y - 2 * c10.x * c12y2 * c22.x - 2 * c10.y * c12x2 * c22.y + 2 * c20.x * c12y2 * c22.x - c11y2 * c12.x * c22.x - c11x2 * c12.y * c22.y + c21x2 * c12y2 + c12x2 * (2 * c20.y * c22.y + c21y2), 2 * c10.x * c12.x * c12.y * c21.y + 2 * c10.y * c12.x * c21.x * c12.y + c11.x * c11.y * c12.x * c21.y + c11.x * c11.y * c21.x * c12.y - 2 * c20.x * c12.x * c12.y * c21.y - 2 * c12.x * c20.y * c21.x * c12.y - 2 * c10.x * c21.x * c12y2 - 2 * c10.y * c12x2 * c21.y + 2 * c20.x * c21.x * c12y2 - c11y2 * c12.x * c21.x - c11x2 * c12.y * c21.y + 2 * c12x2 * c20.y * c21.y, -2 * c10.x * c10.y * c12.x * c12.y - c10.x * c11.x * c11.y * c12.y - c10.y * c11.x * c11.y * c12.x + 2 * c10.x * c12.x * c20.y * c12.y + 2 * c10.y * c20.x * c12.x * c12.y + c11.x * c20.x * c11.y * c12.y + c11.x * c11.y * c12.x * c20.y - 2 * c20.x * c12.x * c20.y * c12.y - 2 * c10.x * c20.x * c12y2 + c10.x * c11y2 * c12.x + c10.y * c11x2 * c12.y - 2 * c10.y * c12x2 * c20.y - c20.x * c11y2 * c12.x - c11x2 * c20.y * c12.y + c10x2 * c12y2 + c10y2 * c12x2 + c20x2 * c12y2 + c12x2 * c20y2].reverse();
    var roots = getRootsInInterval(0, 1, coefs); // console.log(roots);

    for (var i = 0; i < roots.length; i++) {
      var s = roots[i];
      var xRoots = getRoots([c12.x, c11.x, c10.x - c20.x - s * c21.x - s * s * c22.x - s * s * s * c23.x].reverse());
      var yRoots = getRoots([c12.y, c11.y, c10.y - c20.y - s * c21.y - s * s * c22.y - s * s * s * c23.y].reverse()); //
      // console.log('xRoots', xRoots);
      //
      // console.log('yRoots', yRoots);

      if (xRoots.length > 0 && yRoots.length > 0) {
        var _TOLERANCE3 = 1e-4;

        checkRoots: for (var j = 0; j < xRoots.length; j++) {
          var xRoot = xRoots[j];

          if (0 <= xRoot && xRoot <= 1) {
            for (var k = 0; k < yRoots.length; k++) {
              if (Math.abs(xRoot - yRoots[k]) < _TOLERANCE3) {
                var x = c23.x * s * s * s + c22.x * s * s + c21.x * s + c20.x;
                var y = c23.y * s * s * s + c22.y * s * s + c21.y * s + c20.y;
                result.push({
                  x: x,
                  y: y,
                  t: xRoot
                });
                break checkRoots;
              }
            }
          }
        }
      }
    }

    return result;
  }

  function intersectBezier2Line(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2) {
    var c2, c1, c0;
    var cl, n;
    var result = [];
    var minbx = Math.min(bx1, bx2);
    var minby = Math.min(by1, by2);
    var maxbx = Math.max(bx1, bx2);
    var maxby = Math.max(by1, by2);

    var dot = function dot(a, b) {
      return a.x * b.x + a.y * b.y;
    };

    var lerp = function lerp(a, b, t) {
      return {
        x: a.x - (a.x - b.x) * t,
        y: a.y - (a.y - b.y) * t,
        t: t
      };
    };

    c2 = {
      x: ax1 - 2 * ax2 + ax3,
      y: ay1 - 2 * ay2 + ay3
    };
    c1 = {
      x: -2 * ax1 + 2 * ax2,
      y: -2 * ay1 + 2 * ay2
    };
    c0 = {
      x: ax1,
      y: ay1
    };
    n = {
      x: by1 - by2,
      y: bx2 - bx1
    };
    cl = bx1 * by2 - bx2 * by1; // console.log('intersectBezier2Line', n, c0, c1, c2, cl);

    var coefs = [dot(n, c2), dot(n, c1), dot(n, c0) + cl].reverse(); // console.log('intersectBezier2Line coefs', coefs);

    var roots = getRoots(coefs); // console.log('intersectBezier2Line roots', roots);

    for (var i = 0; i < roots.length; i++) {
      var t = roots[i];

      if (0 <= t && t <= 1) {
        var p4 = lerp({
          x: ax1,
          y: ay1
        }, {
          x: ax2,
          y: ay2
        }, t);
        var p5 = lerp({
          x: ax2,
          y: ay2
        }, {
          x: ax3,
          y: ay3
        }, t);
        var p6 = lerp(p4, p5, t); // console.log('p4, p5, p6', p4, p5, p6);

        if (bx1 === bx2) {
          if (minby <= p6.y && p6.y <= maxby) {
            result.push(p6);
          }
        } else if (by1 === by2) {
          if (minbx <= p6.x && p6.x <= maxbx) {
            result.push(p6);
          }
        } else if (p6.x >= minbx && p6.y >= minby && p6.x <= maxbx && p6.y <= maxby) {
          result.push(p6);
        }
      }
    }

    return result;
  }
  /**
   *
   *    (-P1+3P2-3P3+P4)t^3 + (3P1-6P2+3P3)t^2 + (-3P1+3P2)t + P1
   *        /\                     /\                /\        /\
   *        ||                     ||                ||        ||
   *        c3                     c2                c1        c0
   */


  function intersectBezier3Line(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2) {
    var c3, c2, c1, c0;
    var cl, n;
    var result = [];
    var minbx = Math.min(bx1, bx2);
    var minby = Math.min(by1, by2);
    var maxbx = Math.max(bx1, bx2);
    var maxby = Math.max(by1, by2);

    var dot = function dot(a, b) {
      return a.x * b.x + a.y * b.y;
    };

    var lerp = function lerp(a, b, t) {
      return {
        x: a.x - (a.x - b.x) * t,
        y: a.y - (a.y - b.y) * t,
        t: t
      };
    };

    c3 = {
      x: -ax1 + 3 * ax2 - 3 * ax3 + ax4,
      y: -ay1 + 3 * ay2 - 3 * ay3 + ay4
    };
    c2 = {
      x: 3 * ax1 - 6 * ax2 + 3 * ax3,
      y: 3 * ay1 - 6 * ay2 + 3 * ay3
    };
    c1 = {
      x: -3 * ax1 + 3 * ax2,
      y: -3 * ay1 + 3 * ay2
    };
    c0 = {
      x: ax1,
      y: ay1
    };
    n = {
      x: by1 - by2,
      y: bx2 - bx1
    };
    cl = bx1 * by2 - bx2 * by1;
    var coefs = [cl + dot(n, c0), dot(n, c1), dot(n, c2), dot(n, c3)];
    var roots = getRoots(coefs);

    for (var i = 0; i < roots.length; i++) {
      var t = roots[i];

      if (0 <= t && t <= 1) {
        var p5 = lerp({
          x: ax1,
          y: ay1
        }, {
          x: ax2,
          y: ay2
        }, t);
        var p6 = lerp({
          x: ax2,
          y: ay2
        }, {
          x: ax3,
          y: ay3
        }, t);
        var p7 = lerp({
          x: ax3,
          y: ay3
        }, {
          x: ax4,
          y: ay4
        }, t);
        var p8 = lerp(p5, p6, t);
        var p9 = lerp(p6, p7, t);
        var p10 = lerp(p8, p9, t);

        if (bx1 === bx2) {
          if (minby <= p10.y && p10.y <= maxby) {
            result.push(p10);
          }
        } else if (by1 === by2) {
          if (minbx <= p10.x && p10.x <= maxbx) {
            result.push(p10);
          }
        } else if (p10.x >= minbx && p10.y >= minby && p10.x <= maxbx && p10.y <= maxby) {
          result.push(p10);
        }
      }
    }

    return result;
  } // bezier 2d 和椭圆

  var isec = {
    intersectBezier2Line: intersectBezier2Line,
    // 二阶贝塞尔曲线 与 直线
    intersectBezier3Line: intersectBezier3Line,
    // 三阶贝塞尔曲线 与 直线
    intersectBezier2Bezier2: intersectBezier2Bezier2,
    // 二阶贝塞尔曲线 与 二阶贝塞尔曲线
    intersectBezier3Bezier3: intersectBezier3Bezier3,
    // 三阶贝塞尔曲线 与 三阶贝塞尔曲线
    intersectBezier2Bezier3: intersectBezier2Bezier3 // 二阶贝塞尔曲线 与 三阶贝塞尔曲线
    // below functions are not used for now
    // intersectBezier2Ellipse, // 二阶贝塞尔曲线 与 椭圆
    // intersectBezier3Ellipse, // 三阶贝塞尔曲线 与 椭圆
    // intersectBezier2Circle, // 二阶贝塞尔曲线 与 圆
    // intersectBezier3Circle, // 三阶贝塞尔曲线 与 圆

  };

  var Point = /*#__PURE__*/function () {
    function Point(x, y) {
      if (Array.isArray(x)) {
        var _x = x;

        var _x2 = _slicedToArray(_x, 2);

        x = _x2[0];
        y = _x2[1];
      }

      this.x = x;
      this.y = y;
    }

    _createClass(Point, [{
      key: "toString",
      value: function toString() {
        // return this.x.toFixed(1).replace('.0', '') + ',' + this.y.toFixed(1).replace('.0', '');
        return this.x + ',' + this.y;
      }
    }, {
      key: "equal",
      value: function equal(o) {
        return this === o || this.x === o.x && this.y === o.y;
      } // 排序，要求a在b左即x更小，x相等a在b下，符合返回false，不符合则true

    }], [{
      key: "compare",
      value: function compare(a, b) {
        if (a.x > b.x) {
          return true;
        }

        return a.x === b.x && a.y > b.y;
      }
    }]);

    return Point;
  }();

  var Segment = /*#__PURE__*/function () {
    function Segment(coords, belong) {
      this.coords = coords;
      this.belong = belong; // 属于source多边形还是clip多边形，0和1区别

      this.calBbox();
      this.myFill = [false, false]; // 自己的上下内外性

      this.otherFill = [false, false]; // 对方的上下内外性

      this.myCoincide = 0; // 自己重合次数

      this.otherCoincide = 0; // 对方重合次数

      this.isVisited = false; // 扫描求交时用到

      this.isDeleted = false; // 相交裁剪老的线段会被删除
    }

    _createClass(Segment, [{
      key: "calBbox",
      value: function calBbox() {
        var coords = this.coords,
            l = coords.length;

        if (l === 2) {
          var a = coords[0],
              b = coords[1];
          var x1 = Math.min(a.x, b.x);
          var y1 = Math.min(a.y, b.y);
          var x2 = Math.max(a.x, b.x);
          var y2 = Math.max(a.y, b.y);
          this.bbox = [x1, y1, x2, y2];
        } else {
          var arr = coords.map(function (item) {
            return [item.x, item.y];
          });
          this.bbox = bezier$1.bboxBezier(arr);
        }
      } // 线段边逆序

    }, {
      key: "reverse",
      value: function reverse() {
        this.coords.reverse();
      }
    }, {
      key: "equal",
      value: function equal(o) {
        var ca = this.coords,
            cb = o.coords;

        if (ca.length !== cb.length) {
          return false;
        }

        for (var i = 0, len = ca.length; i < len; i++) {
          if (!ca[i].equal(cb[i])) {
            return false;
          }
        }

        return true;
      }
    }, {
      key: "toHash",
      value: function toHash() {
        return this.coords.map(function (item) {
          return item.toString();
        }).join(' ');
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.toHash() + ' ' + this.belong + ' ' + this.myCoincide + '' + this.otherCoincide + ' ' + this.myFill.map(function (i) {
          return i ? 1 : 0;
        }).join('') + this.otherFill.map(function (i) {
          return i ? 1 : 0;
        }).join('');
      }
    }]);

    return Segment;
  }();

  var EPS = 1e-9;
  var EPS2 = 1 - 1e-9;

  function getIntersectionLineLine$1(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2, d) {
    var toSource = ((bx2 - bx1) * (ay1 - by1) - (by2 - by1) * (ax1 - bx1)) / d;
    var toClip = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d; // 非顶点相交才是真相交

    if (toSource > EPS && toSource < EPS2 && toClip > EPS && toClip < EPS2) {
      var ox = ax1 + toSource * (ax2 - ax1);
      var oy = ay1 + toSource * (ay2 - ay1);
      return [{
        point: new Point(ox, oy),
        toSource: toSource,
        toClip: toClip
      }];
    }
  }

  function getIntersectionBezier2Line$1(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2) {
    var res = isec.intersectBezier2Line(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2);

    if (res.length) {
      res = res.map(function (item) {
        var toClip; // toClip是直线上的距离，可以简化为只看x或y，选择差值比较大的防止精度问题

        if (Math.abs(bx2 - bx1) >= Math.abs(by2 - by1)) {
          toClip = Math.abs((item.x - bx1) / (bx2 - bx1));
        } else {
          toClip = Math.abs((item.y - by1) / (by2 - by1));
        }

        if (item.t > EPS && item.t < EPS2 && toClip > EPS && toClip < EPS2) {
          // 还要判断斜率，相等也忽略（小于一定误差）
          var k1 = bezier$1.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3]], item.t);
          var k2 = bezier$1.bezierSlope([[bx1, by1], [bx2, by2]]); // 忽略方向，180°也是平行，Infinity相减为NaN

          if (Math.abs(Math.abs(k1) - Math.abs(k2) || 0) < EPS) {
            return;
          }

          return {
            point: new Point(item.x, item.y),
            toSource: item.t,
            // source是曲线直接用t
            toClip: toClip
          };
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  }

  function getIntersectionBezier2Bezier2$1(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3) {
    var res = isec.intersectBezier2Bezier2(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3);

    if (res.length) {
      res = res.map(function (item) {
        // toClip是另一条曲线的距离，需根据交点和曲线方程求t
        var toClip = bezier$1.getPointT([[bx1, by1], [bx2, by2], [bx3, by3]], item.x, item.y); // 防止误差无值

        if (toClip.length) {
          toClip = toClip[0];

          if (item.t > EPS && item.t < EPS2 && toClip > EPS && toClip < EPS2) {
            // 还要判断斜率，相等也忽略（小于一定误差）
            var k1 = bezier$1.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3]], item.t);
            var k2 = bezier$1.bezierSlope([[bx1, by1], [bx2, by2], [bx3, by3]], toClip); // 忽略方向，180°也是平行，Infinity相减为NaN

            if (Math.abs(Math.abs(k1) - Math.abs(k2) || 0) < EPS) {
              return;
            }

            return {
              point: new Point(item.x, item.y),
              toSource: item.t,
              // source是曲线直接用t
              toClip: toClip
            };
          }
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  }

  function getIntersectionBezier2Bezier3$1(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3, bx4, by4) {
    var res = isec.intersectBezier2Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, bx3, by3, bx4, by4);

    if (res.length) {
      res = res.map(function (item) {
        // toClip是另一条曲线的距离，需根据交点和曲线方程求t
        var toClip = bezier$1.getPointT([[bx1, by1], [bx2, by2], [bx3, by3], [bx4, by4]], item.x, item.y); // 防止误差无值

        if (toClip.length) {
          toClip = toClip[0];

          if (item.t > EPS && item.t < EPS2 && toClip > EPS && toClip < EPS2) {
            // 还要判断斜率，相等也忽略（小于一定误差）
            var k1 = bezier$1.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3]], item.t);
            var k2 = bezier$1.bezierSlope([[bx1, by1], [bx2, by2], [bx3, by3], [bx4, by4]], toClip); // 忽略方向，180°也是平行，Infinity相减为NaN

            if (Math.abs(Math.abs(k1) - Math.abs(k2) || 0) < EPS) {
              return;
            }

            return {
              point: new Point(item.x, item.y),
              toSource: item.t,
              // source是曲线直接用t
              toClip: toClip
            };
          }
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  }

  function getIntersectionBezier3Line$1(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2) {
    var res = isec.intersectBezier3Line(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2);

    if (res.length) {
      res = res.map(function (item) {
        // toClip是直线上的距离，可以简化为只看x或y，选择差值比较大的防止精度问题
        var toClip;

        if (Math.abs(bx2 - bx1) >= Math.abs(by2 - by1)) {
          toClip = Math.abs((item.x - bx1) / (bx2 - bx1));
        } else {
          toClip = Math.abs((item.y - by1) / (by2 - by1));
        }

        if (item.t > EPS && item.t < EPS2 && toClip > EPS && toClip < EPS2) {
          // 还要判断斜率，相等也忽略（小于一定误差）
          var k1 = bezier$1.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3], [ax4, ay4]], item.t);
          var k2 = bezier$1.bezierSlope([[bx1, by1], [bx2, by2]]); // 忽略方向，180°也是平行，Infinity相减为NaN

          if (Math.abs(Math.abs(k1) - Math.abs(k2) || 0) < EPS) {
            return;
          }

          return {
            point: new Point(item.x, item.y),
            toSource: item.t,
            // source是曲线直接用t
            toClip: toClip
          };
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  }

  function getIntersectionBezier3Bezier3$1(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2, bx3, by3, bx4, by4) {
    var res = isec.intersectBezier3Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2, bx3, by3, bx4, by4);

    if (res.length) {
      res = res.map(function (item) {
        // toClip是另一条曲线的距离，需根据交点和曲线方程求t
        var toClip = bezier$1.getPointT([[bx1, by1], [bx2, by2], [bx3, by3], [bx4, by4]], item.x, item.y); // 防止误差无值

        if (toClip.length) {
          toClip = toClip[0];

          if (item.t > EPS && item.t < EPS2 && toClip > EPS && toClip < EPS2) {
            // 还要判断斜率，相等也忽略（小于一定误差）
            var k1 = bezier$1.bezierSlope([[ax1, ay1], [ax2, ay2], [ax3, ay3], [ax4, ay4]], item.t);
            var k2 = bezier$1.bezierSlope([[bx1, by1], [bx2, by2], [bx3, by3], [bx4, by4]], toClip); // 忽略方向，180°也是平行，Infinity相减为NaN

            if (Math.abs(Math.abs(k1) - Math.abs(k2) || 0) < EPS) {
              return;
            }

            return {
              point: new Point(item.x, item.y),
              toSource: item.t,
              // source是曲线直接用t
              toClip: toClip
            };
          }
        }
      }).filter(function (i) {
        return i;
      });

      if (res.length) {
        return res;
      }
    }
  } // 两条线可能多个交点，将交点按原本线段的方向顺序排序


  function sortIntersection$1(res, isSource) {
    return res.sort(function (a, b) {
      if (isSource) {
        return a.toSource - b.toSource;
      }

      return a.toClip - b.toClip;
    }).map(function (item) {
      return {
        point: item.point,
        t: isSource ? item.toSource : item.toClip
      };
    }).filter(function (item) {
      return item.t > EPS && item.t < EPS2;
    });
  }

  var intersect$1 = {
    getIntersectionLineLine: getIntersectionLineLine$1,
    getIntersectionBezier2Line: getIntersectionBezier2Line$1,
    getIntersectionBezier2Bezier2: getIntersectionBezier2Bezier2$1,
    getIntersectionBezier2Bezier3: getIntersectionBezier2Bezier3$1,
    getIntersectionBezier3Line: getIntersectionBezier3Line$1,
    getIntersectionBezier3Bezier3: getIntersectionBezier3Bezier3$1,
    sortIntersection: sortIntersection$1
  };

  var getIntersectionLineLine = intersect$1.getIntersectionLineLine,
      getIntersectionBezier2Line = intersect$1.getIntersectionBezier2Line,
      getIntersectionBezier2Bezier2 = intersect$1.getIntersectionBezier2Bezier2,
      getIntersectionBezier2Bezier3 = intersect$1.getIntersectionBezier2Bezier3,
      getIntersectionBezier3Line = intersect$1.getIntersectionBezier3Line,
      getIntersectionBezier3Bezier3 = intersect$1.getIntersectionBezier3Bezier3,
      sortIntersection = intersect$1.sortIntersection;

  var Polygon$1 = /*#__PURE__*/function () {
    function Polygon(regions, index) {
      this.index = index; // 属于source多边形还是clip多边形，0和1区别

      var segments = []; // 多边形有>=1个区域，一般是1个

      if (!Array.isArray(regions)) {
        return;
      }

      regions.forEach(function (vertices) {
        // 每个区域有>=2条线段，组成封闭区域，1条肯定不行，2条必须是曲线
        if (!Array.isArray(vertices) || vertices.length < 2) {
          return;
        }

        if (vertices.length === 2 && vertices[1].length <= 2) {
          return;
        }

        var startPoint = new Point(vertices[0]),
            firstPoint = startPoint; // 根据多边形有向边，生成线段，不保持原有向，统一左下作为线段起点，如果翻转则记录个值标明

        for (var i = 1, len = vertices.length; i < len; i++) {
          var curr = vertices[i],
              l = curr.length; // 闭合区域，首尾顶点重复统一

          var endPoint = new Point(curr[l - 2], curr[l - 1]);
          var seg = void 0;

          if (l === 2) {
            // 长度为0的直线忽略
            if (startPoint.equal(endPoint)) {
              continue;
            }

            var coords = Point.compare(startPoint, endPoint) ? [endPoint, startPoint] : [startPoint, endPoint];
            seg = new Segment(coords, index);
          } // 曲线需确保x单调性，如果非单调，则切割为单调的多条
          else if (l === 4) {
            // 长度为0的曲线忽略
            if (startPoint.equal(endPoint) && startPoint.x === curr[0] && startPoint.y === curr[1]) {
              continue;
            }

            var cPoint = new Point(curr[0], curr[1]);
            var t = getBezierMonotonicity([startPoint, cPoint, endPoint], true);

            if (t) {
              var points = [[startPoint.x, startPoint.y], [curr[0], curr[1]], [endPoint.x, endPoint.y]];
              var curve1 = bezier$1.sliceBezier(points, t[0]);
              var curve2 = bezier$1.sliceBezier2Both(points, t[0], 1);
              var p1 = new Point(curve1[1]),
                  p2 = new Point(curve1[2]),
                  p3 = new Point(curve2[1]);

              var _coords = Point.compare(startPoint, p2) ? [p2, p1, startPoint] : [startPoint, p1, p2];

              segments.push(new Segment(_coords, index));
              _coords = Point.compare(p2, endPoint) ? [endPoint, p3, p2] : [p2, p3, endPoint];
              seg = new Segment(_coords, index);
            } else {
              var _coords2 = Point.compare(startPoint, endPoint) ? [endPoint, cPoint, startPoint] : [startPoint, cPoint, endPoint];

              seg = new Segment(_coords2, index);
            }
          } // 3阶可能有2个单调改变t点
          else if (l === 6) {
            // 降级为2阶曲线
            if (curr[0] === curr[2] && curr[1] === curr[3]) {
              curr.splice(2, 2);
              i--;
              continue;
            } // 长度为0的曲线忽略


            if (startPoint.equal(endPoint) && startPoint.x === curr[0] && startPoint.y === curr[1] && startPoint.x === curr[2] && startPoint.y === curr[3]) {
              continue;
            }

            var cPoint1 = new Point(curr[0], curr[1]),
                cPoint2 = new Point(curr[2], curr[3]);

            var _t = getBezierMonotonicity([startPoint, cPoint1, cPoint2, endPoint], true);

            if (_t) {
              (function () {
                var points = [[startPoint.x, startPoint.y], [curr[0], curr[1]], [curr[2], curr[3]], [endPoint.x, endPoint.y]];
                var lastPoint = startPoint,
                    lastT = 0;

                _t.forEach(function (t) {
                  var curve = bezier$1.sliceBezier2Both(points, lastT, t);
                  var p1 = new Point(curve[1]),
                      p2 = new Point(curve[2]),
                      p3 = new Point(curve[3]);
                  var coords = Point.compare(lastPoint, p3) ? [p3, p2, p1, lastPoint] : [lastPoint, p1, p2, p3];
                  segments.push(new Segment(coords, index));
                  lastT = t;
                  lastPoint = p3;
                });

                var curve = bezier$1.sliceBezier2Both(points, lastT, 1);
                var p1 = new Point(curve[1]),
                    p2 = new Point(curve[2]);
                var coords = Point.compare(lastPoint, endPoint) ? [endPoint, p2, p1, lastPoint] : [lastPoint, p1, p2, endPoint];
                seg = new Segment(coords, index);
              })();
            } else {
              var _coords3 = Point.compare(startPoint, endPoint) ? [endPoint, cPoint2, cPoint1, startPoint] : [startPoint, cPoint1, cPoint2, endPoint];

              seg = new Segment(_coords3, index);
            }
          }

          segments.push(seg); // 终点是下条边的起点

          startPoint = endPoint;
        } // 强制要求闭合，非闭合自动连直线到开始点闭合


        if (!startPoint.equal(firstPoint)) {
          var _coords4 = Point.compare(startPoint, firstPoint) ? [firstPoint, startPoint] : [startPoint, firstPoint];

          segments.push(new Segment(_coords4, index));
        }
      });
      this.segments = segments;
    } // 根据y坐标排序，生成有序线段列表，再扫描求交


    _createClass(Polygon, [{
      key: "selfIntersect",
      value: function selfIntersect() {
        var list = genHashXList(this.segments);
        this.segments = findIntersection(list, false, false, false);
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.segments.map(function (item) {
          return item.toString();
        });
      }
    }, {
      key: "reset",
      value: function reset(index) {
        this.index = index;
        this.segments.forEach(function (seg) {
          seg.belong = index;
          seg.otherCoincide = 0;
          seg.otherFill[0] = seg.otherFill[1] = false;
        });
        return this;
      } // 2个非自交的多边形互相判断相交，依旧是扫描线算法，2个多边形统一y排序，但要分别出属于哪个多边形，因为只和对方测试相交

    }], [{
      key: "intersect2",
      value: function intersect2(polyA, polyB, isIntermediateA, isIntermediateB) {
        if (!polyA.segments.length || !polyB.segments.length) {
          return;
        }

        var list = genHashXList(polyA.segments.concat(polyB.segments));
        var segments = findIntersection(list, true, isIntermediateA, isIntermediateB);
        polyA.segments = segments.filter(function (item) {
          return item.belong === 0;
        });
        polyB.segments = segments.filter(function (item) {
          return item.belong === 1;
        });
      }
      /**
       * 以Bentley-Ottmann算法为原理，为每个顶点设计事件，按x升序、y升序遍历所有顶点的事件
       * 每条线段边有2个顶点即2个事件，左下为start，右上为end
       * 同顶点优先end，start相同则对比线段谁后面的y更小（向量法），其实就是对比非共点部分的y大小
       * 维护一个活跃边列表ael，同样保证x升序、y升序，start事件线段进入ael，end离开
       * ael中相邻的线段说明上下相互接壤，接壤一侧则内外填充性一致
       * 最下面的边（含第一条）可直接得知下方填充性（下面没有了一定是多边形外部），再推测出上方
       * 其余的边根据自己下方相邻即可确定填充性
       */

    }, {
      key: "annotate2",
      value: function annotate2(polyA, polyB, isIntermediateA, isIntermediateB) {
        var list = genHashXYList(polyA.segments.concat(polyB.segments));
        var aelA = [],
            aelB = [],
            hashA = {},
            hashB = {}; // 算法3遍循环，先注释a多边形的边自己内外性，再b的边自己内外性，最后一起注释对方的内外性
        // 因数据结构合在一起，所以2遍循环可以完成，先注释a和b的自己，再一遍对方

        list.forEach(function (item) {
          var isStart = item.isStart,
              seg = item.seg;
          var belong = seg.belong; // 连续操作时，已有的中间结果可以跳过

          if (belong === 0 && isIntermediateA || belong === 1 && isIntermediateB) {
            return;
          }

          var ael = belong === 0 ? aelA : aelB,
              hash = belong === 0 ? hashA : hashB;

          if (isStart) {
            // 自己重合的线段只考虑第一条，其它剔除
            if (seg.myCoincide) {
              var hc = seg.toHash();

              if (hash.hasOwnProperty(hc)) {
                return;
              }

              hash[hc] = true;
            } // console.error(seg.toString(), ael.length)
            // 下面没有线段了，底部边，上方填充下方空白（除非是偶次重复段，上下都空白，奇次和单线相同）


            if (!ael.length) {
              if (seg.myCoincide) {
                seg.myFill[0] = seg.myCoincide % 2 === 0;
              } else {
                seg.myFill[0] = true;
              }

              ael.push(seg);
            } else {
              // 插入到ael正确的位置，按照x升序、y升序
              var len = ael.length,
                  top = ael[len - 1];
              var isAboveLast = segAboveCompare(seg, top); // 比ael栈顶还高在最上方

              if (isAboveLast) {
                seg.myFill[1] = top.myFill[0];

                if (seg.myCoincide) {
                  seg.myFill[0] = seg.myCoincide % 2 === 0 ? !seg.myFill[1] : seg.myFill[1];
                } else {
                  seg.myFill[0] = !seg.myFill[1];
                }

                ael.push(seg);
              } // 不高且只有1个则在最下方
              else if (len === 1) {
                if (seg.myCoincide) {
                  seg.myFill[0] = seg.myCoincide % 2 === 0;
                } else {
                  seg.myFill[0] = true;
                }

                ael.unshift(seg);
              } else {
                // 遍历，尝试对比是否在ael栈中相邻2条线段之间
                for (var i = len - 2; i >= 0; i--) {
                  var curr = ael[i];
                  var isAbove = segAboveCompare(seg, curr);

                  if (isAbove) {
                    seg.myFill[1] = curr.myFill[0];

                    if (seg.myCoincide) {
                      seg.myFill[0] = seg.myCoincide % 2 === 0 ? !seg.myFill[1] : seg.myFill[1];
                    } else {
                      seg.myFill[0] = !seg.myFill[1];
                    }

                    ael.splice(i + 1, 0, seg);
                    break;
                  } else if (i === 0) {
                    if (seg.myCoincide) {
                      seg.myFill[0] = seg.myCoincide % 2 === 0;
                    } else {
                      seg.myFill[0] = true;
                    }

                    ael.unshift(seg);
                  }
                }
              }
            } // console.warn(seg.toString())

          } else {
            var _i = ael.indexOf(seg); // 一般肯定有，重合线段会剔除不进ael


            if (_i > -1) {
              ael.splice(_i, 1);
            }
          }
        }); // 注释对方，除了重合线直接使用双方各自的注释拼接，普通线两边的对方内外性相同，根据是否在里面inside确定结果
        // inside依旧看自己下方的线段上方情况，不同的是要看下方的线和自己belong是否相同，再确定取下方above的值

        var ael = [],
            hash = {};
        list.forEach(function (item) {
          var isStart = item.isStart,
              seg = item.seg;
          var belong = seg.belong;

          if (isStart) {
            // 自重合或者它重合统一只保留第一条线
            if (seg.myCoincide || seg.otherCoincide) {
              var hc = seg.toHash();

              if (hash.hasOwnProperty(hc)) {
                return;
              }

              hash[hc] = true;
            } // console.error(seg.toString(), ael.length)


            var inside = false;

            if (!ael.length) {
              inside = false;
              ael.push(seg);
            } else {
              var len = ael.length,
                  top = ael[len - 1];
              var isAboveLast = segAboveCompare(seg, top);

              if (isAboveLast) {
                if (top.belong === belong) {
                  inside = top.otherFill[0];
                } else {
                  inside = top.myFill[0];
                }

                ael.push(seg);
              } else if (len === 1) {
                // inside = false;
                ael.unshift(seg);
              } else {
                for (var i = len - 2; i >= 0; i--) {
                  var curr = ael[i];
                  var isAbove = segAboveCompare(seg, curr);

                  if (isAbove) {
                    // 如果在自己的下方线和自己同色，则取下方线的另外色上填充
                    if (curr.belong === belong) {
                      inside = curr.otherFill[0];
                    } // 否则取下方线的下方色上填充
                    else {
                      inside = curr.myFill[0];
                    }

                    ael.splice(i + 1, 0, seg);
                    break;
                  } else if (i === 0) {
                    // inside = false;
                    ael.unshift(seg);
                  }
                }
              }
            } // 重合线的otherFill直接引用指向对方myFill，不能普通计算


            if (!seg.otherCoincide) {
              seg.otherFill[0] = inside;
              seg.otherFill[1] = inside;
            } // console.warn(seg.toString(), inside)

          } else {
            var _i2 = ael.indexOf(seg);

            if (_i2 > -1) {
              ael.splice(_i2, 1);
            }
          }
        });
      }
    }]);

    return Polygon;
  }();

  function findIntersection(list, compareBelong, isIntermediateA, isIntermediateB) {
    // 从左到右扫描，按x坐标排序，相等按y，边会进入和离开扫描线各1次，在扫描线中的边为活跃边，维护1个活跃边列表，新添加的和老的求交
    var ael = [],
        delList = [],
        segments = [];

    while (list.length) {
      if (delList.length) {
        delList.splice(0).forEach(function (seg) {
          var i = ael.indexOf(seg);
          ael.splice(i, 1);

          if (!seg.isDeleted) {
            segments.push(seg);
          }
        });
      }

      var _list$ = list[0],
          x = _list$.x,
          arr = _list$.arr;

      while (arr.length) {
        var seg = arr.shift(); // 被切割的老线段无效

        if (seg.isDeleted) {
          continue;
        }

        var belong = seg.belong,
            bboxA = seg.bbox; // 第2次访问边是离开活动，考虑删除

        if (seg.isVisited) {
          // console.warn(x, seg.toString());
          // console.log(ael.map(item => item.toString()));
          // 可能是垂线不能立刻删除，所以等到下次活动x再删除，因为会出现极端情况刚进来就出去，和后面同y的重合
          if (bboxA[0] !== bboxA[2] || seg.coords.length !== 2) {
            var i = ael.indexOf(seg);
            ael.splice(i, 1);

            if (!seg.isDeleted) {
              segments.push(seg);
            }
          } else {
            delList.push(seg);
          }

          seg.isVisited = false; // 还原以备后面逻辑重复利用
          // console.log(ael.map(item => item.toString()));
        } // 第1次访问边一定是进入活动，求交
        else {
          // console.error(x, seg.toString(), ael.length);
          // console.log(ael.map(item => item.toString()));
          // 和asl里的边求交，如果被分割，新生成的存入asl和hash，老的线段无需再进入asl
          if (ael.length) {
            var coordsA = seg.coords,
                lenA = coordsA.length;
            var _coordsA$ = coordsA[0],
                ax1 = _coordsA$.x,
                ay1 = _coordsA$.y;
            var _coordsA$2 = coordsA[1],
                ax2 = _coordsA$2.x,
                ay2 = _coordsA$2.y;

            for (var _i3 = 0; _i3 < ael.length; _i3++) {
              var item = ael[_i3]; // 被切割的老线段无效，注意seg切割过程中可能变成删除

              if (item.isDeleted || seg.isDeleted) {
                continue;
              } // 互交所属belong不同才进行检测，自交则不检查belong


              if (compareBelong && item.belong === belong) {
                continue;
              } // bbox相交才考虑真正计算，加速


              var bboxB = item.bbox,
                  coordsB = item.coords,
                  lenB = coordsB.length;
              var isSourceReverted = false; // 求交可能a、b线主从互换

              if (isRectsOverlap(bboxA, bboxB, lenA, lenB)) {
                // 完全重合简化，同矩形的线myFill共享，对方矩形互换otherFill
                if (lenA === lenB && seg.equal(item)) {
                  if (compareBelong) {
                    // 因为一定不自交，所以重合线不会被分割
                    seg.otherCoincide++;
                    item.otherCoincide++;
                    seg.otherFill = item.myFill;
                    item.otherFill = seg.myFill;
                  } else {
                    seg.myCoincide++;
                    item.myCoincide++;
                    seg.myFill = item.myFill;
                  }

                  continue;
                }

                var _coordsB$ = coordsB[0],
                    bx1 = _coordsB$.x,
                    by1 = _coordsB$.y;
                var _coordsB$2 = coordsB[1],
                    bx2 = _coordsB$2.x,
                    by2 = _coordsB$2.y;
                var inters = void 0,
                    overs = void 0; // a是直线

                if (lenA === 2) {
                  // b是直线
                  if (lenB === 2) {
                    var d = (by2 - by1) * (ax2 - ax1) - (bx2 - bx1) * (ay2 - ay1); // 平行检查是否重合，否则求交

                    if (d === 0) {
                      // 垂线特殊，y=kx+b没法求
                      if (ax1 === ax2) {
                        if (ax1 === bx1 && ax2 === bx2) {
                          overs = checkOverlapLine(ax1, ay1, ax2, ay2, seg, bx1, by1, bx2, by2, item, true);
                        }
                      } else {
                        var b1 = (ay2 - ay1) * ax1 / (ax2 - ax1) + ay1;
                        var b2 = (by2 - by1) * bx1 / (bx2 - bx1) + by1;

                        if (b1 === b2) {
                          overs = checkOverlapLine(ax1, ay1, ax2, ay2, seg, bx1, by1, bx2, by2, item, false);
                        }
                      }
                    } else {
                      inters = getIntersectionLineLine(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2, d);
                    }
                  } // b是曲线
                  else {
                    var _coordsB$3 = coordsB[2],
                        bx3 = _coordsB$3.x,
                        by3 = _coordsB$3.y; // b是2阶曲线

                    if (lenB === 3) {
                      inters = getIntersectionBezier2Line(bx1, by1, bx2, by2, bx3, by3, ax1, ay1, ax2, ay2);
                      isSourceReverted = true;
                    } // b是3阶曲线
                    else {
                      var _coordsB$4 = coordsB[3],
                          bx4 = _coordsB$4.x,
                          by4 = _coordsB$4.y;
                      inters = getIntersectionBezier3Line(bx1, by1, bx2, by2, bx3, by3, bx4, by4, ax1, ay1, ax2, ay2);
                      isSourceReverted = true;
                    }
                  }
                } // a是曲线
                else {
                  var _coordsA$3 = coordsA[2],
                      ax3 = _coordsA$3.x,
                      ay3 = _coordsA$3.y; // a是2阶曲线

                  if (lenA === 3) {
                    // b是直线
                    if (lenB === 2) {
                      inters = getIntersectionBezier2Line(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2);
                    } // b是曲线
                    else {
                      var _coordsB$5 = coordsB[2],
                          _bx = _coordsB$5.x,
                          _by = _coordsB$5.y; // b是2阶曲线

                      if (lenB === 3) {
                        inters = getIntersectionBezier2Bezier2(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, _bx, _by);

                        if (!inters) {
                          overs = checkOverlapBezier(seg, item);
                        }
                      } // b是3阶曲线
                      else {
                        var _coordsB$6 = coordsB[3],
                            _bx2 = _coordsB$6.x,
                            _by2 = _coordsB$6.y;
                        inters = getIntersectionBezier2Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, bx1, by1, bx2, by2, _bx, _by, _bx2, _by2);
                      }
                    }
                  } // a是3阶曲线
                  else {
                    var _coordsA$4 = coordsA[3],
                        ax4 = _coordsA$4.x,
                        ay4 = _coordsA$4.y; // b是直线

                    if (lenB === 2) {
                      inters = getIntersectionBezier3Line(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2);
                    } // b是曲线
                    else {
                      var _coordsB$7 = coordsB[2],
                          _bx3 = _coordsB$7.x,
                          _by3 = _coordsB$7.y; // b是2阶曲线

                      if (lenB === 3) {
                        inters = getIntersectionBezier2Bezier3(bx1, by1, bx2, by2, _bx3, _by3, ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4);
                        isSourceReverted = true;
                      } // b是3阶曲线
                      else {
                        var _coordsB$8 = coordsB[3],
                            _bx4 = _coordsB$8.x,
                            _by4 = _coordsB$8.y;
                        inters = getIntersectionBezier3Bezier3(ax1, ay1, ax2, ay2, ax3, ay3, ax4, ay4, bx1, by1, bx2, by2, _bx3, _by3, _bx4, _by4);

                        if (!inters) {
                          overs = checkOverlapBezier(seg, item);
                        }
                      }
                    }
                  }
                } // 有重合的，重合线段已经求好，直接使用


                if (overs) {
                  activeNewSeg(segments, list, ael, x, overs.ra);
                  activeNewSeg(segments, list, ael, x, overs.rb);
                  seg.isDeleted = item.isDeleted = true;
                  ael.splice(_i3, 1);
                  break;
                } // 有交点，确保原先线段方向顺序（x升序、y升序），各自依次切割，x右侧新线段也要存入list
                else if (inters && inters.length) {
                  // console.log('inters', i, inters);
                  var pa = sortIntersection(inters, !isSourceReverted); // console.log(pa);

                  var ra = sliceSegment(seg, pa, isIntermediateA && belong === 0); // console.log(ra.map(item => item.toString()));

                  var pb = sortIntersection(inters, isSourceReverted); // console.log(pb);

                  var rb = sliceSegment(item, pb, isIntermediateB && belong === 1); // console.log(rb.map(item => item.toString()));
                  // 新切割的线段继续按照坐标存入列表以及ael，为后续求交

                  activeNewSeg(segments, list, ael, x, ra);
                  activeNewSeg(segments, list, ael, x, rb); // 老的线段被删除无效了，踢出ael，防止seg没被分割

                  if (rb.length) {
                    ael.splice(_i3, 1);
                  }

                  break;
                }
              }
            }
          } // 不相交切割才进入ael


          if (!seg.isDeleted) {
            ael.push(seg);
            seg.isVisited = true;
          } // console.log(ael.map(item => item.toString()));

        }
      }

      list.shift();
    } // 最后面的线


    delList.forEach(function (seg) {
      if (!seg.isDeleted) {
        segments.push(seg);
      }
    }); // 最后再过滤一遍，因为新生成的切割线可能会被再次切割变成删除的无效线段

    return segments.filter(function (item) {
      return !item.isDeleted;
    });
  } // 给定交点列表分割线段，ps需排好顺序从头到尾，isSelf标明是否自相交阶段，false是和对方交点切割


  function sliceSegment(seg, ps, isIntermediate) {
    var res = [];

    if (!ps.length) {
      return res;
    }

    var belong = seg.belong,
        coords = seg.coords,
        len = coords.length;
    var startPoint = coords[0];
    var lastT = 0; // 多个点可能截取多条，最后一条保留只修改数据，其它新生成

    ps.forEach(function (item) {
      var point = item.point,
          t = item.t;
      var ns;

      if (len === 2) {
        ns = new Segment([startPoint, point], belong);
      } else if (len === 3) {
        var c = bezier$1.sliceBezier2Both(coords.map(function (item) {
          return [item.x, item.y];
        }), lastT, t);
        ns = new Segment([startPoint, new Point(c[1][0], c[1][1]), point], belong);
      } else if (len === 4) {
        var _c = bezier$1.sliceBezier2Both(coords.map(function (item) {
          return [item.x, item.y];
        }), lastT, t);

        ns = new Segment([startPoint, new Point(_c[1][0], _c[1][1]), new Point(_c[2][0], _c[2][1]), point], belong);
      } // 连续操作的中间结果已有自己内外性，截取时需继承


      if (isIntermediate) {
        ns.myFill[0] = seg.myFill[0];
        ns.myFill[1] = seg.myFill[1];
      }

      startPoint = point;
      res.push(ns);
      lastT = t;
    }); // 最后一条

    var ns;

    if (len === 2) {
      ns = new Segment([startPoint, coords[1]], belong);
    } else if (len === 3) {
      var c = bezier$1.sliceBezier2Both(coords.map(function (item) {
        return [item.x, item.y];
      }), lastT, 1);
      ns = new Segment([startPoint, new Point(c[1][0], c[1][1]), coords[2]], belong);
    } else if (len === 4) {
      var _c2 = bezier$1.sliceBezier2Both(coords.map(function (item) {
        return [item.x, item.y];
      }), lastT, 1);

      ns = new Segment([startPoint, new Point(_c2[1][0], _c2[1][1]), new Point(_c2[2][0], _c2[2][1]), coords[3]], belong);
    }

    if (isIntermediate) {
      ns.myFill[0] = seg.myFill[0];
      ns.myFill[1] = seg.myFill[1];
    }

    res.push(ns); // 老的打标失效删除

    seg.isDeleted = true;
    return res;
  } // 相交的线段slice成多条后，老的删除，新的考虑添加进扫描列表和活动边列表，根据新的是否在范围内


  function activeNewSeg(segments, list, ael, x, ns) {
    ns.forEach(function (seg) {
      var bbox = seg.bbox,
          x1 = bbox[0],
          x2 = bbox[2]; // console.log(seg.toString(), x1, x2, x);
      // 活跃x之前无相交判断意义，除了竖线，出现活跃前只可能一方为竖线截断另一方的左边部分

      if (x2 <= x && x1 !== x2 && seg.coords.length !== 2) {
        segments.push(seg);
        return;
      } // 按顺序放在list的正确位置，可能x1已经过去不需要加入了，但要考虑ael


      var i = 0;

      if (x1 < x) {
        seg.isVisited = true;
        ael.push(seg);
      } else {
        for (var len = list.length; i < len; i++) {
          var item = list[i];
          var lx = item.x;

          if (x1 === lx) {
            item.arr.push(seg);
            break;
          } // 新的插入


          if (x1 < lx) {
            var temp = {
              x: x1,
              arr: [seg]
            };
            list.splice(i, 0, temp);
            break;
          }
        }
      } // x2一定会加入


      for (var _len = list.length; i < _len; i++) {
        var _item = list[i];
        var _lx = _item.x;

        if (x2 === _lx) {
          // 访问过的尽可能排在前面早出栈，减少对比次数
          _item.arr.unshift(seg);

          break;
        }

        if (x2 < _lx) {
          var _temp = {
            x: x2,
            arr: [seg]
          };
          list.splice(i, 0, _temp);
          break;
        }
      }
    });
  } // 按x升序将所有线段组成一个垂直扫描线列表，求交用，y方向不用管


  function genHashXList(segments) {
    var hashX = {};
    segments.forEach(function (seg) {
      var bbox = seg.bbox,
          min = bbox[0],
          max = bbox[2];
      putHashX(hashX, min, seg);
      putHashX(hashX, max, seg);
    });
    var list = [];
    Object.keys(hashX).forEach(function (x) {
      return list.push({
        x: parseFloat(x),
        arr: hashX[x]
      });
    });
    return list.sort(function (a, b) {
      return a.x - b.x;
    });
  } // 每个线段会放2次，开始点和结束点，哪怕x相同，第1次是开始用push，第2次结束unshift，这样离开时排在前面


  function putHashX(hashX, x, seg) {
    var list = hashX[x] = hashX[x] || [];

    if (seg.isVisited) {
      list.unshift(seg);
      seg.isVisited = false;
    } else {
      list.push(seg);
      seg.isVisited = true;
    }
  } // 按x升序将所有线段组成一个垂直扫描线列表，y方向也需要判断


  function genHashXYList(segments) {
    var hashXY = {};
    segments.forEach(function (seg) {
      var coords = seg.coords,
          l = coords.length;
      var start = coords[0],
          end = coords[l - 1];
      putHashXY(hashXY, start.x, start.y, seg, true);
      putHashXY(hashXY, end.x, end.y, seg, false);
    });
    var listX = [];
    Object.keys(hashXY).forEach(function (x) {
      var hashY = hashXY[x];
      var listY = [];
      Object.keys(hashY).forEach(function (y) {
        var arr = hashY[y].sort(function (a, b) {
          // end优先于start先触发
          if (a.isStart !== b.isStart) {
            return a.isStart ? 1 : -1;
          } // start点相同看谁在上谁在下，下方在前，比y极大值，因为start相同又不相交，所以上方的y极值更大


          if (a.isStart) {
            return segAboveCompare(a.seg, b.seg) ? 1 : -1;
          } // end点相同无所谓，其不参与运算，因为每次end线段先出栈ael

        }); // console.log(x, y, arr.map(item => item.isStart + ', ' + item.seg.toString()));

        listY.push({
          y: parseFloat(y),
          arr: arr
        });
      });
      listX.push({
        x: parseFloat(x),
        arr: listY.sort(function (a, b) {
          return a.y - b.y;
        })
      });
    });
    listX.sort(function (a, b) {
      return a.x - b.x;
    });
    var list = [];
    listX.forEach(function (item) {
      item.arr.forEach(function (item) {
        list = list.concat(item.arr);
      });
    });
    return list;
  }

  function putHashXY(hashXY, x, y, seg, isStart) {
    var hash = hashXY[x] = hashXY[x] || {};
    var list = hash[y] = hash[y] || [];
    list.push({
      isStart: isStart,
      seg: seg
    });
  } // pt在线段left -> right的上方或线上


  function pointAboveOrOnLine(pt, left, right) {
    var x = pt.x,
        y = pt.y;
    var x1 = left.x,
        y1 = left.y;
    var x2 = right.x,
        y2 = right.y;
    return vector.crossProduct(x1 - x, y1 - y, x2 - x, y2 - y) >= 0;
  } // a是否在b的上边，取x相同部分看y大小，只有start点事件时才判断


  function segAboveCompare(segA, segB) {
    var ca = segA.coords,
        cb = segB.coords;
    var la = ca.length,
        lb = cb.length;
    var a1 = ca[0],
        b1 = cb[0]; // 两条直线用向量积判断，注意开始点是否相同即可

    if (la === 2 && lb === 2) {
      var a2 = ca[1],
          b2 = cb[1];

      if (a1.equal(b1)) {
        return pointAboveOrOnLine(a2, b1, b2);
      } else {
        return pointAboveOrOnLine(a1, b1, b2);
      }
    } // a是竖线的话看另一条在左还是右，左的话a在下，否则在上，因为此时只可能是左和a尾相连或右和a首相连


    if (la === 2 && a1.x === ca[1].x) {
      return b1.x >= a1.x;
    } // 如果有曲线，取二者x共同的区域部分[x1, x3]，以及区域中点x2，这3个点不可能都重合，一定会有某点的y比较大小


    var x1 = Math.max(a1.x, b1.x),
        x3 = Math.min(ca[la - 1].x, cb[lb - 1].x),
        x2 = x1 + (x3 - x1) * 0.5;

    if (a1 !== b1) {
      var _y = getYByX(ca, x1),
          _y2 = getYByX(cb, x1);

      if (_y !== _y2) {
        return _y > _y2;
      }
    }

    if (ca[la - 1] !== cb[lb - 1]) {
      var _y3 = getYByX(ca, x3),
          _y4 = getYByX(cb, x3);

      if (_y3 !== _y4) {
        return _y3 > _y4;
      }
    }

    var y1 = getYByX(ca, x2),
        y2 = getYByX(cb, x2);

    if (y1 !== y2) {
      return y1 > y2;
    }
  } // 获取曲线单调性t值，有结果才返回


  function getBezierMonotonicity(coords, isX) {
    if (coords.length === 3) {
      var t = isX ? (coords[0].x - coords[1].x) / (coords[0].x - 2 * coords[1].x + coords[2].x) : (coords[0].y - coords[1].y) / (coords[0].y - 2 * coords[1].y + coords[2].y);

      if (t > 0 && t < 1) {
        return [t];
      }
    } else if (coords.length === 4) {
      var _t2 = equation.getRoots([isX ? 3 * (coords[1].x - coords[0].x) : 3 * (coords[1].y - coords[0].y), isX ? 6 * (coords[2].x + coords[0].x - 2 * coords[1].x) : 6 * (coords[2].y + coords[0].y - 2 * coords[1].y), isX ? 3 * (coords[3].x + 3 * coords[1].x - coords[0].x - 3 * coords[2].x) : 3 * (coords[3].y + 3 * coords[1].y - coords[0].y - 3 * coords[2].y)]).filter(function (i) {
        return i > 0 && i < 1;
      });

      if (_t2.length) {
        return _t2.sort(function (a, b) {
          return a - b;
        });
      }
    }
  } // 根据x的值解得t后获取y，由于线段已经x单调，所以解只会有1个而非多个


  function getYByX(coords, x) {
    var len = coords.length;

    if (x === coords[0].x) {
      return coords[0].y;
    }

    if (x === coords[len - 1].x) {
      return coords[len - 1].y;
    }

    if (len === 2) {
      if (coords[0].y === coords[1].y) {
        return coords[0].y;
      }

      var p = (x - coords[0].x) / (coords[1].x - coords[0].x);
      return coords[0].y + p * (coords[1].y - coords[0].y);
    } else if (len === 3) {
      var t = equation.getRoots([coords[0].x - x, 2 * (coords[1].x - coords[0].x), coords[2].x + coords[0].x - 2 * coords[1].x]).filter(function (i) {
        return i >= 0 && i <= 1;
      });
      var pts = coords.map(function (item) {
        return [item.x, item.y];
      });
      return bezier$1.pointAtByT(pts, t[0])[1];
    } else if (len === 4) {
      var _t3 = equation.getRoots([coords[0].x - x, 3 * (coords[1].x - coords[0].x), 3 * (coords[2].x + coords[0].x - 2 * coords[1].x), coords[3].x + 3 * coords[1].x - coords[0].x - 3 * coords[2].x]).filter(function (i) {
        return i >= 0 && i <= 1;
      });

      var _pts = coords.map(function (item) {
        return [item.x, item.y];
      });

      return bezier$1.pointAtByT(_pts, _t3[0])[1];
    }
  }

  function isRectsOverlap(bboxA, bboxB, lenA, lenB) {
    if (lenA === 2 && lenB === 2) {
      // 2条垂线特殊考虑，此时x范围都是0，只能比较y
      if (bboxA[0] === bboxA[2] && bboxB[0] === bboxB[2] && bboxA[0] === bboxA[2]) {
        if (bboxA[1] >= bboxB[3] || bboxB[1] >= bboxA[3]) {
          return false;
        }

        return true;
      } // 2条水平线也是


      if (bboxA[1] === bboxA[3] && bboxB[1] === bboxB[3] && bboxA[1] === bboxA[1]) {
        if (bboxA[0] >= bboxB[2] || bboxB[0] >= bboxA[2]) {
          return false;
        }

        return true;
      }
    }

    return geom$1.isRectsOverlap(bboxA, bboxB);
  }

  function checkOverlapLine(ax1, ay1, ax2, ay2, segA, bx1, by1, bx2, by2, segB, isY) {
    var ra = [],
        rb = [];
    var coordsA = segA.coords,
        coordsB = segB.coords;

    if (ax1 < bx1 && !isY || ay1 < by1 && isY) {
      ra.push(new Segment([coordsA[0], coordsB[0]], segA.belong));

      if (ax2 < bx2 && !isY || ay2 < by2 && isY) {
        ra.push(new Segment([coordsB[0], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsB[0], coordsA[1]], segB.belong));
        rb.push(new Segment([coordsA[1], coordsB[1]], segB.belong));
      } else if (ax2 === bx2 && !isY || ay2 === by2 && isY) {
        ra.push(new Segment([coordsB[0], coordsB[1]], segA.belong));
        rb.push(new Segment([coordsB[0], coordsB[1]], segB.belong));
      } else {
        ra.push(new Segment([coordsB[0], coordsB[1]], segA.belong));
        rb.push(new Segment([coordsB[0], coordsB[1]], segB.belong));
        ra.push(new Segment([coordsB[1], coordsA[1]], segA.belong));
      }
    } // 不会出现完全重合即ax2 == bx2
    else if (ax1 === bx1 && !isY || ay1 === by1 && isY) {
      if (ax2 < bx2 && !isY || ay2 < by2 && isY) {
        ra.push(new Segment([coordsA[0], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsA[0], coordsA[1]], segB.belong));
        rb.push(new Segment([coordsA[1], coordsB[1]], segB.belong));
      } else {
        ra.push(new Segment([coordsB[0], coordsB[1]], segA.belong));
        ra.push(new Segment([coordsB[1], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsB[0], coordsB[1]], segB.belong));
      }
    } // ax1 > bx1
    else {
      rb.push(new Segment([coordsB[0], coordsA[0]], segB.belong));

      if (ax2 < bx2 && !isY || ay2 < by2 && isY) {
        ra.push(new Segment([coordsA[0], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsA[0], coordsA[1]], segB.belong));
        rb.push(new Segment([coordsA[1], coordsB[1]], segB.belong));
      } else if (ax2 === bx2 && !isY || ay2 === by2 && isY) {
        ra.push(new Segment([coordsA[0], coordsA[1]], segA.belong));
        rb.push(new Segment([coordsA[0], coordsA[1]], segB.belong));
      } else {
        ra.push(new Segment([coordsA[0], coordsB[1]], segA.belong));
        rb.push(new Segment([coordsA[0], coordsB[1]], segB.belong));
        ra.push(new Segment([coordsB[1], coordsA[1]], segA.belong));
      }
    }

    return {
      ra: ra,
      rb: rb
    };
  }

  function checkOverlapBezier(segA, segB) {
    var ca = segA.coords.map(function (item) {
      return [item.x, item.y];
    }),
        la = ca.length;
    var cb = segB.coords.map(function (item) {
      return [item.x, item.y];
    }),
        lb = cb.length;
    var firstA = ca[0],
        firstB = cb[0],
        lastA = ca[la - 1],
        lastB = cb[lb - 1];
    var t1 = bezier$1.getPointT(ca, firstB[0], firstB[1]);
    var t2 = bezier$1.getPointT(ca, lastB[0], lastB[1]);
    var t3 = bezier$1.getPointT(cb, firstA[0], firstA[1]);
    var t4 = bezier$1.getPointT(cb, lastA[0], lastA[1]); // console.warn(segA.toString());console.warn(segB.toString());
    // console.log(t1, t2, t3, t4);

    var l1 = t1.length,
        l2 = t2.length,
        l3 = t3.length,
        l4 = t4.length;
    /**
     * 重合有3种情况，对应4个t（每方各2个）的情况不同：
     * a. 一个包含另外一个，这样其中一方t为空，另一方t为2个即两个端点各1
     * b. 一对端点重合另外一侧包含，比上面的t多1个即空的那方t多1
     * c. 普通部分重合，每方各有1个t
     */

    var conditionA = l1 === 1 && l2 === 1 && l3 === 0 && l4 === 0 || l1 === 0 && l2 === 0 && l3 === 1 && l4 === 1;
    var conditionB = l1 === 1 && l2 === 1 && l3 + l4 === 1 || l1 + l2 === 1 && l3 === 1 && l4 === 1;
    var conditionC = l1 + l2 === 1 && l3 + l4 === 1;

    if (conditionA || conditionB || conditionC) {
      var startA = l1 ? t1[0] : 0;
      var endA = l2 ? t2[0] : 1;
      var a = bezier$1.sliceBezier2Both(ca, startA, endA);
      var startB = l3 ? t3[0] : 0;
      var endB = l4 ? t4[0] : 1;
      var b = bezier$1.sliceBezier2Both(cb, startB, endB); // console.log(startA, endA, startB, endB);
      // 确定重合之后就是截取，重合一定出现在左右的中间部分，这样只要分别判断左右两端是否需要各自裁剪即可

      if (equalBezier(a, b)) {
        var over = a.map(function (item) {
          return new Point(item);
        }); // console.log(over);

        var ra = [],
            rb = [];

        if (startA > 0) {
          var s = bezier$1.sliceBezier2Both(ca, 0, startA);
          var arr = [segA.coords[0], new Point(s[1]), segB.coords[0]];

          if (la === 4) {
            arr.splice(2, 0, new Point(s[2]));
          }

          ra.push(new Segment(arr, segA.belong));
        }

        ra.push(new Segment(over, segA.belong)); // 重合的部分

        if (endA < 1) {
          var _s = bezier$1.sliceBezier2Both(ca, endA, 1);

          var _arr = [segB.coords[lb - 1], new Point(_s[1]), segA.coords[la - 1]];

          if (la === 4) {
            _arr.splice(2, 0, new Point(_s[2]));
          }

          ra.push(new Segment(_arr, segA.belong));
        }

        if (startB > 0) {
          var _s2 = bezier$1.sliceBezier2Both(cb, 0, startB);

          var _arr2 = [segB.coords[0], new Point(_s2[1]), segA.coords[0]];

          if (lb === 4) {
            _arr2.splice(2, 0, new Point(_s2[2]));
          }

          rb.push(new Segment(_arr2, segB.belong));
        }

        rb.push(new Segment(over, segB.belong)); // 重合的部分

        if (endB < 1) {
          var _s3 = bezier$1.sliceBezier2Both(cb, endB, 1);

          var _arr3 = [segA.coords[la - 1], new Point(_s3[1]), segB.coords[lb - 1]];

          if (lb === 4) {
            _arr3.splice(2, 0, new Point(_s3[2]));
          }

          rb.push(new Segment(_arr3, segB.belong));
        } // console.log(ra.map(item => item.toString()));
        // console.log(rb.map(item => item.toString()));


        return {
          ra: ra,
          rb: rb
        };
      }
    }
  }

  function equalBezier(a, b) {
    for (var i = 0, len = a.length; i < len; i++) {
      var ai = a[i],
          bi = b[i];

      if (Math.abs(ai[0] - bi[0]) > 1e-9 || Math.abs(ai[1] - bi[1]) > 1e-9) {
        return false;
      }
    }

    return true;
  }

  function join(res, chains, chain, index, pt, isHead) {
    for (var i = 0, len = chains.length; i < len; i++) {
      var item = chains[i];

      if (item !== chain) {
        var l = item.length;
        var head = item[0],
            tail = item[l - 1];
        var ptHead = head.coords[0];
        var coords = tail.coords,
            l2 = coords.length;
        var ptTail = coords[l2 - 1];

        if (pt.equal(ptHead)) {
          if (isHead) {
            item = reverse(chain).concat(item);
            chains[i] = item;
            chains.splice(index, 1);
            return close(res, chains, item, i);
          } else {
            item = chain.concat(item);
            chains[i] = item;
            chains.splice(index, 1);
            return close(res, chains, item, i);
          }
        } else if (pt.equal(ptTail)) {
          if (isHead) {
            item = item.concat(chain);
            chains[i] = item;
            chains.splice(index, 1);
            return close(res, chains, item, i);
          } else {
            item = item.concat(reverse(chain));
            chains[i] = item;
            chains.splice(index, 1);
            return close(res, chains, item, i);
          }
        }
      }
    } // 无法和别的链接，也要检查自身闭合


    close(res, chains, chain, index);
  }

  function close(res, chains, chain, index) {
    var l = chain.length;
    var head = chain[0],
        tail = chain[l - 1];
    var ptHead = head.coords[0];
    var coords2 = tail.coords,
        l2 = coords2.length;
    var ptTail = coords2[l2 - 1];

    if (ptHead.equal(ptTail)) {
      chains.splice(index, 1);
      res.push(chain);
    }
  } // 整条链颠倒，包含每个线段自身颠倒


  function reverse(chain) {
    chain.forEach(function (item) {
      return item.reverse();
    });
    return chain.reverse();
  }

  function _chain (list) {
    var chains = [],
        res = []; // 在对方内部的排在前面，这样会优先形成包含情况而不是交叉

    list.sort(function (a, b) {
      if (b.otherFill[0] && b.otherFill[1]) {
        return 1;
      }

      return -1;
    });

    outer: while (list.length) {
      var seg = list.shift(),
          coords = seg.coords,
          len = coords.length;
      var start = coords[0],
          end = coords[len - 1];
      var temp = void 0; // 尝试追加到某条链中，互相头尾链接可能有4种情况，其中2种会reverse线段首尾

      for (var i = 0, _len = chains.length; i < _len; i++) {
        var chain = chains[i],
            l = chain.length;
        var head = chain[0],
            tail = chain[l - 1];
        var ptHead = head.coords[0];
        var coords2 = tail.coords,
            l2 = coords2.length;
        var ptTail = coords2[l2 - 1];

        if (start.equal(ptTail)) {
          if (seg.belong !== tail.belong) {
            chain.push(seg);
            join(res, chains, chain, i, end, false);
            continue outer;
          } else if (!temp) {
            temp = {
              i: i,
              t: 0
            };
          }
        } else if (start.equal(ptHead)) {
          if (seg.belong !== tail.belong) {
            seg.reverse();
            chain.unshift(seg);
            join(res, chains, chain, i, end, true);
            continue outer;
          } else if (!temp) {
            temp = {
              i: i,
              t: 1
            };
          }
        } else if (end.equal(ptTail)) {
          if (seg.belong !== tail.belong) {
            seg.reverse();
            chain.push(seg);
            join(res, chains, chain, i, start, false);
            continue outer;
          } else if (!temp) {
            temp = {
              i: i,
              t: 2
            };
          }
        } else if (end.equal(ptHead)) {
          if (seg.belong !== tail.belong) {
            chain.unshift(seg);
            join(res, chains, chain, i, start, true);
            continue outer;
          } else if (!temp) {
            temp = {
              i: i,
              t: 3
            };
          }
        }
      } // 如果没有优先添加对方的线段形成包含，则到这里检查是否有己方的进行链接


      if (temp) {
        if (temp.t === 0) {
          chains[temp.i].push(seg);
          join(res, chains, chains[temp.i], temp.i, end, false);
        } else if (temp.t === 1) {
          seg.reverse();
          chains[temp.i].unshift(seg);
          join(res, chains, chains[temp.i], temp.i, end, true);
        } else if (temp.t === 2) {
          seg.reverse();
          chains[temp.i].push(seg);
          join(res, chains, chains[temp.i], temp.i, start, false);
        } else if (temp.t === 3) {
          chains[temp.i].unshift(seg);
          join(res, chains, chains[temp.i], temp.i, start, true);
        }
      } // 找不到则生成新链
      else {
        chains.push([seg]);
      }
    } // 鞋带公式求得每个多边形的时钟序  https://zhuanlan.zhihu.com/p/401010594


    var v = res.map(function (item) {
      // let isInner = true, isOuter = true;
      var clockwise = true;
      var s = 0,
          lastX,
          lastY,
          minX,
          minY,
          maxX,
          maxY;
      item.forEach(function (seg, i) {
        // 内部是指边的两侧都是对方填充说明在内部
        // if(!seg.otherFill[0] || !seg.otherFill[1]) {
        //   isInner = false;
        // }
        // // 外部是指边的一侧为空
        // if(!seg.myFill[0] && !seg.otherFill[0] || !seg.myFill[1] && !seg.otherFill[1]) {}
        // else {
        //   isOuter = false;
        // }
        var coords = seg.coords,
            len = coords.length,
            bbox = seg.bbox;

        if (i) {
          minX = Math.min(minX, bbox[0]);
          minY = Math.min(minY, bbox[1]);
          maxX = Math.max(maxX, bbox[2]);
          maxY = Math.max(maxY, bbox[3]);
        } else {
          minX = bbox[0];
          minY = bbox[1];
          maxX = bbox[2];
          maxY = bbox[3];
        }

        if (len === 2) {
          if (i) {
            s += lastX * coords[1].y - lastY * coords[1].x;
          } else {
            s += coords[0].x * coords[1].y - coords[0].y * coords[1].x;
          }

          lastX = coords[1].x;
          lastY = coords[1].y;
        } else if (len === 3) {
          if (i) {
            s += lastX * coords[2].y - lastY * coords[2].x;
          } else {
            s += coords[0].x * coords[1].y - coords[0].y * coords[2].x;
          }

          lastX = coords[2].x;
          lastY = coords[2].y;
        } else if (len === 4) {
          if (i) {
            s += lastX * coords[3].y - lastY * coords[3].x;
          } else {
            s += coords[0].x * coords[3].y - coords[0].y * coords[3].x;
          }

          lastX = coords[3].x;
          lastY = coords[3].y;
        }
      }); // 首个顶点重合

      var first = item[0],
          coords = first.coords;
      s += lastX * coords[0].y - lastY * coords[0].x;

      if (s < 0) {
        clockwise = false;
      }

      return {
        // isInner,
        // isOuter,
        list: item,
        clockwise: clockwise,
        bbox: [minX, minY, maxX, maxY],
        area: (maxX - minX) * (maxY - minY)
      };
    });
    v.forEach(function (item) {
      if (item.checked) {
        return;
      }

      var bbox = item.bbox;
      var list = [item];

      for (var _i = 0, _len2 = v.length; _i < _len2; _i++) {
        var item2 = v[_i];

        if (item2 !== item) {
          // 互相包含则存入列表
          if (geom$1.isRectsInside(bbox, item2.bbox, true) || geom$1.isRectsInside(item2.bbox, bbox, true)) {
            list.push(item2);
          }
        }
      } // 按面积排序，最小的即最里面的在前面


      if (list.length > 1) {
        list.sort(function (a, b) {
          return a.area - b.area;
        }); // 可能存在已经排过序的，例如外围a包含了内部的b和c，b和c互不相交，a和b已经调整过排序了，a和c再调整则a已经checked

        for (var _i2 = 1, _len3 = list.length; _i2 < _len3; _i2++) {
          var _item = list[_i2];

          if (_item.checked) {
            var _clockwise = _item.clockwise;

            for (var j = _i2 - 1; j >= 0; j--) {
              var _item2 = list[j];
              _item2.checked = true;

              if (_item2.clockwise === _clockwise) {
                reverse(_item2.list);
                _item2.clockwise = !_clockwise;
              }

              _clockwise = !_clockwise;
            }

            _clockwise = _item.clockwise;

            for (var _j = _i2 + 1; _j < _len3; _j++) {
              var _item3 = list[_j];
              _item3.checked = true;

              if (_item3.clockwise === _clockwise) {
                reverse(_item3.list);
                _item3.clockwise = !_clockwise;
              }

              _clockwise = !_clockwise;
            }

            return;
          }
        } // 新的依次时钟序互相颠倒


        var clockwise = list[0].clockwise;
        list[0].checked = true;

        for (var _i3 = 1, _len4 = list.length; _i3 < _len4; _i3++) {
          var _item4 = list[_i3];
          _item4.checked = true;

          if (_item4.clockwise === clockwise) {
            reverse(_item4.list);
            _item4.clockwise = !clockwise;
          }

          clockwise = !clockwise;
        }
      }
    });
    return v.map(function (item) {
      var list = item.list.map(function (seg) {
        var coords = seg.coords,
            len = coords.length;

        if (len === 2) {
          return [coords[1].x, coords[1].y];
        } else if (len === 3) {
          return [coords[1].x, coords[1].y, coords[2].x, coords[2].y];
        } else if (len === 4) {
          return [coords[1].x, coords[1].y, coords[2].x, coords[2].y, coords[3].x, coords[3].y];
        }
      }); // 首个顶点重合

      var first = item.list[0],
          coords = first.coords;
      list.unshift([coords[0].x, coords[0].y]);
      return list;
    });
  }

  function prefix(polygon) {
    if (!polygon || !Array.isArray(polygon) || !Array.isArray(polygon[0])) {
      return [];
    }

    if (Array.isArray(polygon[0][0])) {
      return polygon;
    }

    return [polygon];
  }

  function trivial(polygonA, polygonB) {
    var isIntermediateA = polygonA instanceof Polygon$1;
    var isIntermediateB = polygonB instanceof Polygon$1; // 生成多边形对象，相交线段拆分开来，曲线x单调性裁剪，重合线段标记

    var source;

    if (isIntermediateA) {
      source = polygonA.reset(0);
    } else {
      source = new Polygon$1(prefix(polygonA), 0);
      source.selfIntersect();
    } // console.log(source.toString());


    var clip;

    if (isIntermediateB) {
      clip = polygonB.reset(1);
    } else {
      clip = new Polygon$1(prefix(polygonB), 1);
      clip.selfIntersect();
    } // console.log(clip.toString());
    // console.log('----');
    // 两个多边形之间再次互相判断相交


    Polygon$1.intersect2(source, clip, isIntermediateA, isIntermediateB); // console.log(source.toString());
    // console.log(clip.toString());
    // console.log('====');

    Polygon$1.annotate2(source, clip, isIntermediateA, isIntermediateB); // console.log(source.toString());
    // console.log(clip.toString());

    return [source, clip];
  }

  var INTERSECT = [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0],
      UNION = [0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
      SUBTRACT = [0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0],
      SUBTRACT_REV = [0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0],
      XOR = [0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0];

  function filter(segments, matrix) {
    var res = [],
        hash = {};
    segments.forEach(function (seg) {
      var belong = seg.belong,
          myFill = seg.myFill,
          otherFill = seg.otherFill,
          otherCoincide = seg.otherCoincide;

      if (otherCoincide) {
        // 对方重合线只出现一次
        var hc = seg.toHash();

        if (hash.hasOwnProperty(hc)) {
          return;
        }

        hash[hc] = true;
      }

      var i;

      if (belong) {
        i = (otherFill[0] ? 8 : 0) + (myFill[0] ? 4 : 0) + (otherFill[1] ? 2 : 0) + (myFill[1] ? 1 : 0);
      } else {
        i = (myFill[0] ? 8 : 0) + (otherFill[0] ? 4 : 0) + (myFill[1] ? 2 : 0) + (otherFill[1] ? 1 : 0);
      }

      if (matrix[i]) {
        res.push(seg);
      }
    }); // console.log(res.map(item => item.toString()));

    return res;
  }

  var bo = {
    intersect: function intersect(polygonA, polygonB, intermediate) {
      var _trivial = trivial(polygonA, polygonB),
          _trivial2 = _slicedToArray(_trivial, 2),
          source = _trivial2[0],
          clip = _trivial2[1];

      var list = filter(source.segments.concat(clip.segments), INTERSECT);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return _chain(list);
    },
    union: function union(polygonA, polygonB, intermediate) {
      var _trivial3 = trivial(polygonA, polygonB),
          _trivial4 = _slicedToArray(_trivial3, 2),
          source = _trivial4[0],
          clip = _trivial4[1];

      var list = filter(source.segments.concat(clip.segments), UNION);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return _chain(list);
    },
    subtract: function subtract(polygonA, polygonB, intermediate) {
      var _trivial5 = trivial(polygonA, polygonB),
          _trivial6 = _slicedToArray(_trivial5, 2),
          source = _trivial6[0],
          clip = _trivial6[1];

      var list = filter(source.segments.concat(clip.segments), SUBTRACT);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return _chain(list);
    },
    subtractRev: function subtractRev(polygonA, polygonB, intermediate) {
      var _trivial7 = trivial(polygonA, polygonB),
          _trivial8 = _slicedToArray(_trivial7, 2),
          source = _trivial8[0],
          clip = _trivial8[1];

      var list = filter(source.segments.concat(clip.segments), SUBTRACT_REV);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return _chain(list);
    },
    xor: function xor(polygonA, polygonB, intermediate) {
      var _trivial9 = trivial(polygonA, polygonB),
          _trivial10 = _slicedToArray(_trivial9, 2),
          source = _trivial10[0],
          clip = _trivial10[1];

      var list = filter(source.segments.concat(clip.segments), XOR);

      if (intermediate) {
        source.segments = list;
        return source;
      }

      return _chain(list);
    },
    chain: function chain(polygon) {
      if (polygon instanceof Polygon$1) {
        return _chain(polygon.segments);
      }

      return prefix(polygon);
    }
  };

  var math = {
    matrix: mx,
    tar: tar,
    vector: vector,
    equation: equation,
    geom: geom$1,
    bezier: bezier$1,
    isec: isec,
    booleanOperations: bo
  };

  var _enums$STYLE_KEY$h = enums.STYLE_KEY,
      TRANSLATE_X$3 = _enums$STYLE_KEY$h.TRANSLATE_X,
      TRANSLATE_Y$3 = _enums$STYLE_KEY$h.TRANSLATE_Y,
      TRANSLATE_Z$3 = _enums$STYLE_KEY$h.TRANSLATE_Z,
      SCALE_X$3 = _enums$STYLE_KEY$h.SCALE_X,
      SCALE_Y$3 = _enums$STYLE_KEY$h.SCALE_Y,
      SCALE_Z$2 = _enums$STYLE_KEY$h.SCALE_Z,
      SKEW_X$2 = _enums$STYLE_KEY$h.SKEW_X,
      SKEW_Y$2 = _enums$STYLE_KEY$h.SKEW_Y,
      ROTATE_X$2 = _enums$STYLE_KEY$h.ROTATE_X,
      ROTATE_Y$2 = _enums$STYLE_KEY$h.ROTATE_Y,
      ROTATE_Z$4 = _enums$STYLE_KEY$h.ROTATE_Z,
      ROTATE_3D$3 = _enums$STYLE_KEY$h.ROTATE_3D,
      PERSPECTIVE$3 = _enums$STYLE_KEY$h.PERSPECTIVE,
      MATRIX$3 = _enums$STYLE_KEY$h.MATRIX,
      FONT_SIZE$7 = _enums$STYLE_KEY$h.FONT_SIZE;
  var PX$7 = o$4.PX,
      PERCENT$6 = o$4.PERCENT,
      REM$6 = o$4.REM,
      VW$6 = o$4.VW,
      VH$6 = o$4.VH,
      VMAX$6 = o$4.VMAX,
      VMIN$6 = o$4.VMIN;
  var matrix = math.matrix,
      geom = math.geom;
  var identity = matrix.identity,
      multiply$2 = matrix.multiply,
      multiplyTfo = matrix.multiplyTfo,
      isE$3 = matrix.isE;
  var d2r = geom.d2r;

  function calSingle(t, k, v) {
    if (k === TRANSLATE_X$3) {
      t[12] = v;
    } else if (k === TRANSLATE_Y$3) {
      t[13] = v;
    } else if (k === TRANSLATE_Z$3) {
      t[14] = v;
    } else if (k === SCALE_X$3) {
      t[0] = v;
    } else if (k === SCALE_Y$3) {
      t[5] = v;
    } else if (k === SCALE_Z$2) {
      t[10] = v;
    } else if (k === SKEW_X$2) {
      v = d2r(v);
      t[4] = Math.tan(v);
    } else if (k === SKEW_Y$2) {
      v = d2r(v);
      t[1] = Math.tan(v);
    } else if (k === ROTATE_X$2) {
      v = d2r(v);
      var sin = Math.sin(v);
      var cos = Math.cos(v);
      t[5] = t[10] = cos;
      t[6] = sin;
      t[9] = -sin;
    } else if (k === ROTATE_Y$2) {
      v = d2r(v);

      var _sin = Math.sin(v);

      var _cos = Math.cos(v);

      t[0] = t[10] = _cos;
      t[8] = _sin;
      t[2] = -_sin;
    } else if (k === ROTATE_Z$4) {
      v = d2r(v);

      var _sin2 = Math.sin(v);

      var _cos2 = Math.cos(v);

      t[0] = t[5] = _cos2;
      t[1] = _sin2;
      t[4] = -_sin2;
    } else if (k === ROTATE_3D$3) {
      var _v = v,
          _v2 = _slicedToArray(_v, 4),
          x = _v2[0],
          y = _v2[1],
          z = _v2[2],
          r = _v2[3];

      r = d2r(r.v);
      var s = Math.sin(r);
      var c = Math.cos(r);

      if (x && !y && !z) {
        if (x < 0) {
          s = -s;
        }

        t[5] = c;
        t[9] = -s;
        t[6] = s;
        t[10] = c;
      } else if (y && !x && !z) {
        if (y < 0) {
          s = -s;
        }

        t[0] = c;
        t[8] = s;
        t[2] = -s;
        t[10] = c;
      } else if (z && !x && !y) {
        if (z < 0) {
          s = -s;
        }

        t[0] = c;
        t[4] = -s;
        t[1] = s;
        t[5] = c;
      } else {
        var len = Math.sqrt(x * x + y * y + z * z);

        if (len !== 1) {
          var rlen = 1 / len;
          x *= rlen;
          y *= rlen;
          z *= rlen;
        }

        var nc = 1 - c;
        var xy = x * y;
        var yz = y * z;
        var zx = z * x;
        var xs = x * s;
        var ys = y * s;
        var zs = z * s;
        t[0] = x * x * nc + c;
        t[1] = xy * nc + zs;
        t[2] = zx * nc - ys;
        t[3] = 0;
        t[4] = xy * nc - zs;
        t[5] = y * y * nc + c;
        t[6] = yz * nc + xs;
        t[7] = 0;
        t[8] = zx * nc + ys;
        t[9] = yz * nc - xs;
        t[10] = z * z * nc + c;
        t[11] = 0;
        t[12] = 0;
        t[13] = 0;
        t[14] = 0;
        t[15] = 1;
      }
    } else if (k === PERSPECTIVE$3 && v > 0) {
      v = Math.max(v, 1);
      t[11] = -1 / v;
    } else if (k === MATRIX$3) {
      util.assignMatrix(t, v);
    }
  }

  function calMatrix(transform, ow, oh, root) {
    var m = identity();

    for (var i = 0, len = transform.length; i < len; i++) {
      var item = transform[i];
      var t = identity();
      calSingle(t, item.k, normalizeSingle(item.k, item.v, ow, oh, root));
      m = multiply$2(m, t);
    }

    return m;
  } // 已有计算好的变换矩阵，根据tfo原点计算最终的matrix


  function calMatrixByOrigin(m, transformOrigin) {
    var _transformOrigin = _slicedToArray(transformOrigin, 2),
        ox = _transformOrigin[0],
        oy = _transformOrigin[1];

    var res = m.slice(0);

    if (ox === 0 && oy === 0 || isE$3(m)) {
      return res;
    }

    res = multiply$2([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ox, oy, 0, 1], res);
    res = multiplyTfo(res, -ox, -oy);
    return res;
  } // img缩放svg下专用，无rem


  function calMatrixWithOrigin(transform, transformOrigin, ow, oh) {
    var m = calMatrix(transform, ow, oh);
    return calMatrixByOrigin(m, transformOrigin);
  }

  function normalizeSingle(k, v, ow, oh, root) {
    if (k === TRANSLATE_X$3 || k === TRANSLATE_Y$3 || k === TRANSLATE_Z$3) {
      if (v.u === PX$7) {
        return v.v;
      } else if (v.u === PERCENT$6) {
        return v.v * (k === TRANSLATE_Y$3 ? oh : ow) * 0.01;
      } else if (v.u === REM$6) {
        return v.v * root.__computedStyle[FONT_SIZE$7];
      } else if (v.u === VW$6) {
        return v.v * root.width * 0.01;
      } else if (v.u === VH$6) {
        return v.v * root.height * 0.01;
      } else if (v.u === VMAX$6) {
        return v.v * Math.max(root.width, root.height) * 0.01;
      } else if (v.u === VMIN$6) {
        return v.v * Math.min(root.width, root.height) * 0.01;
      }
    } else if (k === MATRIX$3) {
      return v;
    } else if (k === ROTATE_3D$3) {
      return v;
    }

    return v.v;
  }

  function calMatrixByPerspective(m, pm) {
    if (!isE$3(pm)) {
      m = multiply$2(pm, m);
    }

    return m;
  }

  function calPerspectiveMatrix(ppt, po) {
    if (ppt && ppt > 0) {
      var res = identity();
      ppt = Math.max(ppt, 1);
      res[11] = -1 / ppt;

      var _po = _slicedToArray(po, 2),
          ox = _po[0],
          oy = _po[1];

      if (ox || oy) {
        res = multiply$2([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, ox, oy, 0, 1], res);
        res = multiplyTfo(res, -ox, -oy);
      }

      return res;
    }
  } // 是否有透视矩阵应用


  function isPerspectiveMatrix(m) {
    if (!m) {
      return;
    }

    return !!(m[3] || m[7] || m[11]);
  }

  var transform = {
    calMatrix: calMatrix,
    calMatrixByPerspective: calMatrixByPerspective,
    calPerspectiveMatrix: calPerspectiveMatrix,
    calMatrixByOrigin: calMatrixByOrigin,
    calMatrixWithOrigin: calMatrixWithOrigin,
    isPerspectiveMatrix: isPerspectiveMatrix
  };

  var _enums$STYLE_KEY$g = enums.STYLE_KEY,
      COLOR$5 = _enums$STYLE_KEY$g.COLOR,
      FONT_WEIGHT$5 = _enums$STYLE_KEY$g.FONT_WEIGHT,
      FONT_FAMILY$5 = _enums$STYLE_KEY$g.FONT_FAMILY,
      FONT_SIZE$6 = _enums$STYLE_KEY$g.FONT_SIZE,
      FONT_STYLE$3 = _enums$STYLE_KEY$g.FONT_STYLE,
      LETTER_SPACING$2 = _enums$STYLE_KEY$g.LETTER_SPACING,
      TEXT_STROKE_COLOR$4 = _enums$STYLE_KEY$g.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$3 = _enums$STYLE_KEY$g.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER$3 = _enums$STYLE_KEY$g.TEXT_STROKE_OVER,
      ROTATE_Z$3 = _enums$STYLE_KEY$g.ROTATE_Z,
      LINE_HEIGHT$6 = _enums$STYLE_KEY$g.LINE_HEIGHT;
  var DEG$2 = o$4.DEG;
  var CANVAS$4 = mode.CANVAS,
      SVG$4 = mode.SVG,
      WEBGL$4 = mode.WEBGL;
  var TuOrU = /(?:[\xA7\xA9\xAE\xB1\xBC-\xBE\xD7\xF7\u02EA\u02EB\u1100-\u11FF\u1401-\u167F\u18B0-\u18FF\u2016\u2020\u2021\u2030\u2031\u203B\u203C\u2042\u2047-\u2049\u2051\u2065\u20DD-\u20E0\u20E2-\u20E4\u2100\u2101\u2103-\u2109\u210F\u2113\u2114\u2116\u2117\u211E-\u2123\u2125\u2127\u2129\u212E\u2135-\u213F\u2145-\u214A\u214C\u214D\u214F-\u2189\u218C-\u218F\u221E\u2234\u2235\u2300-\u2307\u230C-\u231F\u2324-\u2328\u232B\u237D-\u239A\u23BE-\u23CD\u23CF\u23D1-\u23DB\u23E2-\u2422\u2424-\u24FF\u25A0-\u2619\u2620-\u2767\u2776-\u2793\u2B12-\u2B2F\u2B50-\u2B59\u2B97\u2BB8-\u2BD1\u2BD3-\u2BEB\u2BF0-\u2BFF\u2E50\u2E51\u2E80-\u3007\u3012\u3013\u3020-\u302F\u3031-\u309F\u30A1-\u30FB\u30FD-\uA4CF\uA960-\uA97F\uAC00-\uD7FF\uE000-\uFAFF\uFE10-\uFE1F\uFE30-\uFE48\uFE50-\uFE57\uFE5F-\uFE62\uFE67-\uFE6F\uFF01-\uFF07\uFF0A-\uFF0C\uFF0E-\uFF19\uFF1F-\uFF3A\uFF3C\uFF3E\uFF40-\uFF5A\uFFE0-\uFFE2\uFFE4-\uFFE7\uFFF0-\uFFF8\uFFFC\uFFFD]|\uD802[\uDD80-\uDD9F]|\uD805[\uDD80-\uDDFF]|\uD806[\uDE00-\uDEBF]|[\uD80C\uD81C-\uD822\uD83C\uD83D\uD840-\uD87E\uD880-\uD8BE][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC3F]|\uD811[\uDC00-\uDE7F]|\uD81B[\uDFE0-\uDFFF]|\uD823[\uDC00-\uDD7F]|\uD82B[\uDFF0-\uDFFF]|\uD82C[\uDC00-\uDEFF]|\uD833[\uDF00-\uDFCF]|\uD834[\uDC00-\uDDFF\uDEE0-\uDF7F]|\uD836[\uDC00-\uDEAF]|\uD83E[\uDD00-\uDEFF]|[\uD87F\uD8BF][\uDC00-\uDFFD])/;
  /**
   * 表示一行文本的类，保存它的位置、内容、从属信息，在布局阶段生成，并在渲染阶段被Text调用render()
   * 关系上直属于Text类，一个Text类可能因为换行原因导致有多个TextBox，一行内容中也可能有不同Text从而不同TextBox
   * 另外本类还会被LineBoxManager添加到LineBox里，LineBox为一行中的inline/文本组合，之间需要进行垂直对齐
   * 在textOverflow为ellipsis时，可能会收到后面节点的向前回退（后面不足放下…），使得省略号发生在本节点
   */

  var TextBox = /*#__PURE__*/function () {
    function TextBox(parent, index, x, y, w, h, content) {
      var isUpright = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
      this.__parent = parent;
      this.__index = index;
      this.__x = x;
      this.__y = y;

      if (isUpright) {
        this.__width = h;
        this.__height = w;
      } else {
        this.__width = w;
        this.__height = h;
      }

      this.__content = content;
      this.__virtualDom = {};
      this.__parentLineBox = null;
      this.__isVertical = isUpright;
    }
    /**
     * 渲染阶段被Text类调用，多行Text会有多个TextBox，内容被分拆开
     * @param renderMode
     * @param ctx
     * @param computedStyle
     * @param cacheStyle Text父节点Dom的缓存样式，相比computedStyle可以直接用，比如color被缓存为style字符串
     * @param dx
     * @param dy
     */


    _createClass(TextBox, [{
      key: "render",
      value: function render(renderMode, ctx, computedStyle, cacheStyle, dx, dy) {
        var content = this.content,
            x = this.x,
            y = this.y,
            parent = this.parent,
            width = this.width,
            height = this.height,
            isUpright = this.isUpright;
        var ox = parent.ox,
            oy = parent.oy;
        var dom = parent.__domParent;
        var b = css.getBaseline(computedStyle);
        var bv = css.getVerticalBaseline(computedStyle); // 垂直文本x/y互换，渲染时使用rotate模拟，因为是基于baseline绘制，顺时针90deg时tfo是文字左下角，
        // 它等同于lineHeight（现在的w）减去b

        if (isUpright) {
          x += bv;
        } else {
          y += b;
        }

        x += ox + dx;
        y += oy + dy;

        if (isUpright) {
          this.__endX = x;
          this.__endY = y + height;
        } else {
          this.__endX = x + width;
          this.__endY = y;
        }

        var letterSpacing = computedStyle[LETTER_SPACING$2],
            textStrokeWidth = computedStyle[TEXT_STROKE_WIDTH$3],
            textStrokeColor = computedStyle[TEXT_STROKE_COLOR$4],
            fontSize = computedStyle[FONT_SIZE$6],
            lineHeight = computedStyle[LINE_HEIGHT$6];
        var i = 0,
            length = content.length;

        if (renderMode === CANVAS$4 || renderMode === WEBGL$4) {
          var me = dom.matrixEvent,
              list;
          var dev1 = 0,
              dev2 = 0;

          if (isUpright) {
            list = [{
              k: ROTATE_Z$3,
              v: {
                v: 90,
                u: DEG$2
              }
            }];
            dev1 = bv * 0.6;
            dev2 = bv * 0.2;
          }

          var overFill = computedStyle[TEXT_STROKE_OVER$3] === 'fill';

          if (letterSpacing) {
            for (; i < length; i++) {
              var c = content.charAt(i);

              if (isUpright) {
                var cjk = TuOrU.test(c);

                if (cjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  if (overFill) {
                    ctx.fillText(c, x - dev1, y - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(c, x - dev1, y - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(c, x - dev1, y - dev2);
                  }
                } else {
                  var tfo = [x, y];
                  var m = transform.calMatrixWithOrigin(list, tfo, 0, 0);
                  m = mx.multiply(me, m);
                  ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);

                  if (overFill) {
                    ctx.fillText(c, x, y);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(c, x, y);
                  }

                  if (!overFill) {
                    ctx.fillText(c, x, y);
                  }
                }

                y += ctx.measureText(c).width + letterSpacing;
              } else {
                if (overFill) {
                  ctx.fillText(c, x, y);
                }

                if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                  ctx.strokeText(c, x, y);
                }

                if (!overFill) {
                  ctx.fillText(c, x, y);
                }

                x += ctx.measureText(c).width + letterSpacing;
              }
            }
          } else {
            if (isUpright) {
              var _cjk = TuOrU.test(content.charAt(0)),
                  last = 0,
                  count = 0,
                  len = content.length;

              for (var _i = 1; _i < len; _i++) {
                var nowCjk = TuOrU.test(content.charAt(_i)); // 不相等时cjk发生变化，输出之前的内容，记录当下的所有

                if (nowCjk !== _cjk) {
                  if (_cjk) {
                    ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);
                    var s = content.slice(last, _i);

                    if (overFill) {
                      ctx.fillText(s, x - dev1, y + count + b - dev2);
                    }

                    if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                      ctx.strokeText(s, x - dev1, y + count + b - dev2);
                    }

                    if (!overFill) {
                      ctx.fillText(s, x - dev1, y + count + b - dev2);
                    }

                    count += fontSize;
                  } else {
                    var _tfo = [x, y + count];

                    var _m = transform.calMatrixWithOrigin(list, _tfo, 0, 0);

                    _m = mx.multiply(me, _m);
                    ctx.setTransform(_m[0], _m[1], _m[4], _m[5], _m[12], _m[13]);

                    var _s = content.slice(last, _i);

                    if (overFill) {
                      ctx.fillText(_s, x, y + count);
                    }

                    if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                      ctx.strokeText(_s, x, y + count);
                    }

                    if (!overFill) {
                      ctx.fillText(_s, x, y + count);
                    }

                    count += ctx.measureText(_s).width;
                  }

                  last = _i;
                  _cjk = !_cjk;
                } // cjk单字符输出
                else if (nowCjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  var _s2 = content.slice(last, _i);

                  if (overFill) {
                    ctx.fillText(_s2, x - dev1, y + count + b - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s2, x - dev1, y + count + b - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(_s2, x - dev1, y + count + b - dev2);
                  }

                  count += fontSize;
                  last = _i;
                }
              }

              if (last < len) {
                var _s3 = content.slice(last, len); // 最后的cjk只可能是一个字符


                if (_cjk) {
                  ctx.setTransform(me[0], me[1], me[4], me[5], me[12], me[13]);

                  if (overFill) {
                    ctx.fillText(_s3, x - dev1, y + count + b - dev2);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s3, x - dev1, y + count + b - dev2);
                  }

                  if (!overFill) {
                    ctx.fillText(_s3, x - dev1, y + count + b - dev2);
                  }
                } else {
                  var _tfo2 = [x, y + count];

                  var _m2 = transform.calMatrixWithOrigin(list, _tfo2, 0, 0);

                  _m2 = mx.multiply(me, _m2);
                  ctx.setTransform(_m2[0], _m2[1], _m2[4], _m2[5], _m2[12], _m2[13]);

                  if (overFill) {
                    ctx.fillText(_s3, x, y + count);
                  }

                  if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                    ctx.strokeText(_s3, x, y + count);
                  }

                  if (!overFill) {
                    ctx.fillText(_s3, x, y + count);
                  }
                }
              }
            } else {
              if (overFill) {
                ctx.fillText(content, x, y);
              }

              if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
                ctx.strokeText(content, x, y);
              }

              if (!overFill) {
                ctx.fillText(content, x, y);
              }
            }
          }
        } else if (renderMode === SVG$4) {
          var color = cacheStyle[COLOR$5];

          if (color.k) {
            color = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, color, dx, dy).v;
          } // 垂直的svg以中线为基线，需偏移baseline和中线的差值


          if (isUpright) {
            x += lineHeight * 0.5 - bv;
          }

          var props = [['x', x], ['y', y], ['fill', color], ['font-family', computedStyle[FONT_FAMILY$5]], ['font-weight', computedStyle[FONT_WEIGHT$5]], ['font-style', computedStyle[FONT_STYLE$3]], ['font-size', computedStyle[FONT_SIZE$6] + 'px']]; // svg无法定义stroke的over

          if (textStrokeWidth && (textStrokeColor[3] > 0 || textStrokeColor.length === 3 || textStrokeColor.k)) {
            var _textStrokeColor = cacheStyle[TEXT_STROKE_COLOR$4]; // 渐变

            if (_textStrokeColor.k) {
              _textStrokeColor = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, _textStrokeColor, dx, dy).v;
            }

            props.push(['stroke', _textStrokeColor]);
            props.push(['stroke-width', computedStyle[TEXT_STROKE_WIDTH$3]]);
          }

          if (letterSpacing) {
            props.push(['letter-spacing', letterSpacing]);
          }

          if (isUpright) {
            props.push(['writing-mode', 'vertical-lr']);
          }

          this.__virtualDom = {
            type: 'item',
            tagName: 'text',
            props: props,
            content: util.encodeHtml(content)
          };
        }
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff) {
        this.__x += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff) {
        this.__y += diff;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "endX",
      get: function get() {
        return this.__endX;
      }
    }, {
      key: "endY",
      get: function get() {
        return this.__endY;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "content",
      get: function get() {
        return this.__content;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.parent.baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        return this.parent.verticalBaseline;
      }
    }, {
      key: "virtualDom",
      get: function get() {
        return this.__virtualDom;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }]);

    return TextBox;
  }();

  var _enums$STYLE_KEY$f = enums.STYLE_KEY,
      FONT_SIZE$5 = _enums$STYLE_KEY$f.FONT_SIZE,
      FONT_FAMILY$4 = _enums$STYLE_KEY$f.FONT_FAMILY,
      FONT_WEIGHT$4 = _enums$STYLE_KEY$f.FONT_WEIGHT,
      FONT_STYLE$2 = _enums$STYLE_KEY$f.FONT_STYLE,
      COLOR$4 = _enums$STYLE_KEY$f.COLOR,
      LINE_HEIGHT$5 = _enums$STYLE_KEY$f.LINE_HEIGHT,
      ROTATE_Z$2 = _enums$STYLE_KEY$f.ROTATE_Z;
  var DEG$1 = o$4.DEG;
  var CANVAS$3 = mode.CANVAS,
      SVG$3 = mode.SVG,
      WEBGL$3 = mode.WEBGL;
  var CHAR = '…';

  var Ellipsis = /*#__PURE__*/function (_Node) {
    _inherits(Ellipsis, _Node);

    function Ellipsis(x, y, width, parent, isUpright) {
      var _this;

      _this = _Node.call(this) || this;
      _this.__x = _this.__sx1 = x;
      _this.__y = _this.__sy1 = y;
      _this.__width = width;
      _this.__parent = _this.__domParent = parent;
      parent.__ellipsis = _assertThisInitialized(_this);
      _this.__parentLineBox = null;
      _this.__baseline = css.getBaseline(parent.computedStyle);
      _this.__isVertical = isUpright;
      return _this;
    }

    _createClass(Ellipsis, [{
      key: "render",
      value: function render(renderMode, ctx) {
        var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var x = this.x,
            y = this.y,
            parent = this.parent,
            isUpright = this.isUpright;
        var ox = parent.ox,
            oy = parent.oy,
            computedStyle = parent.computedStyle,
            color = parent.cacheStyle[COLOR$4];
        var b = css.getBaseline(computedStyle);
        var bv = css.getVerticalBaseline(computedStyle);

        if (isUpright) {
          x += bv;
        } else {
          y += b;
        }

        x += ox + dx;
        y += oy + dy;

        if (renderMode === CANVAS$3 || renderMode === WEBGL$3) {
          var font = css.setFontStyle(computedStyle);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          if (ctx.fillStyle !== color) {
            ctx.fillStyle = color;
          }

          if (isUpright) {
            var me = parent.matrixEvent,
                list = [{
              k: ROTATE_Z$2,
              v: {
                v: 90,
                u: DEG$1
              }
            }];
            var tfo = [x, y];
            var m = transform.calMatrixWithOrigin(list, tfo, 0, 0);
            m = mx.multiply(me, m);
            ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
          }

          ctx.fillText(CHAR, x, y);
        } else if (renderMode === SVG$3) {
          // 垂直的svg以中线为基线，需偏移baseline和中线的差值
          if (isUpright) {
            x += computedStyle[LINE_HEIGHT$5] * 0.5 - bv;
          }

          var props = [['x', x], ['y', y], ['fill', color], ['font-family', computedStyle[FONT_FAMILY$4]], ['font-weight', computedStyle[FONT_WEIGHT$4]], ['font-style', computedStyle[FONT_STYLE$2]], ['font-size', computedStyle[FONT_SIZE$5] + 'px']];

          if (isUpright) {
            props.push(['writing-mode', 'vertical-lr']);
          }

          var vd = this.__virtualDom = {
            type: 'text',
            children: [{
              type: 'item',
              tagName: 'text',
              props: props,
              content: CHAR
            }]
          };
          parent.virtualDom.children.push(vd);
        }
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }, {
      key: "isEllipsis",
      get: function get() {
        return true;
      }
    }]);

    return Ellipsis;
  }(Node);

  var _enums$STYLE_KEY$e = enums.STYLE_KEY,
      TX$1 = _enums$STYLE_KEY$e.TRANSLATE_X,
      TY$1 = _enums$STYLE_KEY$e.TRANSLATE_Y,
      TZ$1 = _enums$STYLE_KEY$e.TRANSLATE_Z,
      OP$2 = _enums$STYLE_KEY$e.OPACITY,
      FT$2 = _enums$STYLE_KEY$e.FILTER,
      PPT$1 = _enums$STYLE_KEY$e.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$3 = _enums$STYLE_KEY$e.PERSPECTIVE_ORIGIN,
      Z_INDEX$4 = _enums$STYLE_KEY$e.Z_INDEX,
      SCALE_X$2 = _enums$STYLE_KEY$e.SCALE_X,
      SCALE_Y$2 = _enums$STYLE_KEY$e.SCALE_Y,
      SCALE_Z$1 = _enums$STYLE_KEY$e.SCALE_Z,
      ROTATE_X$1 = _enums$STYLE_KEY$e.ROTATE_X,
      ROTATE_Y$1 = _enums$STYLE_KEY$e.ROTATE_Y,
      ROTATE_Z$1 = _enums$STYLE_KEY$e.ROTATE_Z,
      ROTATE_3D$2 = _enums$STYLE_KEY$e.ROTATE_3D,
      SKEW_X$1 = _enums$STYLE_KEY$e.SKEW_X,
      SKEW_Y$1 = _enums$STYLE_KEY$e.SKEW_Y,
      TF$2 = _enums$STYLE_KEY$e.TRANSFORM,
      TRANSFORM_ORIGIN$4 = _enums$STYLE_KEY$e.TRANSFORM_ORIGIN;
  var isIgnore = o$2.isIgnore,
      isRepaint$1 = o$2.isRepaint; // 低位表示<repaint级别

  var NONE$3 = 0; //                                          0
  // cacheTotal变化需重新生成的时候

  var CACHE$4 = 1; //                                         1

  var TRANSLATE_X$2 = 2; //                                  10

  var TRANSLATE_Y$2 = 4; //                                 100

  var TRANSLATE_Z$2 = 8; //                                1000

  var TRANSFORM$5 = 16; //                                10000

  var TRANSFORM_ALL$4 = 30; //                            11110

  var OPACITY$5 = 32; //                                 100000

  var FILTER$5 = 64; //                                 1000000

  var MIX_BLEND_MODE$4 = 128; //                       10000000

  var PERSPECTIVE$2 = 256; //                         100000000

  var REPAINT$4 = 512; //                            1000000000
  // 高位表示reflow

  var REFLOW$3 = 1024; //                           10000000000
  // 特殊高位表示rebuild，节点发生变化

  var REBUILD$1 = 2048; //                         100000000000

  var ENUM = {
    NONE: NONE$3,
    CACHE: CACHE$4,
    TRANSLATE_X: TRANSLATE_X$2,
    TRANSLATE_Y: TRANSLATE_Y$2,
    TRANSLATE_Z: TRANSLATE_Z$2,
    TRANSFORM: TRANSFORM$5,
    TRANSFORM_ALL: TRANSFORM_ALL$4,
    OPACITY: OPACITY$5,
    FILTER: FILTER$5,
    MIX_BLEND_MODE: MIX_BLEND_MODE$4,
    PERSPECTIVE: PERSPECTIVE$2,
    REPAINT: REPAINT$4,
    REFLOW: REFLOW$3,
    REBUILD: REBUILD$1
  };

  function isTransforms(k) {
    return k === SCALE_X$2 || k === SCALE_Y$2 || k === SCALE_Z$1 || k === ROTATE_X$1 || k === ROTATE_Y$1 || k === ROTATE_Z$1 || k === ROTATE_3D$2 || k === SKEW_X$1 || k === SKEW_Y$1 || k === TF$2 || k === TRANSFORM_ORIGIN$4;
  }

  var o$1 = Object.assign({
    // 是否包含value之内的
    contain: function contain(lv, value) {
      return (lv & value) > 0;
    },

    /**
     * 得出等级
     * @param k
     * @returns {number|*}
     */
    getLevel: function getLevel(k) {
      if (isIgnore(k)) {
        return NONE$3;
      }

      if (k === Z_INDEX$4) {
        return CACHE$4;
      }

      if (k === TX$1) {
        return TRANSLATE_X$2;
      }

      if (k === TY$1) {
        return TRANSLATE_Y$2;
      }

      if (k === TZ$1) {
        return TRANSLATE_Z$2;
      }

      if (k === OP$2) {
        return OPACITY$5;
      }

      if (k === FT$2) {
        return FILTER$5;
      }

      if (k === PPT$1 || k === PERSPECTIVE_ORIGIN$3) {
        return PERSPECTIVE$2;
      }

      if (isTransforms(k)) {
        return TRANSFORM$5;
      }

      if (isRepaint$1(k)) {
        return REPAINT$4;
      }

      return REFLOW$3;
    },
    isReflow: function isReflow(lv) {
      return lv >= REFLOW$3;
    },
    isRepaint: function isRepaint(lv) {
      return lv < REFLOW$3;
    }
  }, ENUM);

  var _enums$STYLE_KEY$d = enums.STYLE_KEY,
      DISPLAY$7 = _enums$STYLE_KEY$d.DISPLAY,
      POSITION$4 = _enums$STYLE_KEY$d.POSITION,
      LINE_HEIGHT$4 = _enums$STYLE_KEY$d.LINE_HEIGHT,
      FONT_SIZE$4 = _enums$STYLE_KEY$d.FONT_SIZE,
      FONT_FAMILY$3 = _enums$STYLE_KEY$d.FONT_FAMILY,
      FONT_WEIGHT$3 = _enums$STYLE_KEY$d.FONT_WEIGHT,
      COLOR$3 = _enums$STYLE_KEY$d.COLOR,
      VISIBILITY$5 = _enums$STYLE_KEY$d.VISIBILITY,
      LETTER_SPACING$1 = _enums$STYLE_KEY$d.LETTER_SPACING,
      OVERFLOW$3 = _enums$STYLE_KEY$d.OVERFLOW,
      WHITE_SPACE$2 = _enums$STYLE_KEY$d.WHITE_SPACE,
      TEXT_OVERFLOW$1 = _enums$STYLE_KEY$d.TEXT_OVERFLOW,
      WIDTH$7 = _enums$STYLE_KEY$d.WIDTH,
      HEIGHT$7 = _enums$STYLE_KEY$d.HEIGHT,
      TEXT_STROKE_COLOR$3 = _enums$STYLE_KEY$d.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$2 = _enums$STYLE_KEY$d.TEXT_STROKE_WIDTH,
      MARGIN_TOP$5 = _enums$STYLE_KEY$d.MARGIN_TOP,
      MARGIN_BOTTOM$5 = _enums$STYLE_KEY$d.MARGIN_BOTTOM,
      MARGIN_LEFT$7 = _enums$STYLE_KEY$d.MARGIN_LEFT,
      MARGIN_RIGHT$6 = _enums$STYLE_KEY$d.MARGIN_RIGHT,
      PADDING_TOP$5 = _enums$STYLE_KEY$d.PADDING_TOP,
      PADDING_BOTTOM$4 = _enums$STYLE_KEY$d.PADDING_BOTTOM,
      PADDING_LEFT$7 = _enums$STYLE_KEY$d.PADDING_LEFT,
      PADDING_RIGHT$6 = _enums$STYLE_KEY$d.PADDING_RIGHT,
      BORDER_TOP_WIDTH$5 = _enums$STYLE_KEY$d.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$4 = _enums$STYLE_KEY$d.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$7 = _enums$STYLE_KEY$d.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$6 = _enums$STYLE_KEY$d.BORDER_RIGHT_WIDTH,
      FILTER$4 = _enums$STYLE_KEY$d.FILTER,
      ELLIPSIS$1 = enums.ELLIPSIS;
  var AUTO$6 = o$4.AUTO;
  var CANVAS$2 = mode.CANVAS,
      SVG$2 = mode.SVG,
      WEBGL$2 = mode.WEBGL;
  var isFunction$a = util.isFunction;
  /**
   * 在给定宽度w的情况下，测量文字content多少个满足塞下，只支持水平书写，从start的索引开始，content长length
   * 尽可能地少的次数调用canvas的measureText或svg的html节点的width，因为比较消耗性能
   * 这就需要一种算法，不能逐字遍历看总长度是否超过，也不能单字宽度相加因为有文本整形某些字体多个字宽度不等于每个之和
   * 简单的2分法实现简单，但是次数稍多，对于性能不是最佳，因为内容的slice裁剪和传递给canvas测量都随尺寸增加而加大
   * 由于知道w和fontSize，因此能推测出平均值为fontSize/w，即字的个数，
   * 进行测量后得出w2，和真实w对比，产生误差d，再看d和fontSize推测差距个数，如此反复
   * 返回内容和end索引和长度，最少也要1个字符
   * @param ctx
   * @param renderMode
   * @param start
   * @param length
   * @param content
   * @param w
   * @param perW
   * @param fontFamily
   * @param fontSize
   * @param fontWeight
   * @param letterSpacing
   * @param isUpright
   */

  function measureLineWidth(ctx, renderMode, start, length, content, w, perW, fontFamily, fontSize, fontWeight, letterSpacing, isUpright) {
    if (start >= length) {
      // 特殊情况不应该走进这里
      return [0, 0, false];
    }

    var i = start,
        j = length,
        rw = 0,
        newLine = false; // 特殊降级，有letterSpacing时，canvas无法完全兼容，只能采取单字测量的方式完成

    if (letterSpacing && [CANVAS$2, WEBGL$2].indexOf(renderMode) > -1) {
      var count = 0;

      for (; i < j; i++) {
        var mw = ctx.measureText(content.charAt(i)).width + letterSpacing;

        if (count + mw > w + 1e-10) {
          newLine = true;
          break;
        }

        count += mw;
      }

      return [i - start, count, newLine || count > w + 1e-10];
    } // 没有letterSpacing或者是svg模式可以完美获取TextMetrics


    var hypotheticalNum = Math.round(w / perW); // 不能增长0个字符，至少也要1个

    if (hypotheticalNum <= 0) {
      hypotheticalNum = 1;
    } // 超过内容长度范围也不行
    else if (hypotheticalNum > length - start) {
      hypotheticalNum = length - start;
    } // 类似2分的一个循环


    while (i < j) {
      var _mw = void 0,
          str = content.slice(start, start + hypotheticalNum);

      if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
        _mw = ctx.measureText(str).width;
      } else if (renderMode === SVG$2) {
        _mw = inject.measureTextSync(str, fontFamily, fontSize, fontWeight, isUpright);
      }

      if (letterSpacing) {
        _mw += hypotheticalNum * letterSpacing;
      }

      if (_mw === w) {
        rw = w;
        newLine = true;
        break;
      } // 超出，设置右边界，并根据余量推测减少个数，
      // 因为精度问题，固定宽度或者累加的剩余空间，不用相等判断，而是为原本w宽度加一点点冗余1e-10


      if (_mw > w + 1e-10) {
        newLine = true; // 限制至少1个

        if (hypotheticalNum === 1) {
          rw = _mw;
          break;
        } // 注意特殊判断i和j就差1个可直接得出结果，因为现在超了而-1不超肯定是-1的结果


        if (i === j - 1 || i - start === hypotheticalNum - 1) {
          hypotheticalNum = i - start;
          break;
        }

        j = hypotheticalNum + start - 1;
        var reduce = Math.round((_mw - w) / perW);

        if (reduce <= 0) {
          reduce = 1;
        }

        hypotheticalNum -= reduce;

        if (hypotheticalNum < i - start) {
          hypotheticalNum = i - start;
        }
      } // 还有空余，设置左边界，并根据余量推测增加的个数
      else {
        rw = _mw;

        if (hypotheticalNum === length - start) {
          break;
        }

        i = hypotheticalNum + start;
        var add = Math.round((w - _mw) / perW);

        if (add <= 0) {
          add = 1;
        }

        hypotheticalNum += add;

        if (hypotheticalNum > j - start) {
          hypotheticalNum = j - start;
        }
      }
    }

    return [hypotheticalNum, rw, newLine];
  }

  function getFontKey(ff, fs, fw, ls) {
    return ff + '_' + fs + '_' + fw + '_' + ls;
  }

  var Text = /*#__PURE__*/function (_Node) {
    _inherits(Text, _Node);

    function Text(content) {
      var _this;

      _this = _Node.call(this) || this;
      _this.__content = util.isNil(content) ? '' : content.toString();
      _this.__textBoxes = [];
      _this.__charWidth = 0; // 最小字符宽度（单个）

      _this.__textWidth = 0; // 整体宽度

      _this.__bp = null; // block父节点

      _this.__widthHash = {}; // 存储当前字体样式key下的charWidth/textWidth

      _this.__limitCache = null;
      _this.__hasContent = false;
      return _this;
    }
    /**
     * text在virtual时和普通一样，无需特殊处理
     * endSpace由外界inline布局控制，末尾最后一行的空白mpb，包含递归情况，递归为多个嵌套末尾节点的空白mpb之和
     * 即便宽度不足，每行还是强制渲染一个字符，换行依据lx开始，因为x可能是从中间开始的，非inline则两个相等
     * 最后一个字符排版时要考虑末尾mpb，排不下的话回退删掉这个字符，如果最后一个字符另起开头，排不下也强制排，每行至少1个字符
     * 在textOverflow时很特殊，多个inline同行，回退可能到前一个inline节点，这个通过x和lx判断是否行首，决定至少1个字符规则
     * @param data
     * @private
     */


    _createClass(Text, [{
      key: "__layoutFlow",
      value: function __layoutFlow(data) {
        var __cache = this.__cache;

        if (__cache) {
          __cache.release();
        }

        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h,
            _data$lx = data.lx,
            lx = _data$lx === void 0 ? x : _data$lx,
            _data$ly = data.ly,
            ly = _data$ly === void 0 ? y : _data$ly,
            lineBoxManager = data.lineBoxManager,
            _data$endSpace = data.endSpace,
            endSpace = _data$endSpace === void 0 ? 0 : _data$endSpace,
            _data$lineClamp = data.lineClamp,
            lineClamp = _data$lineClamp === void 0 ? 0 : _data$lineClamp,
            _data$lineClampCount = data.lineClampCount,
            lineClampCount = _data$lineClampCount === void 0 ? 0 : _data$lineClampCount,
            _data$isUpright = data.isUpright,
            isUpright = _data$isUpright === void 0 ? false : _data$isUpright;
        this.__x = this.__sx = this.__sx1 = x;
        this.__y = this.__sy = this.__sy1 = y;
        var __isDestroyed = this.__isDestroyed,
            content = this.content,
            computedStyle = this.computedStyle,
            textBoxes = this.textBoxes,
            root = this.root;
        textBoxes.splice(0); // 空内容w/h都为0可以提前跳出，lineClamp超出一般不会进这，但有特例flex文本垂直预计算时，所以也要跳出

        if (__isDestroyed || computedStyle[DISPLAY$7] === 'none' || !content || lineClamp && lineClampCount >= lineClamp) {
          return lineClampCount;
        }

        this.__ox = this.__oy = 0; // 顺序尝试分割字符串为TextBox，形成多行，begin为每行起始索引，i是当前字符索引

        var i = 0;
        var length = content.length;
        var maxW = 0;
        var lineHeight = computedStyle[LINE_HEIGHT$4],
            letterSpacing = computedStyle[LETTER_SPACING$1],
            whiteSpace = computedStyle[WHITE_SPACE$2],
            fontSize = computedStyle[FONT_SIZE$4],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            fontFamily = computedStyle[FONT_FAMILY$3];
        var size = isUpright ? h : w;
        var beginSpace = isUpright ? y - ly : x - lx; // x>=lx，当第一行非起始处时前面被prev节点占据，这个差值可认为是count宽度
        // 基于最近block父节点的样式

        var bp = this.domParent;

        while (bp.computedStyle[DISPLAY$7] === 'inline') {
          bp = bp.domParent;
        }

        this.__bp = bp;
        var textOverflow = bp.computedStyle[TEXT_OVERFLOW$1]; // 布局测量前置，根据renderMode不同提供不同的测量方法

        var renderMode = root.renderMode;
        var ctx;

        if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
          ctx = renderMode === WEBGL$2 ? inject.getFontCanvas().ctx : root.ctx;
          ctx.font = css.setFontStyle(computedStyle);
        } // fontSize在中文是正好1个字宽度，英文不一定，等宽为2个，不等宽可能1~2个，特殊字符甚至>2个，取预估均值然后倒数得每个均宽0.8


        var perW = fontSize * 0.8 + letterSpacing;
        var lineCount = 0;
        var mainCoords; // 根据书写模式指向不同x/y
        // 不换行特殊对待，同时考虑overflow和textOverflow

        if (whiteSpace === 'nowrap') {
          var isTextOverflow,
              textWidth = this.textWidth;
          var _bp$computedStyle = bp.computedStyle,
              position = _bp$computedStyle[POSITION$4],
              overflow = _bp$computedStyle[OVERFLOW$3];
          var containerSize = bp.currentStyle[isUpright ? HEIGHT$7 : WIDTH$7]; // 只要是overflow隐藏，不管textOverflow如何（默认是clip等同于overflow:hidden的功能）都截取

          if (overflow === 'hidden') {
            // abs自适应宽度时不裁剪
            if (position === 'absolute' && containerSize.u === AUTO$6) {
              isTextOverflow = false;
            } else {
              isTextOverflow = textWidth > size + 1e-10 - beginSpace - endSpace;
            }
          } // ellipsis生效情况，本节点开始向前回退查找，尝试放下一部分字符


          if (isTextOverflow && textOverflow === 'ellipsis') {
            var _this$__lineBack = this.__lineBack(ctx, renderMode, i, length, content, size - endSpace - beginSpace, perW, x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, letterSpacing, isUpright);

            var _this$__lineBack2 = _slicedToArray(_this$__lineBack, 1);

            mainCoords = _this$__lineBack2[0];
            lineCount++;

            if (isUpright) {
              x = mainCoords;
            } else {
              y = mainCoords;
            }
          } // 默认是否clip跟随overflow:hidden，无需感知，裁剪由dom做，这里不裁剪
          else {
            var textBox = new TextBox(this, textBoxes.length, x, y, textWidth, lineHeight, content, isUpright);
            textBoxes.push(textBox);
            lineBoxManager.addItem(textBox, false);

            if (isUpright) {
              x += lineHeight;
            } else {
              y += lineHeight;
            }

            if (isTextOverflow) {
              lineCount++;
            }
          } // 和html一样，maxW此时在html是满格


          maxW = textWidth;
        } // 普通换行，注意x和lx的区别，可能相同（block起始处）可能不同（非起始处），第1行从x开始，第2行及以后都从lx开始
        // 然后第一次换行还有特殊之处，可能同一行前半部行高很大，此时y增加并非自身的lineHeight，而是整体LineBox的
        else {
          while (i < length) {
            var limit = i ? size : size - beginSpace;

            if (lineClamp && lineCount + lineClampCount >= lineClamp - 1) {
              limit -= endSpace;
            }

            var _measureLineWidth = measureLineWidth(ctx, renderMode, i, length, content, limit, perW, fontFamily, fontSize, fontWeight, letterSpacing),
                _measureLineWidth2 = _slicedToArray(_measureLineWidth, 3),
                num = _measureLineWidth2[0],
                rw = _measureLineWidth2[1],
                newLine = _measureLineWidth2[2]; // 多行文本截断，这里肯定需要回退，注意防止恰好是最后一个字符，此时无需截取


            if (lineClamp && newLine && lineCount + lineClampCount >= lineClamp - 1 && i + num < length) {
              var _this$__lineBack3 = this.__lineBack(ctx, renderMode, i, i + num, content, limit - endSpace, perW, lineCount ? lx : x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, letterSpacing, isUpright);

              var _this$__lineBack4 = _slicedToArray(_this$__lineBack3, 2);

              mainCoords = _this$__lineBack4[0];
              maxW = _this$__lineBack4[1];
              lineCount++;

              if (isUpright) {
                x = mainCoords;
              } else {
                y = mainCoords;
              }

              break;
            } // 最后一行考虑endSpace，可能不够需要回退，但不能是1个字符


            if (i + num === length && endSpace && rw + endSpace > limit + 1e-10 && num > 1) {
              var _measureLineWidth3 = measureLineWidth(ctx, renderMode, i, length, content, limit - endSpace, perW, fontFamily, fontSize, fontWeight, letterSpacing);

              var _measureLineWidth4 = _slicedToArray(_measureLineWidth3, 3);

              num = _measureLineWidth4[0];
              rw = _measureLineWidth4[1];
              newLine = _measureLineWidth4[2];

              // 可能加上endSpace后超过了，还得再判断一次
              if (lineClamp && newLine && lineCount + lineClampCount >= lineClamp - 1) {
                var _this$__lineBack5 = this.__lineBack(ctx, renderMode, i, i + num, content, limit - endSpace, perW, lineCount ? lx : x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, letterSpacing, isUpright);

                var _this$__lineBack6 = _slicedToArray(_this$__lineBack5, 2);

                mainCoords = _this$__lineBack6[0];
                maxW = _this$__lineBack6[1];
                lineCount++;

                if (isUpright) {
                  x = mainCoords;
                } else {
                  y = mainCoords;
                }

                break;
              }
            }

            maxW = Math.max(maxW, rw); // 根据是否第一行分开处理行首空白

            var _textBox = new TextBox(this, textBoxes.length, lineCount && !isUpright ? lx : x, lineCount && isUpright ? ly : y, rw, lineHeight, content.slice(i, i + num), isUpright);

            textBoxes.push(_textBox);
            lineBoxManager.addItem(_textBox, newLine); // 竖排横排换行不一样

            if (isUpright) {
              x += Math.max(lineHeight, lineBoxManager.verticalLineHeight);
            } else {
              y += Math.max(lineHeight, lineBoxManager.lineHeight);
            } // 至少也要1个字符形成1行，哪怕是首行，因为是否放得下逻辑在dom中做过了


            i += num;

            if (newLine) {
              lineCount++;
            }
          } // 换行后Text的x重设为lx


          if (lineCount) {
            if (isUpright) {
              this.__y = this.__sy1 = ly;
            } else {
              this.__x = this.__sx1 = lx;
            }
          }
        }

        if (isUpright) {
          this.__width = x - data.x;
          this.__height = maxW;
          this.__verticalBaseline = css.getVerticalBaseline(computedStyle);
        } else {
          this.__width = maxW;
          this.__height = y - data.y;
          this.__baseline = css.getBaseline(computedStyle);
        }

        return lineClampCount + lineCount;
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        this.__width = this.__height = this.__baseline = this.__verticalBaseline = 0;

        this.__textBoxes.splice(0);
      } // 末尾行因ellipsis的缘故向前回退字符生成textBox，可能会因不满足宽度导致无法生成，此时向前继续回退TextBox

    }, {
      key: "__lineBack",
      value: function __lineBack(ctx, renderMode, i, length, content, limit, perW, x, y, maxW, endSpace, lineHeight, textBoxes, lineBoxManager, fontFamily, fontSize, fontWeight, letterSpacing, isUpright) {
        var ew,
            bp = this.__bp,
            computedStyle = bp.computedStyle; // 临时测量ELLIPSIS的尺寸

        if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
          var font = css.setFontStyle(computedStyle);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          ew = ctx.measureText(ELLIPSIS$1).width;
        } else {
          ew = inject.measureTextSync(ELLIPSIS$1, computedStyle[FONT_FAMILY$3], computedStyle[FONT_SIZE$4], computedStyle[FONT_WEIGHT$3]);
        }

        if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
          var _font = css.setFontStyle(this.computedStyle);

          if (ctx.font !== _font) {
            ctx.font = _font;
          }
        }

        var _measureLineWidth5 = measureLineWidth(ctx, renderMode, i, length, content, limit - ew - endSpace, perW, fontFamily, fontSize, fontWeight, letterSpacing),
            _measureLineWidth6 = _slicedToArray(_measureLineWidth5, 2),
            num = _measureLineWidth6[0],
            rw = _measureLineWidth6[1]; // 还是不够，需要回溯查找前一个inline节点继续回退，同时防止空行首，要至少一个textBox且一个字符


        if (rw + ew > limit + 1e-10 - endSpace) {
          // 向前回溯已有的tb，需注意可能是新行开头这时还没生成新的lineBox，而旧行则至少1个内容
          // 新行的话进不来，会添加上面num的内容，旧行不添加只修改之前的tb内容也有可能删除一些
          var lineBox = lineBoxManager.lineBox;

          if (!lineBoxManager.isNewLine && lineBox && lineBox.size) {
            var list = lineBox.list;

            for (var j = list.length - 1; j >= 0; j--) {
              var tb = list[j]; // 可能是个inlineBlock，整个省略掉，除非是第一个不作ellipsis处理

              if (!(tb instanceof TextBox)) {
                if (!j) {
                  break;
                }

                var _item = list.pop();

                if (isUpright) {
                  y -= _item.outerHeight;
                } else {
                  x -= _item.outerWidth;
                }

                limit += isUpright ? _item.outerHeight : _item.outerWidth;

                _item.__layoutNone();

                continue;
              } // 先判断整个tb都删除是否可以容纳下，同时注意第1个tb不能删除因此必进


              var _content = tb.content,
                  width = tb.width,
                  height = tb.height,
                  parent = tb.parent;

              if (!j || limit >= width + ew + 1e-10 + endSpace) {
                var _length = _content.length;
                var _parent$computedStyle = parent.computedStyle,
                    _lineHeight = _parent$computedStyle[LINE_HEIGHT$4],
                    _letterSpacing = _parent$computedStyle[LETTER_SPACING$1],
                    _fontSize = _parent$computedStyle[FONT_SIZE$4],
                    _fontWeight = _parent$computedStyle[FONT_WEIGHT$3],
                    _fontFamily = _parent$computedStyle[FONT_FAMILY$3];

                if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
                  ctx.font = css.setFontStyle(parent.computedStyle);
                } // 再进行查找，这里也会有至少一个字符不用担心


                var _measureLineWidth7 = measureLineWidth(ctx, renderMode, 0, _length, _content, limit - ew + width - endSpace, perW, _fontFamily, _fontSize, _fontWeight, _letterSpacing),
                    _measureLineWidth8 = _slicedToArray(_measureLineWidth7, 2),
                    _num = _measureLineWidth8[0],
                    _rw = _measureLineWidth8[1]; // 可能发生x回退，当tb的内容产生减少时


                if (_num !== _content.length) {
                  tb.__content = _content.slice(0, _num);

                  if (isUpright) {
                    y -= height - _rw;
                    tb.__height = _rw;
                  } else {
                    x -= width - _rw;
                    tb.__width = _rw;
                  }
                } // 重新设置lineHeight和baseline，因为可能删除了东西


                lineBox.__resetLb(computedStyle[LINE_HEIGHT$4], isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle));

                var _ep = isUpright ? new Ellipsis(x, y + _rw + endSpace, ew, bp, isUpright) : new Ellipsis(x + _rw + endSpace, y, ew, bp, isUpright);

                lineBoxManager.addItem(_ep, true);

                if (isUpright) {
                  x += Math.max(_lineHeight, lineBoxManager.verticalLineHeight);
                } else {
                  y += Math.max(_lineHeight, lineBoxManager.lineHeight);
                }

                maxW = Math.max(maxW, _rw + ew);
                return [y, maxW];
              } // 舍弃这个tb，x也要向前回退，w增加，这会发生在ELLIPSIS字体很大，里面内容字体很小时


              var item = list.pop();

              if (isUpright) {
                limit += height;
                y -= height;
              } else {
                limit += width;
                x -= width;
              }

              var tbs = item.parent.textBoxes;
              var k = tbs.indexOf(item);

              if (k > -1) {
                tbs.splice(k, 1);
              } // 还得去掉dom，防止inline嵌套一直向上，同时得判断不能误删前面一个的dom


              var dom = item.parent.parent;
              var prev = list[list.length - 1];

              if (prev instanceof TextBox) {
                prev = prev.parent.parent;
              }

              while (dom !== bp && dom !== prev) {
                var _contentBoxList = dom.contentBoxList || [];

                var _i2 = _contentBoxList.indexOf(item);

                if (_i2 > -1) {
                  _contentBoxList.splice(_i2, 1);
                }

                var _computedStyle = dom.computedStyle;

                if (isUpright) {
                  var mbp = _computedStyle[MARGIN_TOP$5] + _computedStyle[MARGIN_BOTTOM$5] + _computedStyle[PADDING_TOP$5] + _computedStyle[PADDING_BOTTOM$4] + _computedStyle[BORDER_TOP_WIDTH$5] + _computedStyle[BORDER_BOTTOM_WIDTH$4];
                  y -= mbp;
                  limit += mbp;
                } else {
                  var _mbp = _computedStyle[MARGIN_LEFT$7] + _computedStyle[MARGIN_RIGHT$6] + _computedStyle[PADDING_LEFT$7] + _computedStyle[PADDING_RIGHT$6] + _computedStyle[BORDER_LEFT_WIDTH$7] + _computedStyle[BORDER_RIGHT_WIDTH$6];

                  x -= _mbp;
                  limit += _mbp;
                }

                dom.__layoutNone();

                dom = dom.domParent;
              }

              var contentBoxList = prev.contentBoxList || [];

              var _i = contentBoxList.indexOf(item);

              if (_i > -1) {
                contentBoxList.splice(_i, 1);
              }
            }
          }
        } // 本次回退不用向前追溯删除textBox会进这里，最少一个字符兜底


        var textBox = new TextBox(this, textBoxes.length, x, y, rw, lineHeight, content.slice(i, i + num), isUpright);
        textBoxes.push(textBox);
        lineBoxManager.addItem(textBox, false); // ELLIPSIS也作为内容加入，但特殊的是指向最近block使用其样式渲染

        var ep = isUpright ? new Ellipsis(x, y + rw + endSpace, ew, bp, isUpright) : new Ellipsis(x + rw + endSpace, y, ew, bp, isUpright);
        lineBoxManager.addItem(ep, true);

        if (isUpright) {
          x += Math.max(lineHeight, lineBoxManager.verticalLineHeight);
        } else {
          y += Math.max(lineHeight, lineBoxManager.lineHeight);
        }

        maxW = Math.max(maxW, rw + ew);
        return [isUpright ? x : y, maxW];
      } // 外部dom换行发现超行，且一定是ellipsis时，会进这里让上一行text回退，lineBox一定有值且最后一个一定是本text的最后的textBox

    }, {
      key: "__backtrack",
      value: function __backtrack(bp, lineBoxManager, lineBox, textBox, limit, endSpace, ew, computedStyle, ctx, renderMode, isUpright) {
        var list = lineBox.list;

        for (var j = list.length - 1; j >= 0; j--) {
          var tb = list[j]; // 可能是个inlineBlock，整个省略掉，除非是第一个不作ellipsis处理

          if (!(tb instanceof TextBox)) {
            if (!j) {
              break;
            }

            var _item2 = list.pop();

            limit += isUpright ? _item2.outerHeight : _item2.outerWidth;

            _item2.__layoutNone();

            continue;
          } // 先判断整个tb都删除是否可以容纳下，同时注意第1个tb不能删除因此必进


          var content = tb.content,
              width = tb.width,
              height = tb.height,
              parent = tb.parent;

          if (!j || limit >= width + ew + 1e-10 + endSpace) {
            var length = content.length;
            var _parent$computedStyle2 = parent.computedStyle,
                letterSpacing = _parent$computedStyle2[LETTER_SPACING$1],
                fontSize = _parent$computedStyle2[FONT_SIZE$4],
                fontWeight = _parent$computedStyle2[FONT_WEIGHT$3],
                fontFamily = _parent$computedStyle2[FONT_FAMILY$3];

            if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
              ctx.font = css.setFontStyle(parent.computedStyle);
            }

            var perW = fontSize * 0.8 + letterSpacing; // 再进行查找，这里也会有至少一个字符不用担心

            var _measureLineWidth9 = measureLineWidth(ctx, renderMode, 0, length, content, limit - ew - endSpace + width, perW, fontFamily, fontSize, fontWeight, letterSpacing),
                _measureLineWidth10 = _slicedToArray(_measureLineWidth9, 2),
                num = _measureLineWidth10[0],
                rw = _measureLineWidth10[1]; // 可能发生x回退，当tb的内容产生减少时


            if (num !== content.length) {
              tb.__content = content.slice(0, num);

              if (isUpright) {
                tb.__height = rw;
              } else {
                tb.__width = rw;
              }
            } // 重新设置lineHeight和baseline，因为可能删除了东西


            lineBox.__resetLb(computedStyle[LINE_HEIGHT$4], isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle));

            var ep = isUpright ? new Ellipsis(tb.x, tb.y + rw + endSpace, ew, bp, isUpright) : new Ellipsis(tb.x + rw + endSpace, tb.y, ew, bp, isUpright);
            lineBoxManager.addItem(ep, true);
            return;
          } // 舍弃这个tb，x也要向前回退，w增加，这会发生在ELLIPSIS字体很大，里面内容字体很小时


          var item = list.pop();
          limit += isUpright ? height : width;
          var tbs = item.parent.textBoxes;
          var k = tbs.indexOf(item);

          if (k > -1) {
            tbs.splice(k, 1);
          } // 还得去掉dom，防止inline嵌套一直向上，同时得判断不能误删前面一个的dom


          var dom = item.parent.parent;
          var prev = list[list.length - 1];

          if (prev instanceof TextBox) {
            prev = prev.parent.parent;
          }

          while (dom !== bp && dom !== prev) {
            var _contentBoxList2 = dom.contentBoxList || [];

            var _i3 = _contentBoxList2.indexOf(item);

            if (_i3 > -1) {
              _contentBoxList2.splice(_i3, 1);
            }

            var _computedStyle2 = dom.computedStyle;

            if (isUpright) {
              var mbp = _computedStyle2[MARGIN_TOP$5] + _computedStyle2[MARGIN_BOTTOM$5] + _computedStyle2[PADDING_TOP$5] + _computedStyle2[PADDING_BOTTOM$4] + _computedStyle2[BORDER_TOP_WIDTH$5] + _computedStyle2[BORDER_BOTTOM_WIDTH$4];
              limit += mbp;
            } else {
              var _mbp2 = _computedStyle2[MARGIN_LEFT$7] + _computedStyle2[MARGIN_RIGHT$6] + _computedStyle2[PADDING_LEFT$7] + _computedStyle2[PADDING_RIGHT$6] + _computedStyle2[BORDER_LEFT_WIDTH$7] + _computedStyle2[BORDER_RIGHT_WIDTH$6];

              limit += _mbp2;
            }

            dom.__layoutNone();

            dom = dom.domParent;
          }

          var contentBoxList = prev.contentBoxList || [];
          var i = contentBoxList.indexOf(item);

          if (i > -1) {
            contentBoxList.splice(i, 1);
          }
        }
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout) {
        _get(_getPrototypeOf(Text.prototype), "__offsetX", this).call(this, diff, isLayout);

        if (isLayout) {
          this.textBoxes.forEach(function (item) {
            item.__offsetX(diff);
          });
        }

        this.__sx1 += diff;
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout) {
        _get(_getPrototypeOf(Text.prototype), "__offsetY", this).call(this, diff, isLayout);

        if (isLayout) {
          this.textBoxes.forEach(function (item) {
            item.__offsetY(diff);
          });
        }

        this.__sy1 += diff;
      }
    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(total) {
        return total - this.firstCharWidth;
      }
    }, {
      key: "__inlineSize",
      value: function __inlineSize(isUpright) {
        var min, max;
        this.textBoxes.forEach(function (item, i) {
          if (i) {
            min = Math.min(min, isUpright ? item.y : item.x);
            max = Math.max(max, (isUpright ? item.y : item.x) + item.width);
          } else {
            min = isUpright ? item.y : item.x;
            max = (isUpright ? item.y : item.x) + item.width;
          }
        });

        if (isUpright) {
          this.__y = min;
          this.__sy = this.__sy1 = min + this.oy;
          this.__sx = this.__sx1;
          this.__height = max - min;
        } else {
          this.__x = min;
          this.__sx = this.__sx1 = min + this.ox;
          this.__sy = this.__sy1;
          this.__width = max - min;
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx) {
        var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var __isDestroyed = this.__isDestroyed,
            computedStyle = this.computedStyle,
            textBoxes = this.textBoxes,
            cacheStyle = this.cacheStyle;

        if (renderMode === SVG$2) {
          this.__virtualDom = {
            type: 'text',
            children: []
          };
        } // >=REPAINT清空bbox


        this.__bbox = null;
        this.__filterBbox = null;

        if (__isDestroyed || computedStyle[DISPLAY$7] === 'none' || computedStyle[VISIBILITY$5] === 'hidden' || !textBoxes.length) {
          this.__hasContent = false;
          return;
        }

        this.__hasContent = true;

        if (renderMode === WEBGL$2) {
          return;
        }

        if (renderMode === CANVAS$2) {
          var font = css.setFontStyle(computedStyle);

          if (ctx.font !== font) {
            ctx.font = font;
          }

          var color = cacheStyle[COLOR$3]; // 渐变

          if (color.k) {
            var dom = this.parent;
            color = dom.__gradient(renderMode, ctx, dom.__bx1, dom.__by1, dom.__bx2, dom.__by2, color, dx, dy).v;
          }

          if (ctx.fillStyle !== color) {
            ctx.fillStyle = color;
          }

          var strokeWidth = computedStyle[TEXT_STROKE_WIDTH$2];

          if (ctx.lineWidth !== strokeWidth) {
            ctx.lineWidth = strokeWidth;
          }

          var textStrokeColor = cacheStyle[TEXT_STROKE_COLOR$3]; // 渐变

          if (textStrokeColor.k) {
            var _dom = this.parent;
            textStrokeColor = _dom.__gradient(renderMode, ctx, _dom.__bx1, _dom.__by1, _dom.__bx2, _dom.__by2, textStrokeColor, dx, dy).v;
          }

          if (ctx.strokeStyle !== textStrokeColor) {
            ctx.strokeStyle = textStrokeColor;
          }
        } // 可能为空，整个是个ellipsis


        textBoxes.forEach(function (item) {
          item.render(renderMode, ctx, computedStyle, cacheStyle, dx, dy);
        });

        if (renderMode === SVG$2) {
          this.__virtualDom.children = textBoxes.map(function (textBox) {
            return textBox.virtualDom;
          });
        }
      }
    }, {
      key: "__deepScan",
      value: function __deepScan(cb) {
        cb(this);
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.__isDestroyed) {
          return;
        }

        _get(_getPrototypeOf(Text.prototype), "__destroy", this).call(this);

        var __cache = this.__cache;

        if (__cache) {
          __cache.release();
        }
      }
    }, {
      key: "getComputedStyle",
      value: function getComputedStyle(key) {
        return this.__domParent.getComputedStyle(key);
      }
    }, {
      key: "updateContent",
      value: function updateContent(s, cb) {
        if (s === this.__content || this.__isDestroyed) {
          this.__content = s;

          if (isFunction$a(cb)) {
            cb();
          }

          return;
        }

        this.__content = s;

        this.__root.__addUpdate(this.__domParent, {
          focus: o$1.REFLOW,
          cb: cb
        });
      }
    }, {
      key: "remove",
      value: function remove(cb) {
        var root = this.__root;
        var parent = this.isShadowRoot ? this.hostRoot.__parent : this.__parent;
        var i;

        if (parent) {
          var target = this.isShadowRoot ? this.hostRoot : this;
          i = parent.__children.indexOf(target);

          parent.__children.splice(i, 1);

          i = parent.__zIndexChildren.indexOf(target);

          parent.__zIndexChildren.splice(i, 1);

          var __prev = this.__prev,
              __next = this.__next;

          if (__prev) {
            __prev.__next = __next;
          }

          if (__next) {
            __next.__prev = __prev;
          }
        }

        if (this.__isDestroyed) {
          if (isFunction$a(cb)) {
            cb();
          }

          return;
        }

        parent.__deleteStruct(this, i); // 不可见仅改变数据结构


        if (this.computedStyle[DISPLAY$7] === 'none') {
          this.__destroy();

          if (isFunction$a(cb)) {
            cb();
          }

          return;
        } // 可见在reflow逻辑做结构关系等，text视为父变更


        var res = {
          focus: o$1.REFLOW,
          removeDom: true,
          cb: cb
        };

        root.__addUpdate(this, res);
      }
    }, {
      key: "content",
      get: function get() {
        return this.__content;
      },
      set: function set(v) {
        this.__content = v;
      }
    }, {
      key: "textBoxes",
      get: function get() {
        return this.__textBoxes;
      }
    }, {
      key: "charWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root = this.root,
            ctx = _this$root.ctx,
            renderMode = _this$root.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$4],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$1];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('charWidth')) {
          var max = 0;

          if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
            if (renderMode === WEBGL$2) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle);

            for (var i = 0, len = content.length; i < len; i++) {
              max = Math.max(max, ctx.measureText(content.charAt([i])).width);
            }
          } else if (renderMode === SVG$2) {
            max = inject.measureTextListMax(content, fontFamily, fontSize, fontWeight);
          }

          o.charWidth = max + letterSpacing;
        }

        return o.charWidth;
      }
    }, {
      key: "firstCharWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root2 = this.root,
            ctx = _this$root2.ctx,
            renderMode = _this$root2.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$4],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$1];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('firstCharWidth')) {
          if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
            if (renderMode === WEBGL$2) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle);
            o.firstCharWidth = ctx.measureText(content.charAt(0)).width + letterSpacing;
          } else if (renderMode === SVG$2) {
            o.firstCharWidth = inject.measureTextSync(content.charAt(0), fontFamily, fontSize, fontWeight) + letterSpacing;
          }
        }

        return o.firstCharWidth;
      }
    }, {
      key: "textWidth",
      get: function get() {
        var __widthHash = this.__widthHash,
            content = this.content,
            computedStyle = this.computedStyle,
            _this$root3 = this.root,
            ctx = _this$root3.ctx,
            renderMode = _this$root3.renderMode;
        var fontFamily = computedStyle[FONT_FAMILY$3],
            fontSize = computedStyle[FONT_SIZE$4],
            fontWeight = computedStyle[FONT_WEIGHT$3],
            letterSpacing = computedStyle[LETTER_SPACING$1];
        var fontKey = getFontKey(fontFamily, fontSize, fontWeight, letterSpacing);

        if (!__widthHash.hasOwnProperty(fontKey)) {
          __widthHash[fontKey] = {};
        }

        var o = __widthHash[fontKey];

        if (!o.hasOwnProperty('textWidth')) {
          if (renderMode === CANVAS$2 || renderMode === WEBGL$2) {
            if (renderMode === WEBGL$2) {
              ctx = inject.getFontCanvas().ctx;
            }

            ctx.font = css.setFontStyle(computedStyle);
            o.textWidth = ctx.measureText(content).width + letterSpacing * content.length;
          } else if (renderMode === SVG$2) {
            o.textWidth = inject.measureTextSync(content, fontFamily, fontSize, fontWeight) + letterSpacing * content.length;
          }
        }

        return o.textWidth;
      }
    }, {
      key: "clientWidth",
      get: function get() {
        return this.__width || 0;
      }
    }, {
      key: "clientHeight",
      get: function get() {
        return this.__height || 0;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this.__width || 0;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this.__height || 0;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__width || 0;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__height || 0;
      }
    }, {
      key: "root",
      get: function get() {
        return this.__domParent.__root;
      }
    }, {
      key: "currentStyle",
      get: function get() {
        return this.__domParent.__currentStyle;
      }
    }, {
      key: "style",
      get: function get() {
        return this.__domParent.__style;
      }
    }, {
      key: "computedStyle",
      get: function get() {
        return this.__domParent.__computedStyle;
      }
    }, {
      key: "cacheStyle",
      get: function get() {
        return this.__domParent.__cacheStyle;
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var __sx1 = this.__sx1,
              __sy1 = this.__sy1,
              width = this.width,
              height = this.height,
              textStrokeWidth = this.computedStyle[TEXT_STROKE_WIDTH$2]; // 文字描边暂时不清楚最大值是多少，影响不确定，先按描边宽算，因为会出现>>0.5宽的情况

          var half = textStrokeWidth;
          this.__bbox = [__sx1 - half, __sy1 - half, __sx1 + width + half, __sy1 + height + half];
        }

        return this.__bbox;
      }
    }, {
      key: "filterBbox",
      get: function get() {
        if (!this.__filterBbox) {
          var bbox = this.__bbox || this.bbox;
          var filter = this.computedStyle[FILTER$4];
          this.__filterBbox = css.spreadFilter(bbox, filter);
        }

        return this.__filterBbox;
      }
    }, {
      key: "isShadowRoot",
      get: function get() {
        return !this.__parent && this.__host && this.__host !== this.root;
      }
    }, {
      key: "matrix",
      get: function get() {
        return this.__domParent.__matrix;
      }
    }, {
      key: "matrixEvent",
      get: function get() {
        return this.__domParent.__matrixEvent;
      }
    }, {
      key: "perspectiveMatrix",
      get: function get() {
        return this.__domParent.__perspectiveMatrix;
      }
    }]);

    return Text;
  }(Node);

  var isFunction$9 = util.isFunction;

  var Event = /*#__PURE__*/function () {
    function Event() {
      this.__eHash = {};
    }

    _createClass(Event, [{
      key: "on",
      value: function on(id, handle) {
        if (!isFunction$9(handle)) {
          return;
        }

        var self = this;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.on(id[i], handle);
          }
        } else {
          if (!self.__eHash.hasOwnProperty(id)) {
            self.__eHash[id] = [];
          } // 遍历防止此handle被侦听过了


          for (var _i = 0, item = self.__eHash[id], _len = item.length; _i < _len; _i++) {
            if (item[_i] === handle) {
              return self;
            }
          }

          self.__eHash[id].push(handle);
        }

        return self;
      }
    }, {
      key: "once",
      value: function once(id, handle) {
        if (!isFunction$9(handle)) {
          return;
        }

        var self = this; // 包裹一层会导致添加后删除对比引用删不掉，需保存原有引用进行对比

        function cb() {
          for (var _len2 = arguments.length, data = new Array(_len2), _key = 0; _key < _len2; _key++) {
            data[_key] = arguments[_key];
          }

          handle.apply(self, data);
          self.off(id, cb);
        }

        cb.__karasEventCb = handle;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.once(id[i], handle);
          }
        } else if (handle) {
          self.on(id, cb);
        }

        return this;
      }
    }, {
      key: "off",
      value: function off(id, handle) {
        var self = this;

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.off(id[i], handle);
          }
        } else if (self.__eHash.hasOwnProperty(id)) {
          if (handle) {
            for (var _i2 = 0, item = self.__eHash[id], _len3 = item.length; _i2 < _len3; _i2++) {
              // 需考虑once包裹的引用对比
              if (item[_i2] === handle || item[_i2].__karasEventCb === handle) {
                item.splice(_i2, 1);
                break;
              }
            }
          } // 未定义为全部清除
          else {
            delete self.__eHash[id];
          }
        }

        return this;
      }
    }, {
      key: "emit",
      value: function emit(id) {
        var self = this;

        for (var _len4 = arguments.length, data = new Array(_len4 > 1 ? _len4 - 1 : 0), _key2 = 1; _key2 < _len4; _key2++) {
          data[_key2 - 1] = arguments[_key2];
        }

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            self.emit(id[i], data);
          }
        } else {
          if (self.__eHash.hasOwnProperty(id)) {
            var list = self.__eHash[id];

            if (list.length) {
              list = list.slice();

              for (var _i3 = 0, _len5 = list.length; _i3 < _len5; _i3++) {
                var cb = list[_i3];

                if (isFunction$9(cb)) {
                  cb.apply(self, data);
                }
              }
            }
          }
        }

        return this;
      }
    }], [{
      key: "mix",
      value: function mix() {
        for (var i = arguments.length - 1; i >= 0; i--) {
          var o = i < 0 || arguments.length <= i ? undefined : arguments[i];
          var event = new Event();
          o.__eHash = {};
          var fns = ['on', 'once', 'off', 'emit'];

          for (var j = fns.length - 1; j >= 0; j--) {
            var fn = fns[j];
            o[fn] = event[fn];
          }
        }
      }
    }]);

    return Event;
  }();

  _defineProperty(Event, "REFRESH", 'refresh');

  _defineProperty(Event, "PAUSE", 'pause');

  _defineProperty(Event, "PLAY", 'play');

  _defineProperty(Event, "FRAME", 'frame');

  _defineProperty(Event, "FINISH", 'finish');

  _defineProperty(Event, "CANCEL", 'cancel');

  _defineProperty(Event, "BEGIN", 'begin');

  _defineProperty(Event, "END", 'end');

  var isFunction$8 = util.isFunction,
      extend$2 = util.extend;
  var REGISTER$1 = {};

  var Component = /*#__PURE__*/function (_Event) {
    _inherits(Component, _Event);

    function Component() {
      var _this;

      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      _this = _Event.call(this) || this;
      _this.__tagName = /(?:function|class)\s+([\w$]+)/.exec(_this.constructor.toString())[1]; // 构建工具中都是arr，手写可能出现hash情况

      if (Array.isArray(props)) {
        _this.props = util.arr2hash(props);
      } else {
        _this.props = props;
      }

      _this.__parent = null;
      _this.__host = null;
      _this.__ref = {};
      _this.__isMounted = false;
      _this.__taskList = [];
      return _this;
    }
    /**
     * build中调用初始化，处理过flatten
     */


    _createClass(Component, [{
      key: "__init",
      value: function __init() {
        var _this2 = this;

        this.__ref = {};
        var sr = this.__shadowRoot;

        if (sr instanceof Text) ; else if (sr instanceof Node) {
          var style = css.normalize(this.props.style);
          var keys = Object.keys(style);
          extend$2(sr.style, style, keys);
          extend$2(sr.currentStyle, style, keys); // 事件添加到sr

          Object.keys(this.props).forEach(function (k) {
            var v = _this2.props[k];

            if (/^on[a-zA-Z]/.test(k)) {
              k = k.slice(2).toLowerCase();
              sr.listener[k] = v;
            }
          });
        } // 自定义事件无视返回强制添加


        Object.keys(this.props).forEach(function (k) {
          var v = _this2.props[k];

          if (/^on-[a-zA-Z\d_$]/.test(k)) {
            k = k.slice(3);

            _this2.on(k, v);
          }
        });

        if (isFunction$8(this.componentDidMount)) {
          this.__root.once(Event.REFRESH, function () {
            _this2.componentDidMount();
          });
        }
      }
    }, {
      key: "render",
      value: function render() {
        inject.warn('Component should implement render()');
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.__isDestroyed) {
          return;
        }

        this.__isDestroyed = true;
        this.__isMounted = false;

        if (isFunction$8(this.componentWillUnmount)) {
          this.componentWillUnmount();
        }

        if (this.__shadow) {
          this.__shadow.__destroy();
        }

        this.__host = this.__hostRoot = this.__shadow = this.__shadowRoot = this.__prev = this.__next = this.__root = this.__parent = this.__domParent = null;
      }
    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, force) {
        var sr = this.shadowRoot;

        if (sr instanceof Text) {
          return;
        }

        var res = sr.__emitEvent(e, force);

        if (res) {
          e.target = this;
          return true;
        }
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.__tagName;
      }
    }, {
      key: "shadow",
      get: function get() {
        return this.__shadow;
      }
    }, {
      key: "shadowRoot",
      get: function get() {
        return this.__shadowRoot;
      }
    }, {
      key: "root",
      get: function get() {
        return this.__root;
      }
    }, {
      key: "host",
      get: function get() {
        return this.__host;
      }
    }, {
      key: "hostRoot",
      get: function get() {
        return this.__hostRoot;
      }
    }, {
      key: "parent",
      get: function get() {
        return this.__parent;
      }
    }, {
      key: "prev",
      get: function get() {
        return this.__prev;
      }
    }, {
      key: "next",
      get: function get() {
        return this.__next;
      }
    }, {
      key: "ref",
      get: function get() {
        return this.__ref;
      }
    }, {
      key: "domParent",
      get: function get() {
        return this.__domParent;
      }
    }, {
      key: "state",
      get: function get() {
        return this.__state;
      },
      set: function set(v) {
        this.__state = v;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__isDestroyed;
      }
    }], [{
      key: "REGISTER",
      get: function get() {
        return REGISTER$1;
      }
    }, {
      key: "getRegister",
      value: function getRegister(name) {
        if (!name || !util.isString(name) || !/^[A-Z]/.test(name)) {
          throw new Error('Invalid param');
        }

        if (!REGISTER$1.hasOwnProperty(name)) {
          throw new Error("Component has not register: ".concat(name));
        }

        return REGISTER$1[name];
      }
    }, {
      key: "register",
      value: function register(name, obj) {
        if (!name || !util.isString(name) || !/^[A-Z]/.test(name) || !obj.prototype || !(obj.prototype instanceof Component)) {
          throw new Error('Invalid param: Component register');
        }

        if (Component.hasRegister(name)) {
          throw new Error("Component has already register: ".concat(name));
        }

        REGISTER$1[name] = obj;
      }
    }, {
      key: "hasRegister",
      value: function hasRegister(name) {
        return name && REGISTER$1.hasOwnProperty(name);
      }
    }, {
      key: "delRegister",
      value: function delRegister(name) {
        if (Component.hasRegister(name)) {
          delete REGISTER$1[name];
        }
      }
    }]);

    return Component;
  }(Event);

  Object.keys(o$2.GEOM).concat(['x', 'y', 'ox', 'oy', 'sx', 'sy', // '__sx1',
  // '__sx2',
  // '__sx3',
  // '__sx4',
  // '__sx5',
  // '__sx6',
  // '__sy1',
  // '__sy2',
  // '__sy3',
  // '__sy4',
  // '__sy5',
  // '__sy6',
  'width', 'height', 'outerWidth', 'outerHeight', 'clientWidth', 'clientHeight', 'offsetWidth', 'offsetHeight', 'style', 'animationList', 'animateStyle', 'currentStyle', 'computedStyle', 'currentProps', 'baseline', 'virtualDom', 'mask', 'maskId', 'textWidth', 'content', 'lineBoxes', 'charWidthList', 'charWidth', '__layoutData', '__struct', 'availableAnimating', 'effectiveAnimating', 'displayAnimating', 'visibilityAnimating', 'bbox', 'contentBoxList', 'listener', 'matrix', 'matrixEvent']).forEach(function (fn) {
    Object.defineProperty(Component.prototype, fn, {
      get: function get() {
        var sr = this.shadowRoot;

        if (sr) {
          return sr[fn];
        }
      }
    });
  });
  ['__layout', '__layoutFlow', '__layoutStyle', '__layoutAbs', '__layoutNone', '__tryLayInline', '__offsetX', '__offsetY', '__calAutoBasis', '__computeReflow', '__mp', 'animate', 'removeAnimate', 'clearAnimate', 'frameAnimate', 'updateStyle', 'getBoundingClientRect', 'getComputedStyle', '__deepScan', 'clearCache', '__structure', '__modifyStruct', '__updateStruct', 'flowChildren', 'absChildren', '__isRealInline', '__calBasis', '__calMinMax', '__computeMeasure', 'appendChild', 'prependChild', 'insertBefore', 'insertAfter', 'removeChild', 'remove'].forEach(function (fn) {
    Component.prototype[fn] = function () {
      var sr = this.shadowRoot;

      if (sr && isFunction$8(sr[fn])) {
        return sr[fn].apply(sr, arguments);
      }
    };
  });

  var _enums$STYLE_KEY$c = enums.STYLE_KEY,
      MARGIN_TOP$4 = _enums$STYLE_KEY$c.MARGIN_TOP,
      MARGIN_LEFT$6 = _enums$STYLE_KEY$c.MARGIN_LEFT,
      MARGIN_RIGHT$5 = _enums$STYLE_KEY$c.MARGIN_RIGHT,
      MARGIN_BOTTOM$4 = _enums$STYLE_KEY$c.MARGIN_BOTTOM,
      PADDING_TOP$4 = _enums$STYLE_KEY$c.PADDING_TOP,
      PADDING_LEFT$6 = _enums$STYLE_KEY$c.PADDING_LEFT,
      PADDING_RIGHT$5 = _enums$STYLE_KEY$c.PADDING_RIGHT,
      PADDING_BOTTOM$3 = _enums$STYLE_KEY$c.PADDING_BOTTOM,
      BORDER_TOP_WIDTH$4 = _enums$STYLE_KEY$c.BORDER_TOP_WIDTH,
      BORDER_LEFT_WIDTH$6 = _enums$STYLE_KEY$c.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$5 = _enums$STYLE_KEY$c.BORDER_RIGHT_WIDTH,
      BORDER_BOTTOM_WIDTH$3 = _enums$STYLE_KEY$c.BORDER_BOTTOM_WIDTH;
  /**
   * 获取inline的每一行内容的矩形坐标4个点，同时附带上border的矩形，比前面4个点尺寸大或相等（有无border/padding）
   * @param xom
   * @param isUpright
   * @param contentBoxList
   * @param start
   * @param end
   * @param lineBox
   * @param baseline
   * @param lineHeight
   * @param leading
   * @param isStart
   * @param isEnd
   * @param backgroundClip
   * @param paddingTop
   * @param paddingRight
   * @param paddingBottom
   * @param paddingLeft
   * @param borderTopWidth
   * @param borderRightWidth
   * @param borderBottomWidth
   * @param borderLeftWidth
   * @returns {(*|number)[]}
   */

  function getInlineBox(xom, isUpright, contentBoxList, start, end, lineBox, baseline, lineHeight, leading, isStart, isEnd, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth) {
    // 根据bgClip确定y伸展范围，inline渲染bg扩展到pb的位置不影响布局
    var bcStart = 0,
        bcEnd = 0;
    var pbStart = isUpright ? paddingLeft + borderLeftWidth : paddingTop + borderTopWidth;
    var pbEnd = isUpright ? paddingRight + borderRightWidth : paddingBottom + borderBottomWidth;

    if (backgroundClip === 'paddingBox') {
      bcStart = isUpright ? paddingLeft : paddingTop;
      bcEnd = isUpright ? paddingRight : paddingBottom;
    } else if (backgroundClip === 'borderBox') {
      bcStart = pbStart;
      bcEnd = pbEnd;
    } // inline的baseline和lineBox的差值，不同lh时造成的偏移，一般为多个textBox时比较小的那个发生
    // 垂直排版不能简单算baseline差值，因为原点坐标系不一样


    var diff;

    if (isUpright) {
      diff = lineBox.verticalBaseline - baseline;
    } else {
      diff = lineBox.baseline - baseline;
    }

    var x1, y1, x2, y2, bx1, by1, bx2, by2; // x坐标取首尾contentBox的左右2侧，clip布局时已算好；y是根据lineHeight和lineBox的高度以及baseline对齐后计算的
    // 垂直排版则互换x/y逻辑

    if (isUpright) {
      x1 = lineBox.x + diff - bcStart + leading;
      y1 = start.y;
      bx1 = lineBox.x + diff - pbStart + leading;
    } else {
      x1 = start.x;
      y1 = lineBox.y + diff - bcStart + leading;
      by1 = lineBox.y + diff - pbStart + leading;
    } // 容器内包含的inline节点，需考虑行首水平mbp（垂直排版为垂直头mbp）


    var dom = start instanceof TextBox ? start.parent.domParent : start.domParent;

    while (dom !== xom) {
      var list = dom.contentBoxList;

      if (start === list[0]) {
        if (isUpright) {
          var _dom$computedStyle = dom.computedStyle,
              marginTop = _dom$computedStyle[MARGIN_TOP$4],
              _paddingTop = _dom$computedStyle[PADDING_TOP$4],
              _borderTopWidth = _dom$computedStyle[BORDER_TOP_WIDTH$4];
          y1 -= marginTop + _paddingTop + _borderTopWidth;
        } else {
          var _dom$computedStyle2 = dom.computedStyle,
              marginLeft = _dom$computedStyle2[MARGIN_LEFT$6],
              _paddingLeft = _dom$computedStyle2[PADDING_LEFT$6],
              _borderLeftWidth = _dom$computedStyle2[BORDER_LEFT_WIDTH$6];
          x1 -= marginLeft + _paddingLeft + _borderLeftWidth;
        }
      }

      dom = dom.domParent;
    } // 第一个需考虑容器本身的padding/border


    if (isUpright) {
      by1 = y1;

      if (isStart) {
        by1 -= paddingTop + borderTopWidth;

        if (backgroundClip === 'paddingBox') {
          y1 -= paddingTop;
        } else if (backgroundClip === 'borderBox') {
          y1 -= paddingTop + borderTopWidth;
        }
      }

      x2 = lineBox.x + diff + lineHeight + bcEnd - leading;
      bx2 = lineBox.x + diff + lineHeight + pbEnd - leading;
      y2 = end.y + end.outerHeight;
    } else {
      bx1 = x1;

      if (isStart) {
        bx1 -= paddingLeft + borderLeftWidth;

        if (backgroundClip === 'paddingBox') {
          x1 -= paddingLeft;
        } else if (backgroundClip === 'borderBox') {
          x1 -= paddingLeft + borderLeftWidth;
        }
      }

      x2 = end.x + end.outerWidth;
      y2 = lineBox.y + diff + lineHeight + bcEnd - leading;
      by2 = lineBox.y + diff + lineHeight + pbEnd - leading;
    } // TextBox的parent是Text，再是Dom，这里一定是inline，无嵌套就是xom本身，有则包含若干层最上层还是xom


    dom = end instanceof TextBox ? end.parent.domParent : end.domParent; // 从end开始，向上获取dom节点的尾部mpb进行累加，直到xom跳出

    while (dom !== xom) {
      var _list = dom.contentBoxList;

      if (end === _list[_list.length - 1]) {
        if (isUpright) {
          var _dom$computedStyle3 = dom.computedStyle,
              marginBottom = _dom$computedStyle3[MARGIN_BOTTOM$4],
              _paddingBottom = _dom$computedStyle3[PADDING_BOTTOM$3],
              _borderBottomWidth = _dom$computedStyle3[BORDER_BOTTOM_WIDTH$3];
          y2 += marginBottom + _paddingBottom + _borderBottomWidth;
        } else {
          var _dom$computedStyle4 = dom.computedStyle,
              marginRight = _dom$computedStyle4[MARGIN_RIGHT$5],
              _paddingRight = _dom$computedStyle4[PADDING_RIGHT$5],
              _borderRightWidth = _dom$computedStyle4[BORDER_RIGHT_WIDTH$5];
          x2 += marginRight + _paddingRight + _borderRightWidth;
        }
      }

      dom = dom.domParent;
    }

    if (isUpright) {
      by2 = y2;

      if (isEnd) {
        by2 += paddingBottom + borderBottomWidth;

        if (backgroundClip === 'paddingBox') {
          y2 += paddingBottom;
        } else if (backgroundClip === 'borderBox') {
          y2 += paddingBottom + borderBottomWidth;
        }
      }
    } else {
      bx2 = x2;

      if (isEnd) {
        bx2 += paddingRight + borderRightWidth;

        if (backgroundClip === 'paddingBox') {
          x2 += paddingRight;
        } else if (backgroundClip === 'borderBox') {
          x2 += paddingRight + borderRightWidth;
        }
      }
    } // 要考虑xom的ox/oy值


    x1 += xom.ox;
    x2 += xom.ox;
    bx1 += xom.ox;
    bx2 += xom.ox;
    y1 += xom.oy;
    y2 += xom.oy;
    by1 += xom.oy;
    by2 += xom.oy;
    return [x1, y1, x2, y2, bx1, by1, bx2, by2];
  }
  /**
   * 统计inline的所有contentBox排成一行时的总宽度，考虑嵌套的mpb
   * @param xom
   * @param contentBoxList
   * @param isUpright
   * @returns {number}
   */


  function getInlineWidth(xom, contentBoxList, isUpright) {
    var sum = 0;
    var length = contentBoxList.length;

    if (contentBoxList[length - 1] instanceof Ellipsis) {
      length--;
    }

    for (var i = 0; i < length; i++) {
      var contentBox = contentBoxList[i];

      if (isUpright) {
        sum += contentBox.height;
      } else {
        sum += contentBox.width;
      } // 嵌套时，首尾box考虑mpb


      var dom = contentBox instanceof TextBox ? contentBox.parent.domParent : contentBox.domParent;

      while (dom !== xom) {
        var list = dom.contentBoxList;

        if (contentBox === list[0]) {
          if (isUpright) {
            var _dom$computedStyle5 = dom.computedStyle,
                marginTop = _dom$computedStyle5[MARGIN_TOP$4],
                paddingTop = _dom$computedStyle5[PADDING_TOP$4],
                borderTopWidth = _dom$computedStyle5[BORDER_TOP_WIDTH$4];
            sum += marginTop + paddingTop + borderTopWidth;
          } else {
            var _dom$computedStyle6 = dom.computedStyle,
                marginLeft = _dom$computedStyle6[MARGIN_LEFT$6],
                paddingLeft = _dom$computedStyle6[PADDING_LEFT$6],
                borderLeftWidth = _dom$computedStyle6[BORDER_LEFT_WIDTH$6];
            sum += marginLeft + paddingLeft + borderLeftWidth;
          }
        }

        if (contentBox === list[list.length - 1]) {
          if (isUpright) {
            var _dom$computedStyle7 = dom.computedStyle,
                marginBottom = _dom$computedStyle7[MARGIN_BOTTOM$4],
                paddingBottom = _dom$computedStyle7[PADDING_BOTTOM$3],
                borderBottomWidth = _dom$computedStyle7[BORDER_BOTTOM_WIDTH$3];
            sum += marginBottom + paddingBottom + borderBottomWidth;
          } else {
            var _dom$computedStyle8 = dom.computedStyle,
                marginRight = _dom$computedStyle8[MARGIN_RIGHT$5],
                paddingRight = _dom$computedStyle8[PADDING_RIGHT$5],
                borderRightWidth = _dom$computedStyle8[BORDER_RIGHT_WIDTH$5];
            sum += marginRight + paddingRight + borderRightWidth;
          }
        }

        dom = dom.domParent;
      }
    }

    return sum;
  }

  var inline = {
    getInlineBox: getInlineBox,
    getInlineWidth: getInlineWidth
  };

  var _enums$STYLE_KEY$b = enums.STYLE_KEY,
      SCALE_X$1 = _enums$STYLE_KEY$b.SCALE_X,
      SCALE_Y$1 = _enums$STYLE_KEY$b.SCALE_Y;
  var NUMBER$3 = o$4.NUMBER;

  function matrixResize(imgWidth, imgHeight, targetWidth, targetHeight, x, y, w, h) {
    if (imgWidth === targetWidth && imgHeight === targetHeight) {
      return;
    }

    var list = [{
      k: SCALE_X$1,
      v: {
        v: targetWidth / imgWidth,
        u: NUMBER$3
      }
    }, {
      k: SCALE_Y$1,
      v: {
        v: targetHeight / imgHeight,
        u: NUMBER$3
      }
    }];
    var tfo = [x, y];
    return transform.calMatrixWithOrigin(list, tfo, w, h);
  }

  var image = {
    matrixResize: matrixResize
  };

  var _enums$STYLE_KEY$a = enums.STYLE_KEY,
      BACKGROUND_POSITION_X$2 = _enums$STYLE_KEY$a.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$2 = _enums$STYLE_KEY$a.BACKGROUND_POSITION_Y;
  var clone$2 = util.clone,
      joinArr$2 = util.joinArr;
  var canvasPolygon$4 = painter.canvasPolygon,
      svgPolygon$4 = painter.svgPolygon;

  function renderBgc(xom, renderMode, ctx, color, list, x, y, w, h, btlr, btrr, bbrr, bblr) {
    var method = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 'fill';
    var isInline = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : false;
    var dx = arguments.length > 15 && arguments[15] !== undefined ? arguments[15] : 0;
    var dy = arguments.length > 16 && arguments[16] !== undefined ? arguments[16] : 0;
    // radial渐变ellipse形状会有matrix，用以从圆缩放到椭圆
    var matrix, cx, cy;

    if (Array.isArray(color)) {
      matrix = color[1];
      cx = color[2];
      cy = color[3];
      color = color[0];
    } // border-radius使用三次贝塞尔曲线模拟1/4圆角，误差在[0, 0.000273]之间


    list = list || border.calRadius(x, y, w, h, btlr, btrr, bbrr, bblr);

    if (!list) {
      list = [[x, y], [x + w, y], [x + w, y + h], [x, y + h], [x, y]];
    } // 椭圆有matrix，用逆矩阵变化点来完成


    if (matrix) {
      var tfo = [cx, cy];
      matrix = transform.calMatrixByOrigin(matrix, tfo);
      var t = mx.inverse(matrix);
      list = list.map(function (item) {
        if (!item || !item.length) {
          return null;
        }

        var arr = [];

        for (var i = 0, len = item.length; i < len; i += 2) {
          var p = mx.calPoint([item[i], item[i + 1]], t);
          arr.push(p[0]);
          arr.push(p[1]);
        }

        return arr;
      });
    }

    if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
      if (matrix) {
        ctx.save();
        var me = xom.matrixEvent;
        matrix = mx.multiply(me, matrix);
        ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
      }

      ctx.beginPath();

      if (ctx.fillStyle !== color) {
        ctx.fillStyle = color;
      }

      canvasPolygon$4(ctx, list, dx, dy);
      ctx[method]();
      ctx.closePath();

      if (matrix) {
        ctx.restore();
      }
    } else if (renderMode === mode.SVG) {
      var d = svgPolygon$4(list);

      if (isInline) {
        var v = {
          tagName: 'symbol',
          props: [],
          children: [{
            type: 'item',
            tagName: 'path',
            props: [['d', d], ['fill', color]]
          }]
        };

        xom.__cacheDefs.push(v);

        return ctx.add(v);
      } else {
        xom.virtualDom.bb.push({
          type: 'item',
          tagName: 'path',
          props: [['d', d], ['fill', color]]
        }); // 椭圆渐变独有

        if (matrix) {
          var bb = xom.virtualDom.bb;
          bb[bb.length - 1].props.push(['transform', "matrix(".concat(joinArr$2(mx.m2m6(matrix), ','), ")")]);
        }
      }
    }
  }

  function renderImage(xom, renderMode, ctx, loadBgi, bx1, by1, bx2, by2, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, isInline) {
    var dx = arguments.length > 17 && arguments[17] !== undefined ? arguments[17] : 0;
    var dy = arguments.length > 18 && arguments[18] !== undefined ? arguments[18] : 0;
    var source = loadBgi.source; // 无source不绘制，可能错误或加载中

    if (source) {
      bx1 += dx;
      by1 += dy;
      bx2 += dx;
      by2 += dy;
      var bgW = bx2 - bx1;
      var bgH = by2 - by1;
      var width = loadBgi.width,
          height = loadBgi.height;

      var _ref = backgroundSize[i] || [],
          _ref2 = _slicedToArray(_ref, 2),
          w = _ref2[0],
          h = _ref2[1]; // -1为auto，-2为contain，-3为cover


      if (w === -1 && h === -1) {
        w = width;
        h = height;
      } else if (w === -2) {
        if (width > bgW && height > bgH) {
          w = width / bgW;
          h = height / bgH;

          if (w >= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        } else if (width > bgW) {
          w = bgW;
          h = w * height / width;
        } else if (height > bgH) {
          h = bgH;
          w = h * width / height;
        } else {
          w = width;
          h = height;
        }
      } else if (w === -3) {
        if (bgW > width && bgH > height) {
          w = width / bgW;
          h = height / bgH;

          if (w <= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        } else if (bgW > width) {
          w = bgW;
          h = w * height / width;
        } else if (bgH > height) {
          h = bgH;
          w = h * width / height;
        } else {
          w = width / bgW;
          h = height / bgH;

          if (w <= h) {
            w = bgW;
            h = w * height / width;
          } else {
            h = bgH;
            w = h * width / height;
          }
        }
      } else if (w === -1) {
        w = h * width / height;
      } else if (h === -1) {
        h = w * height / width;
      }

      var bgX = computedStyle[BACKGROUND_POSITION_X$2][i] || 0;

      if (/%/.test(bgX)) {
        bgX = (bgW - w) * parseFloat(bgX) * 0.01;
      }

      bgX += bx1;
      var bgY = computedStyle[BACKGROUND_POSITION_Y$2][i] || 0;

      if (/%/.test(bgY)) {
        bgY = (bgH - h) * parseFloat(bgY) * 0.01;
      }

      bgY += by1; // 超出尺寸模拟mask截取

      var needMask = bgX < bx1 || bgY < by1 || bgX + w > bx1 + bgW || bgY + h > by1 + bgH; // 计算因为repeat，需要向4个方向扩展渲染几个数量图片

      var xnl = 0;
      var xnr = 0;
      var ynt = 0;
      var ynb = 0; // repeat-x

      if (['repeatX', 'repeat'].indexOf(backgroundRepeat[i]) > -1) {
        var diff = bgX - bx1;

        if (diff > 0) {
          xnl = Math.ceil(diff / w);
        }

        diff = bx1 + bgW - bgX - w;

        if (diff > 0) {
          xnr = Math.ceil(diff / w);
        }
      } // repeat-y


      if (['repeatY', 'repeat'].indexOf(backgroundRepeat[i]) > -1) {
        var _diff = bgY - by1;

        if (_diff > 0) {
          ynt = Math.ceil(_diff / h);
        }

        _diff = by1 + bgH - bgY - h;

        if (_diff > 0) {
          ynb = Math.ceil(_diff / h);
        }
      } // 分同行列和4个角分别判断，先看同行同列，再看4个角的象限


      var repeat = [];

      if (xnl > 0) {
        for (var _i = 0; _i < xnl; _i++) {
          var x = bgX - (_i + 1) * w;
          repeat.push([x, bgY]); // 看最左边超过没有

          if (!needMask && _i === 0 && x < bx1) {
            needMask = true;
          }
        }
      }

      if (xnr > 0) {
        for (var _i2 = 0; _i2 < xnr; _i2++) {
          var _x = bgX + (_i2 + 1) * w;

          repeat.push([_x, bgY]); // 看最右边超过没有

          if (!needMask && _i2 === xnr - 1 && _x + w > bx1 + bgW) {
            needMask = true;
          }
        }
      }

      if (ynt > 0) {
        for (var _i3 = 0; _i3 < ynt; _i3++) {
          var y = bgY - (_i3 + 1) * h;
          repeat.push([bgX, y]); // 看最上边超过没有

          if (!needMask && _i3 === 0 && y < by1) {
            needMask = true;
          }
        }
      }

      if (ynb > 0) {
        for (var _i4 = 0; _i4 < ynb; _i4++) {
          var _y = bgY + (_i4 + 1) * h;

          repeat.push([bgX, _y]); // 看最下边超过没有

          if (!needMask && _i4 === ynb - 1 && _y + w > by1 + bgH) {
            needMask = true;
          }
        }
      } // 原点和同行列十字画完，看4个角的情况


      if (xnl > 0 && ynt > 0) {
        for (var _i5 = 0; _i5 < xnl; _i5++) {
          for (var j = 0; j < ynt; j++) {
            repeat.push([bgX - (_i5 + 1) * w, bgY - (j + 1) * h]);
          }
        }
      }

      if (xnr > 0 && ynt > 0) {
        for (var _i6 = 0; _i6 < xnr; _i6++) {
          for (var _j = 0; _j < ynt; _j++) {
            repeat.push([bgX + (_i6 + 1) * w, bgY - (_j + 1) * h]);
          }
        }
      }

      if (xnl > 0 && ynb > 0) {
        for (var _i7 = 0; _i7 < xnl; _i7++) {
          for (var _j2 = 0; _j2 < ynb; _j2++) {
            repeat.push([bgX - (_i7 + 1) * w, bgY + (_j2 + 1) * h]);
          }
        }
      }

      if (xnr > 0 && ynb > 0) {
        for (var _i8 = 0; _i8 < xnr; _i8++) {
          for (var _j3 = 0; _j3 < ynb; _j3++) {
            repeat.push([bgX + (_i8 + 1) * w, bgY + (_j3 + 1) * h]);
          }
        }
      }

      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        if (needMask) {
          ctx.save();
          renderBgc(this, renderMode, ctx, '#FFF', null, bx1, by1, bgW, bgH, btlr, btrr, bbrr, bblr, 'clip');
        } // 先画不考虑repeat的中心声明的


        ctx.drawImage(source, bgX, bgY, w, h); // 再画重复的十字和4角象限

        repeat.forEach(function (item) {
          ctx.drawImage(source, item[0], item[1], w, h);
        });

        if (needMask) {
          ctx.restore();
        }
      } else if (renderMode === mode.SVG) {
        var matrix = image.matrixResize(width, height, w, h, bgX, bgY, bgW, bgH);
        var props = [['xlink:href', loadBgi.url], ['x', bgX], ['y', bgY], ['width', width], ['height', height]];
        var needResize;

        if (matrix && !mx.isE(matrix)) {
          needResize = true;
          props.push(['transform', 'matrix(' + joinArr$2(mx.m2m6(matrix), ',') + ')']);
        }

        if (needMask) {
          var p1 = [bx1, by1];
          var p2 = [bx2, by2];

          if (needResize) {
            var inverse = mx.inverse(matrix);
            p1 = mx.calPoint(p1, inverse);
            p2 = mx.calPoint(p2, inverse);
          }

          var v = {
            tagName: 'clipPath',
            children: [{
              tagName: 'path',
              props: [['d', "M".concat(p1[0], ",").concat(p1[1], "L").concat(p2[0], ",").concat(p1[1], "L").concat(p2[0], ",").concat(p2[1], "L").concat(p1[0], ",").concat(p2[1], "L").concat(p1[0], ",").concat(p1[1])], ['fill', '#FFF']]
            }]
          };
          var id = ctx.add(v);

          xom.__cacheDefs.push(v);

          props.push(['clip-path', 'url(#' + id + ')']);
        }

        if (isInline) {
          var _v = {
            tagName: 'symbol',
            props: [],
            children: [{
              type: 'img',
              tagName: 'image',
              props: props
            }]
          };

          xom.__cacheDefs.push(_v);

          repeat.forEach(function (item) {
            var copy = clone$2(props);

            if (needResize) {
              var _matrix = image.matrixResize(width, height, w, h, item[0], item[1], bgW, bgH);

              if (_matrix && !mx.isE(_matrix)) {
                copy[5][1] = 'matrix(' + joinArr$2(mx.m2m6(_matrix), ',') + ')';
              }
            }

            copy[1][1] = item[0];
            copy[2][1] = item[1];

            _v.children.push({
              type: 'img',
              tagName: 'image',
              props: copy
            });
          });
          return ctx.add(_v);
        } else {
          // 先画不考虑repeat的中心声明的
          xom.virtualDom.bb.push({
            type: 'img',
            tagName: 'image',
            props: props
          }); // 再画重复的十字和4角象限

          repeat.forEach(function (item) {
            var copy = clone$2(props);

            if (needResize) {
              var _matrix2 = image.matrixResize(width, height, w, h, item[0], item[1], bgW, bgH);

              if (_matrix2 && !mx.isE(_matrix2)) {
                copy[5][1] = 'matrix(' + joinArr$2(mx.m2m6(_matrix2), ',') + ')';
              }
            }

            copy[1][1] = item[0];
            copy[2][1] = item[1];
            xom.virtualDom.bb.push({
              type: 'img',
              tagName: 'image',
              props: copy
            });
          });
        }
      }
    }
  }

  var bg = {
    renderBgc: renderBgc,
    renderImage: renderImage
  };

  var isFunction$7 = util.isFunction;

  function traversal(list, length, diff, after) {
    if (after) {
      for (var i = 0; i < length; i++) {
        var item = list[i];
        item.__after && item.__after(diff);
      }
    } else {
      for (var _i = 0; _i < length; _i++) {
        var _item = list[_i];
        _item.__before && _item.__before(diff);
      }
    }
  }

  var isPause;

  var Frame = /*#__PURE__*/function () {
    function Frame() {
      this.__rootTask = []; // 动画刷新后，每个root注册的刷新回调执行

      this.__task = [];
      this.__now = null;
    }

    _createClass(Frame, [{
      key: "__init",
      value: function __init() {
        var self = this;
        var task = self.task;
        inject.cancelAnimationFrame(self.id);
        var last = self.__now = inject.now();

        function cb() {
          // 必须清除，可能会发生重复，当动画finish回调中gotoAndPlay(0)，下方结束判断发现aTask还有值会继续，新的init也会进入再次执行
          inject.cancelAnimationFrame(self.id);
          self.id = inject.requestAnimationFrame(function () {
            if (isPause || !task.length) {
              return;
            }

            var now = self.__now = inject.now();
            var diff = now - last;
            diff = Math.max(diff, 0); // let delta = diff * 0.06; // 比例是除以1/60s，等同于*0.06

            last = now; // 优先动画计算

            var clone = task.slice(0);
            var length = clone.length; // 普通的before/after，动画计算在before，所有回调在after

            traversal(clone, length, diff, false);

            var list = self.__rootTask.splice(0);

            for (var i = 0, len = list.length; i < len; i++) {
              var item = list[i];
              item && item(diff);
            } // 刷新成功后调用after，确保图像生成


            traversal(clone, length, diff, true); // 执行每个Root的刷新并清空
            // 还有则继续，没有则停止节省性能

            if (task.length) {
              cb();
            }
          });
        }

        cb();
      }
    }, {
      key: "onFrame",
      value: function onFrame(handle) {
        if (!handle) {
          return;
        }

        var task = this.task;

        if (!task.length) {
          this.__init();
        }

        if (isFunction$7(handle)) {
          handle = {
            __after: handle,
            __karasFramecb: handle
          };
        }

        task.push(handle);
      }
    }, {
      key: "offFrame",
      value: function offFrame(handle) {
        if (!handle) {
          return;
        }

        var task = this.task;

        for (var i = 0, len = task.length; i < len; i++) {
          var item = task[i]; // 需考虑nextFrame包裹的引用对比

          if (item === handle || item.__karasFramecb === handle) {
            task.splice(i, 1);
            break;
          }
        }

        if (!task.length) {
          inject.cancelAnimationFrame(this.id);
          this.__now = null;
        }
      }
    }, {
      key: "nextFrame",
      value: function nextFrame(handle) {
        var _this = this;

        if (!handle) {
          return;
        } // 包裹一层会导致添加后删除对比引用删不掉，需保存原有引用进行对比


        var cb = isFunction$7(handle) ? {
          __after: function __after(diff) {
            handle(diff);

            _this.offFrame(cb);
          }
        } : {
          __before: handle.__before,
          __after: function __after(diff) {
            handle.__after && handle.__after(diff);

            _this.offFrame(cb);
          }
        };
        cb.__karasFramecb = handle;
        this.onFrame(cb);
      }
    }, {
      key: "pause",
      value: function pause() {
        isPause = true;
      }
    }, {
      key: "resume",
      value: function resume() {
        if (isPause) {
          this.__init();

          isPause = false;
        }
      }
    }, {
      key: "task",
      get: function get() {
        return this.__task;
      }
    }]);

    return Frame;
  }();

  var frame = new Frame();

  /**
   * https://github.com/gre/bezier-easing
   * BezierEasing - use bezier curve for transition easing function
   * by Gaëtan Renaudeau 2014 - 2015 – MIT License
   */
  // These values are established by empiricism with tests (tradeoff: performance VS precision)
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 0.001;
  var SUBDIVISION_PRECISION = 0.0000001;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);
  var float32ArraySupported = typeof Float32Array === 'function';

  function A(aA1, aA2) {
    return 1.0 - 3.0 * aA2 + 3.0 * aA1;
  }

  function B(aA1, aA2) {
    return 3.0 * aA2 - 6.0 * aA1;
  }

  function C(aA1) {
    return 3.0 * aA1;
  } // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.


  function calcBezier(aT, aA1, aA2) {
    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
  } // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.


  function getSlope(aT, aA1, aA2) {
    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
  }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX,
        currentT,
        i = 0;

    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;

      if (currentX > 0.0) {
        aB = currentT;
      } else {
        aA = currentT;
      }
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);

    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);

      if (currentSlope === 0.0) {
        return aGuessT;
      }

      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }

    return aGuessT;
  }

  function LinearEasing(x) {
    return x;
  }

  function bezier(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
      throw new Error('bezier x values must be in [0, 1] range');
    }

    if (mX1 === mY1 && mX2 === mY2) {
      return LinearEasing;
    } // Precompute samples table


    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);

    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }

    function getTForX(aX) {
      var intervalStart = 0.0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample; // Interpolate to provide an initial guess for t

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= NEWTON_MIN_SLOPE) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    }

    return function BezierEasing(x) {
      // Because JavaScript number are imprecise, we should guarantee the extremes are right.
      if (x === 0 || x === 1) {
        return x;
      }

      return calcBezier(getTForX(x), mY1, mY2);
    };
  }

  var easing = {
    linear: bezier(1, 1, 0, 0),
    easeIn: bezier(0.42, 0, 1, 1),
    easeOut: bezier(0, 0, 0.58, 1),
    ease: bezier(0.25, 0.1, 0.25, 1),
    easeInOut: bezier(0.42, 0, 0.58, 1),
    cubicBezier: bezier,
    getEasing: function getEasing(v, v1, v2, v3) {
      if (arguments.length === 4) {
        return bezier(v, v1, v2, v3);
      } else if (Array.isArray(v) && v.length === 4) {
        return bezier(v[0], v[1], v[2], v[3]);
      } else if (v) {
        v = v.toString();
        var timingFunction;

        if (/^\s*(?:cubic-bezier\s*)?\(\s*[\d.]+\s*,\s*[-\d.]+\s*,\s*[\d.]+\s*,\s*[-\d.]+\s*\)\s*$/i.test(v)) {
          v = v.match(/[\d.]+/g);
          timingFunction = bezier(v[0], v[1], v[2], v[3]);
        } else if (v !== 'getEasing') {
          timingFunction = this[v];
        }

        return timingFunction;
      }
    }
  };
  easing['ease-in'] = easing.easeIn;
  easing['ease-out'] = easing.easeOut;
  easing['ease-in-out'] = easing.easeInOut;

  var _enums$STYLE_KEY$9 = enums.STYLE_KEY,
      FILTER$3 = _enums$STYLE_KEY$9.FILTER,
      TRANSFORM_ORIGIN$3 = _enums$STYLE_KEY$9.TRANSFORM_ORIGIN,
      PERSPECTIVE_ORIGIN$2 = _enums$STYLE_KEY$9.PERSPECTIVE_ORIGIN,
      BACKGROUND_CLIP$1 = _enums$STYLE_KEY$9.BACKGROUND_CLIP,
      BACKGROUND_POSITION_X$1 = _enums$STYLE_KEY$9.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y$1 = _enums$STYLE_KEY$9.BACKGROUND_POSITION_Y,
      BOX_SHADOW$1 = _enums$STYLE_KEY$9.BOX_SHADOW,
      TRANSLATE_X$1 = _enums$STYLE_KEY$9.TRANSLATE_X,
      TRANSLATE_Y$1 = _enums$STYLE_KEY$9.TRANSLATE_Y,
      TRANSLATE_Z$1 = _enums$STYLE_KEY$9.TRANSLATE_Z,
      BACKGROUND_SIZE$1 = _enums$STYLE_KEY$9.BACKGROUND_SIZE,
      FONT_SIZE$3 = _enums$STYLE_KEY$9.FONT_SIZE,
      FLEX_BASIS$3 = _enums$STYLE_KEY$9.FLEX_BASIS,
      FLEX_DIRECTION$2 = _enums$STYLE_KEY$9.FLEX_DIRECTION,
      WIDTH$6 = _enums$STYLE_KEY$9.WIDTH,
      HEIGHT$6 = _enums$STYLE_KEY$9.HEIGHT,
      TOP$4 = _enums$STYLE_KEY$9.TOP,
      BOTTOM$4 = _enums$STYLE_KEY$9.BOTTOM,
      LINE_HEIGHT$3 = _enums$STYLE_KEY$9.LINE_HEIGHT,
      OPACITY$4 = _enums$STYLE_KEY$9.OPACITY,
      Z_INDEX$3 = _enums$STYLE_KEY$9.Z_INDEX,
      TRANSFORM$4 = _enums$STYLE_KEY$9.TRANSFORM,
      COLOR$2 = _enums$STYLE_KEY$9.COLOR,
      FONT_WEIGHT$2 = _enums$STYLE_KEY$9.FONT_WEIGHT,
      FONT_STYLE$1 = _enums$STYLE_KEY$9.FONT_STYLE,
      FONT_FAMILY$2 = _enums$STYLE_KEY$9.FONT_FAMILY,
      TEXT_ALIGN$2 = _enums$STYLE_KEY$9.TEXT_ALIGN,
      MATRIX$2 = _enums$STYLE_KEY$9.MATRIX,
      ROTATE_3D$1 = _enums$STYLE_KEY$9.ROTATE_3D,
      TRANSLATE_PATH = _enums$STYLE_KEY$9.TRANSLATE_PATH,
      TEXT_STROKE_COLOR$2 = _enums$STYLE_KEY$9.TEXT_STROKE_COLOR,
      TEXT_STROKE_OVER$2 = _enums$STYLE_KEY$9.TEXT_STROKE_OVER,
      STROKE_WIDTH$7 = _enums$STYLE_KEY$9.STROKE_WIDTH;
  var AUTO$5 = o$4.AUTO,
      PX$6 = o$4.PX,
      PERCENT$5 = o$4.PERCENT,
      INHERIT$2 = o$4.INHERIT,
      RGBA$2 = o$4.RGBA,
      STRING$1 = o$4.STRING,
      NUMBER$2 = o$4.NUMBER,
      REM$5 = o$4.REM,
      VW$5 = o$4.VW,
      VH$5 = o$4.VH,
      VMAX$5 = o$4.VMAX,
      VMIN$5 = o$4.VMIN,
      GRADIENT$2 = o$4.GRADIENT,
      calUnit = o$4.calUnit;
  var isNil$a = util.isNil,
      isFunction$6 = util.isFunction,
      isNumber = util.isNumber,
      isObject$1 = util.isObject,
      clone$1 = util.clone,
      equalArr = util.equalArr;
  var linear = easing.linear;
  var cloneStyle = css.cloneStyle,
      equalStyle$1 = css.equalStyle;
  var isGeom$1 = o$2.isGeom,
      GEOM$1 = o$2.GEOM;
  var isColorKey = key.isColorKey,
      isExpandKey = key.isExpandKey,
      isLengthKey = key.isLengthKey,
      isGradientKey = key.isGradientKey,
      isRadiusKey = key.isRadiusKey;

  function unify(frames, target) {
    var hash = {};
    var keys = []; // 获取所有关键帧的属性

    frames.forEach(function (item) {
      var style = item.style;
      Object.keys(style).forEach(function (k) {
        var v = style[k]; // 未定义的过滤掉，null空有意义

        if (v !== undefined && !hash.hasOwnProperty(k)) {
          hash[k] = true; // geom为属性字符串，style都为枚举int

          if (!GEOM$1.hasOwnProperty(k)) {
            k = parseInt(k);
          } // path动画要转为translateXY，所以手动添加，使2帧之间存在过渡，有可能之前已存在这个动画，可忽视


          if (k === TRANSLATE_PATH) {
            if (!hash.hasOwnProperty(TRANSLATE_X$1)) {
              keys.push(TRANSLATE_X$1);
            }

            if (!hash.hasOwnProperty(TRANSLATE_Y$1)) {
              keys.push(TRANSLATE_Y$1);
            }

            hash[TRANSLATE_X$1] = hash[TRANSLATE_Y$1] = true;
          }

          keys.push(k);
        }
      });
    }); // 添补没有声明完全的关键帧属性为节点当前值

    frames.forEach(function (item) {
      var style = item.style;
      keys.forEach(function (k) {
        if (!style.hasOwnProperty(k) || isNil$a(style[k])) {
          if (GEOM$1.hasOwnProperty(k)) {
            style[k] = clone$1(target.getProps(k));
          } else {
            if (k === TRANSLATE_X$1 && style.hasOwnProperty(TRANSLATE_PATH)) {
              style[k] = clone$1(style[TRANSLATE_PATH][0]);
            } else if (k === TRANSLATE_Y$1 && style.hasOwnProperty(TRANSLATE_PATH)) {
              style[k] = clone$1(style[TRANSLATE_PATH][1]);
            } else {
              style[k] = cloneStyle(target.__currentStyle, [k])[k];
            }
          }
        }
      });
    });
    return keys;
  } // 每次初始化时处理继承值，以及转换transform为单matrix矩阵


  function inherit(frames, keys, target) {
    var computedStyle = target.__computedStyle;
    frames.forEach(function (item) {
      var style = item.style;
      keys.forEach(function (k) {
        var v = style[k]; // geom的属性可能在帧中没有

        if (isNil$a(v)) {
          return;
        }

        if (k === TRANSFORM$4) {
          var ow = target.__outerWidth;
          var oh = target.__outerHeight;
          var m = transform.calMatrix(v, ow, oh);
          style[k] = [{
            k: MATRIX$2,
            v: m
          }];
        } else if (v.u === INHERIT$2) {
          if (k === COLOR$2 || k === TEXT_STROKE_COLOR$2) {
            style[k] = {
              v: util.rgba2int(computedStyle[k]),
              u: RGBA$2
            };
          } else if (isLengthKey(k)) {
            style[k] = {
              v: computedStyle[k],
              u: PX$6
            };
          } else if (k === FONT_WEIGHT$2) {
            style[k] = {
              v: computedStyle[k],
              u: NUMBER$2
            };
          } else if (k === FONT_STYLE$1 || k === FONT_FAMILY$2 || k === TEXT_ALIGN$2 || k === TEXT_STROKE_OVER$2) {
            style[k] = {
              v: computedStyle[k],
              u: STRING$1
            };
          }
        }
      });
      item.clone = cloneStyle(style);
    });
  }
  /**
   * 通知root更新当前动画，需要根据frame的状态来决定是否是同步插入
   * 在异步时，因为动画本身是异步，需要addRefreshTask
   * 而如果此时frame在执行before过程中，说明帧动画本身是在before计算的，需要同步插入
   * @param keys 样式所有的key
   * @param root
   * @param node
   * @param cb
   */


  function genBeforeRefresh(keys, root, node, cb) {
    root.__addUpdate(node, {
      keys: keys,
      cb: cb
    });
  }
  /**
   * 将每帧的样式格式化，提取出offset属性并转化为时间，提取出缓动曲线easing
   * 加好空数组transition/keys，后续计算两帧之间变化时存入
   * 加好空数组fixed，后续计算无帧变化时存入
   * @param style 关键帧样式
   * @param duration 动画时间长度
   * @param es options的easing曲线控制，frame没有自定义则使用全局的
   */


  function framing(style, duration, es) {
    var _style = style,
        offset = _style.offset,
        easing = _style.easing; // 这两个特殊值提出来存储不干扰style

    delete style.offset;
    delete style.easing; // translatePath特殊对待，ae的曲线运动动画，普通css不包含，特殊处理并添加到style最后

    var translatePath = style.translatePath;
    style = css.normalize(style);

    if (Array.isArray(translatePath) && [6, 8].indexOf(translatePath.length) > -1) {
      style[TRANSLATE_PATH] = translatePath.map(function (item) {
        var v = calUnit(item);

        if (v.u === NUMBER$2) {
          v.u = PX$6;
        }

        return v;
      });
    }

    return {
      style: style,
      time: offset * duration,
      easing: easing || es,
      timingFunction: getEasing(easing || es),
      transition: [],
      // 变化的属性
      keys: [],
      // 变化的k
      fixed: [] // 不变的k

    };
  }

  function calByUnit(p, n, container, root) {
    if (p.u === PX$6) {
      if (n.u === PERCENT$5) {
        return n.v * 0.01 * container - p.v;
      } else if (n.u === REM$5) {
        return n.v * root.computedStyle[FONT_SIZE$3] - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.width * 0.01 - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.height * 0.01 - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.width, root.height) * 0.01 - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.width, root.height) * 0.01 - p.v;
      }
    } else if (p.u === PERCENT$5) {
      if (n.u === PX$6) {
        return n.v * 100 / container - p.v;
      } else if (n.u === REM$5) {
        return n.v * root.computedStyle[FONT_SIZE$3] * 100 / container - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.width / container - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.height / container - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.width, root.height) / container - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.width, root.height) / container - p.v;
      }
    } else if (p.u === REM$5) {
      if (n.u === PX$6) {
        return n.v / root.computedStyle[FONT_SIZE$3] - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * 0.01 * container / root.computedStyle[FONT_SIZE$3] - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.width * 0.01 / root.computedStyle[FONT_SIZE$3] - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.height * 0.01 / root.computedStyle[FONT_SIZE$3] - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.width, root.height) * 0.01 / root.computedStyle[FONT_SIZE$3] - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.width, root.height) * 0.01 / root.computedStyle[FONT_SIZE$3] - p.v;
      }
    } else if (p.u === VW$5) {
      if (n.u === PX$6) {
        return n.v * 100 / root.width - p.v;
      } else if (n.u === REM$5) {
        return n.v * 100 * root.computedStyle[FONT_SIZE$3] / root.width - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * container / root.width - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.height / root.width - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.width, root.height) / root.width - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.width, root.height) / root.width - p.v;
      }
    } else if (p.u === VH$5) {
      if (n.u === PX$6) {
        return n.v * 100 / root.height - p.v;
      } else if (n.u === REM$5) {
        return n.v * 100 * root.computedStyle[FONT_SIZE$3] / root.height - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.width / root.height - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * container / root.height - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.width, root.height) / root.height - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.width, root.height) / root.height - p.v;
      }
    } else if (p.u === VMAX$5) {
      if (n.u === PX$6) {
        return n.v * 100 / Math.max(root.width, root.height) - p.v;
      } else if (n.u === REM$5) {
        return n.v * 100 * root.computedStyle[FONT_SIZE$3] / Math.max(root.width, root.height) - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * container / Math.max(root.width, root.height) - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.width / Math.max(root.width, root.height) - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.height / Math.max(root.width, root.height) - p.v;
      } else if (n.u === VMIN$5) {
        return n.v * Math.min(root.width, root.height) / Math.max(root.width, root.height) - p.v;
      }
    } else if (p.u === VMIN$5) {
      if (n.u === PX$6) {
        return n.v * 100 / Math.min(root.width, root.height) - p.v;
      } else if (n.u === REM$5) {
        return n.v * 100 * root.computedStyle[FONT_SIZE$3] / Math.min(root.width, root.height) - p.v;
      } else if (n.u === PERCENT$5) {
        return n.v * container / Math.min(root.width, root.height) - p.v;
      } else if (n.u === VW$5) {
        return n.v * root.width / Math.min(root.width, root.height) - p.v;
      } else if (n.u === VH$5) {
        return n.v * root.height / Math.min(root.width, root.height) - p.v;
      } else if (n.u === VMAX$5) {
        return n.v * Math.max(root.width, root.height) / Math.min(root.width, root.height) - p.v;
      }
    }

    return 0;
  }
  /**
   * 计算两帧之间的差，单位不同的以后面为准，返回的v表示差值
   * 没有变化返回空
   * auto等无法比较的不参与计算
   * @param prev 上一帧样式
   * @param next 下一帧样式
   * @param k 比较的样式名
   * @param target dom对象
   */


  function calDiff(prev, next, k, target) {
    var p = prev.style[k];
    var n = next.style[k]; // 提前设置好引用，无需每帧计算时取引用，由于单位一定相同，可以简化直接引用到值v上无需单位u，有些直接量没有单位

    var cl = prev.clone[k]; // translatePath可能不存在

    if (cl && cl.hasOwnProperty('v')) {
      cl = cl.v;
    }

    var res = {
      k: k,
      st: p,
      cl: cl
    };

    if (k === TRANSFORM$4) {
      // transform不存在时需给默认矩阵，他只有1个matrix3d的值做动画
      if (!p && !n || !p.length && !n.length) {
        return;
      }

      var pm, nm;

      if (p && p[0]) {
        pm = p[0].v;
      } else {
        pm = mx.identity();
      }

      if (n && n[0]) {
        nm = n[0].v;
      } else {
        nm = mx.identity();
      } // transform特殊被初始化转成matrix矩阵，直接计算差值


      if (equalArr(pm, nm)) {
        return;
      }

      res.v = [nm[0] - pm[0], nm[1] - pm[1], nm[2] - pm[2], nm[3] - pm[3], nm[4] - pm[4], nm[5] - pm[5], nm[6] - pm[6], nm[7] - pm[7], nm[8] - pm[8], nm[9] - pm[9], nm[10] - pm[10], nm[11] - pm[11], nm[12] - pm[12], nm[13] - pm[13], nm[14] - pm[14], nm[15] - pm[15]];
    } else if (k === ROTATE_3D$1) {
      if (p[0] === n[0] && p[1] === n[1] && p[2] === n[2] && p[3].v === n[3].v && p[3].u === n[3].u) {
        return;
      }

      res.v = [n[0] - p[0], n[1] - p[1], n[2] - p[2], n[3].v - p[3].v];
    } else if (k === FILTER$3) {
      // filter很特殊，里面有多个滤镜，按顺序计算，为空视为默认值，如blur默认0，brightness默认1
      var len = Math.max(p ? p.length : 0, n ? n.length : 0);
      var v = [];

      for (var i = 0; i < len; i++) {
        var pv = p ? p[i] : null,
            nv = n ? n[i] : null; // 空或key不等都无变化

        if (isNil$a(pv) || isNil$a(nv) || pv.k !== nv.k) {
          v.push(null);
        } else {
          var _k = pv.k,
              pvv = pv.v,
              nvv = nv.v;

          if (_k === 'blur') {
            if (pvv.u === nvv.u) {
              v.push(nvv.v - pvv.v);
            } else {
              var v2 = calByUnit(pvv, nvv, 0, target.root);
              v.push(v2);
            }
          } else if (_k === 'hueRotate' || _k === 'saturate' || _k === 'brightness' || _k === 'contrast' || _k === 'sepia' || _k === 'invert' || _k === 'grayscale') {
            v.push(nvv.v - pvv.v);
          } else if (_k === 'dropShadow') {
            var _v = [];

            for (var _i = 0; _i < 4; _i++) {
              var a = pvv[_i],
                  b = nvv[_i];

              if (a.u === b.u) {
                _v.push(b.v - a.v);
              } else {
                _v.push(calByUnit(a, b, _i === 1 ? target.clientHeight : target.clientWidth, target.root));
              }
            }

            _v.push([nvv[4][0] - pvv[4][0], nvv[4][1] - pvv[4][1], nvv[4][2] - pvv[4][2], nvv[4][3] - pvv[4][3]]);

            v.push(_v);
          }
        }
      }

      res.v = v;
    } else if (k === TRANSFORM_ORIGIN$3 || k === PERSPECTIVE_ORIGIN$2 || isRadiusKey(k)) {
      // x/y都相等无需
      if (n[0].v === p[0].v && n[0].u === p[0].u && n[1].v === p[1].v && n[1].u === p[1].u) {
        return;
      }

      res.v = [];

      for (var _i2 = 0; _i2 < 2; _i2++) {
        var pi = p[_i2];
        var ni = n[_i2];

        if (pi.u === ni.u) {
          res.v.push(ni.v - pi.v);
        } else {
          var _v2 = calByUnit(pi, ni, target[_i2 ? 'outerHeight' : 'outerWidth'], target.root);

          res.v.push(_v2);
        }
      }
    } else if (k === BACKGROUND_POSITION_X$1 || k === BACKGROUND_POSITION_Y$1) {
      res.v = [];
      var length = Math.min(p.length, n.length);

      for (var _i3 = 0; _i3 < length; _i3++) {
        var _pi = p[_i3],
            _ni = n[_i3];

        if (_pi.u === _ni.u) {
          var _v3 = _ni.v - _pi.v;

          res.v.push(_v3);
        } else {
          var k2 = void 0;

          if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
            k2 = k === BACKGROUND_POSITION_X$1 ? 'clientWidth' : 'clientHeight';
          } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
            k2 = k === BACKGROUND_POSITION_X$1 ? 'width' : 'height';
          } else {
            k2 = k === BACKGROUND_POSITION_X$1 ? 'offsetWidth' : 'offsetHeight';
          }

          var _v4 = calByUnit(_pi, _ni, target[k2], target.root);

          res.v.push(_v4);
        }
      }
    } else if (k === BOX_SHADOW$1) {
      res.v = [];

      for (var _i4 = 0, _len = Math.min(p.length, n.length); _i4 < _len; _i4++) {
        var _a = p[_i4];
        var _b = n[_i4]; // 不能为空，outset/inset必须相等

        if (!_a || !_b || _a[5] !== _b[5]) {
          res.v.push(null);
          continue;
        }

        var _v5 = []; // x/y/blur/spread

        for (var j = 0; j < 4; j++) {
          if (_a[j].u === _b[j].u) {
            _v5.push(_b[j].v - _a[j].v);
          } else {
            var _v6 = calByUnit(_a[j], _b[j], _i4 === 1 ? target.offsetHeight : target.offsetWidth, target.root);

            _v5.push(_v6);
          }
        } // rgba


        var c = [];

        for (var _j = 0; _j < 4; _j++) {
          c.push(_b[4][_j] - _a[4][_j]);
        }

        _v5.push(c);

        res.v.push(_v5);
      }
    } else if (k === BACKGROUND_SIZE$1) {
      res.v = [];

      var _length = Math.min(p.length, n.length);

      var has;

      for (var _i5 = 0; _i5 < _length; _i5++) {
        var _pi2 = p[_i5],
            _ni2 = n[_i5];

        if (!_pi2 || !_ni2) {
          res.v.push(null);
          continue;
        }

        var temp = [];

        for (var _j2 = 0; _j2 < 2; _j2++) {
          var pp = _pi2[_j2],
              nn = _ni2[_j2];

          if (pp.u === nn.u) {
            temp.push(nn.v - pp.v);
          } else {
            var _k2 = void 0;

            if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
              _k2 = _i5 ? 'clientWidth' : 'clientHeight';
            } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
              _k2 = _i5 ? 'width' : 'height';
            } else {
              _k2 = _i5 ? 'offsetWidth' : 'offsetHeight';
            }

            var _v7 = calByUnit(pp, nn, target[_k2], target.root);

            temp.push(_v7);
          }
        }

        if (equalArr(temp, [0, 0])) {
          res.v.push(null);
        } else {
          res.v.push(temp);
          has = true;
        }
      }

      if (!has) {
        return;
      }
    } else if (k === OPACITY$4 || k === Z_INDEX$3) {
      if (n === p) {
        return;
      }

      res.v = n - p;
    } else if (k === STROKE_WIDTH$7) {
      res.v = [];

      var _length2 = Math.min(p.length, n.length);

      for (var _i6 = 0; _i6 < _length2; _i6++) {
        var _pi3 = p[_i6],
            _ni3 = n[_i6];

        if (_pi3.u === _ni3.u) {
          var _v9 = _ni3.v - _pi3.v;

          res.v.push(_v9);
        }

        var _v8 = calByUnit(_pi3, _ni3, target.offsetWidth, target.root);

        res.v.push(_v8);
      }
    } // 特殊的path，不存在style中但在动画某帧中，不会统一化所以可能反向计算frameR时后一帧没有
    else if (k === TRANSLATE_PATH && p) {
      var k1 = 'offsetWidth',
          _k3 = 'offsetHeight';

      if (['padding-box', 'paddingBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
        k1 = 'clientWidth';
        _k3 = 'clientHeight';
      } else if (['content-box', 'contentBox'].indexOf(target.computedStyle[BACKGROUND_CLIP$1]) > -1) {
        k1 = 'width';
        _k3 = 'height';
      }

      res.v = p.map(function (item, i) {
        var v = item.v,
            u = item.u;

        if (u === PERCENT$5) {
          if (i % 2 === 0) {
            return {
              v: (parseFloat(v) || 0) * 0.01 * target[k1],
              u: PX$6
            };
          } else {
            return {
              v: (parseFloat(v) || 0) * 0.01 * target[_k3],
              u: PX$6
            };
          }
        } else if (u === REM$5) {
          return {
            v: (parseFloat(v) || 0) * target.root.computedStyle[FONT_SIZE$3] * 100,
            u: PX$6
          };
        } else if (u === VW$5) {
          return {
            v: (parseFloat(v) || 0) * 0.01 * target.root.width,
            u: PX$6
          };
        } else if (u === VH$5) {
          return {
            v: (parseFloat(v) || 0) * 0.01 * target.root.height,
            u: PX$6
          };
        } else if (u === VMAX$5) {
          return {
            v: (parseFloat(v) || 0) * 0.01 * Math.max(target.root.width, target.root.height),
            u: PX$6
          };
        } else if (u === VMIN$5) {
          return {
            v: (parseFloat(v) || 0) * 0.01 * Math.min(target.root.width, target.root.height),
            u: PX$6
          };
        } else {
          return {
            v: parseFloat(v) || 0,
            u: PX$6
          };
        }
      });
    } else if (isExpandKey(k)) {
      if (p.u === n.u) {
        var _v10 = n.v - p.v;

        if (_v10 === 0) {
          return;
        }

        res.v = _v10;
      } else {
        var _v11 = calByUnit(p, n, target[k === TRANSLATE_X$1 || k === TRANSLATE_Z$1 ? 'outerWidth' : 'outerHeight'], target.root);

        if (!_v11) {
          return;
        }

        res.v = _v11;
      }
    } else if (isLengthKey(k)) {
      // auto不做动画
      if (p.u === AUTO$5 || n.u === AUTO$5) {
        return;
      }

      var computedStyle = target.computedStyle;
      var parentComputedStyle = (target.domParent || target).computedStyle;
      var diff = 0;

      if (p.u === n.u) {
        diff = n.v - p.v;
      } // lineHeight奇怪的单位变化，%相对于fontSize
      else if (k === LINE_HEIGHT$3) {
        diff = calByUnit(p, n, computedStyle[FONT_SIZE$3], target.root);
      } // fontSize的%相对于parent的
      else if (k === FONT_SIZE$3) {
        diff = calByUnit(p, n, parentComputedStyle[FONT_SIZE$3], target.root);
      } // 相对于父height的特殊属性
      else if (k === FLEX_BASIS$3 && ['column', 'column-reverse', 'columnReverse'].indexOf(computedStyle[FLEX_DIRECTION$2]) > -1 || [HEIGHT$6, TOP$4, BOTTOM$4].indexOf(k) > -1) {
        if (p.u !== AUTO$5 && n.u !== AUTO$5) {
          diff = calByUnit(p, n, parentComputedStyle[HEIGHT$6], target.root);
        }
      } // 其余都是相对于父width的
      else {
        if (p.u !== AUTO$5 && n.u !== AUTO$5) {
          diff = calByUnit(p, n, parentComputedStyle[WIDTH$6], target.root);
        }
      } // 兜底NaN非法


      if (diff === 0 || isNaN(diff)) {
        return;
      }

      res.v = diff;
    } else if (isGradientKey(k)) {
      // backgroundImage发生了渐变色和图片的变化，fill发生渐变色和纯色的变化等
      res.v = [];

      var _length3 = Math.min(p.length, n.length);

      for (var _i7 = 0; _i7 < _length3; _i7++) {
        var _pi4 = p[_i7],
            _ni4 = n[_i7];

        if (!_pi4 || !_ni4 || _pi4.u !== _ni4.u || _pi4.u === STRING$1) {
          res.v.push(null);
          continue;
        }

        var u = _pi4.u;
        _pi4 = _pi4.v;
        _ni4 = _ni4.v;

        var _temp = void 0; // 渐变


        if (u === GRADIENT$2) {
          var r = calDiffGradient(_pi4, _ni4, target);

          if (!r) {
            res.v.push(null);
            continue;
          }

          _temp = r;
        } // 纯色
        else {
          if (equalArr(_ni4, _pi4)) {
            res.v.push(null);
            continue;
          }

          _temp = [_ni4[0] - _pi4[0], _ni4[1] - _pi4[1], _ni4[2] - _pi4[2], _ni4[3] - _pi4[3]];
        }

        res.v.push(_temp);
      }
    } else if (isColorKey(k)) {
      if (n.u !== p.u) {
        return;
      } // 特殊增加支持有gradient的先判断，仅color和textStrokeColor支持


      n = n.v;
      p = p.v;

      if (n.u === GRADIENT$2) {
        var _r = calDiffGradient(p, n, target);

        if (!_r) {
          return;
        }

        res.v = _r;
      } else {
        if (equalArr(n, p)) {
          return;
        }

        res.v = [n[0] - p[0], n[1] - p[1], n[2] - p[2], n[3] - p[3]];
      }
    } else if (GEOM$1.hasOwnProperty(k)) {
      var tagName = target.tagName;

      if (isNil$a(p)) {
        return;
      } else if (GEOM$1[k][tagName] && isFunction$6(GEOM$1[k][tagName].calDiff)) {
        var fn = GEOM$1[k][tagName].calDiff;

        if (target.isMulti) {
          var arr = [];

          for (var _i8 = 0, _len2 = Math.min(p.length, n.length); _i8 < _len2; _i8++) {
            arr.push(fn(p[_i8], n[_i8]));
          }

          return arr;
        } else {
          res.v = fn(p, n);
        }
      } // 特殊处理multi
      else if (target.isMulti) {
        if (k === 'points' || k === 'controls') {
          if (isNil$a(n) || !n.length || isNil$a(p) || !p.length || equalArr(p, n)) {
            return;
          }

          res.v = [];

          for (var _i9 = 0, _len3 = Math.min(p.length, n.length); _i9 < _len3; _i9++) {
            var _pv = p[_i9];
            var _nv = n[_i9];

            if (isNil$a(_pv) || !_pv.length || isNil$a(_nv) || !_nv.length) {
              res.v.push(null);
            } else {
              var _v12 = [];

              for (var _j3 = 0, len2 = Math.min(_pv.length, _nv.length); _j3 < len2; _j3++) {
                var pv2 = _pv[_j3];
                var nv2 = _nv[_j3];

                if (isNil$a(pv2) || isNil$a(nv2)) {
                  _v12.push(null);
                } else {
                  var v3 = [];

                  for (var _k4 = 0, len3 = Math.max(pv2.length, nv2.length); _k4 < len3; _k4++) {
                    var pv3 = pv2[_k4];
                    var nv3 = nv2[_k4]; // control由4点变2点

                    if (isNil$a(pv3) || isNil$a(nv3)) {
                      v3.push(0);
                    } else {
                      v3.push(nv3 - pv3);
                    }
                  }

                  _v12.push(v3);
                }
              }

              res.v.push(_v12);
            }
          }
        } else if (k === 'controlA' || k === 'controlB') {
          if (isNil$a(n) || !n.length || isNil$a(p) || !p.length || equalArr(p, n)) {
            return;
          }

          res.v = [];

          for (var _i10 = 0, _len4 = Math.min(p.length, n.length); _i10 < _len4; _i10++) {
            var _pv2 = p[_i10];
            var _nv2 = n[_i10];

            if (isNil$a(_pv2) || !_pv2.length || isNil$a(_nv2) || !_nv2.length) {
              res.v.push(null);
            } else {
              res.v.push([_nv2[0] - _pv2[0], _nv2[1] - _pv2[1]]);
            }
          }
        } else {
          if (n === p || equalArr(n, p) || k === 'edge' || k === 'closure' || k === 'booleanOperations') {
            return;
          }

          var _v13 = [];

          for (var _i11 = 0, _len5 = Math.min(p.length, n.length); _i11 < _len5; _i11++) {
            var _pv3 = p[_i11];
            var _nv3 = n[_i11];

            if (isNil$a(_pv3) || isNil$a(_nv3)) {
              _v13.push(0);
            }

            _v13.push(_nv3 - _pv3);
          }

          res.v = _v13;
        }
      } // 非multi特殊处理这几类数组类型数据
      else if (k === 'points' || k === 'controls') {
        if (isNil$a(n) || !n.length || isNil$a(p) || !p.length || equalArr(p, n)) {
          return;
        }

        res.v = [];

        for (var _i12 = 0, _len6 = Math.min(p.length, n.length); _i12 < _len6; _i12++) {
          var _pv4 = p[_i12];
          var _nv4 = n[_i12];

          if (isNil$a(_pv4) || !_pv4.length || isNil$a(_nv4) || !_nv4.length) {
            res.v.push(null);
          } else {
            var _v14 = [];

            for (var _j4 = 0, _len7 = Math.max(_pv4.length, _nv4.length); _j4 < _len7; _j4++) {
              var _pv5 = _pv4[_j4];
              var _nv5 = _nv4[_j4]; // control由4点变2点

              if (isNil$a(_pv5) || isNil$a(_nv5)) {
                _v14.push(0);
              } else {
                _v14.push(_nv5 - _pv5);
              }
            }

            res.v.push(_v14);
          }
        }
      } else if (k === 'controlA' || k === 'controlB') {
        if (isNil$a(n) || !n.length || isNil$a(p) || !p.length || equalArr(p, n)) {
          return;
        }

        res.v = [n[0] - p[0], n[1] - p[1]];
      } // 其它简单数据，除了edge/closure/booleanOperations没有增量
      else {
        if (n === p || k === 'edge' || k === 'closure' || k === 'booleanOperations') {
          return;
        } else {
          res.v = n - p;
        }
      }
    } // display等不能有增量过程的
    else {
      return;
    }

    return res;
  } // 渐变的差异计算


  function calDiffGradient(p, n, target) {
    if (p.k !== n.k) {
      return;
    }

    var pv = p.v;
    var nv = n.v;
    var temp = [[]];
    var eq = equalArr(pv, nv); // 渐变值部分是通用的

    for (var i = 0, len = Math.min(pv.length, nv.length); i < len; i++) {
      var a = pv[i];
      var b = nv[i];
      var t = [];
      t.push([b[0][0] - a[0][0], b[0][1] - a[0][1], b[0][2] - a[0][2], b[0][3] - a[0][3]]);

      if (a[1] && b[1]) {
        if (a[1].u === b[1].u) {
          t.push(b[1].v - a[1].v);
        } else {
          var v = calByUnit(a[1], b[1], target.clientWidth, target.root);
          t.push(v || 0);
        }
      }

      temp[0].push(t);
    }

    if (p.k === 'linear') {
      var isArrP = Array.isArray(p.d);
      var isArrN = Array.isArray(n.d);

      if (isArrN !== isArrP) {
        return;
      }

      if (isArrP) {
        var _v15 = [n.d[0] - p.d[0], n.d[1] - p.d[1], n.d[2] - p.d[2], n.d[3] - p.d[3]];

        if (eq && equalArr(_v15, [0, 0, 0, 0])) {
          return;
        }

        temp[1] = _v15;
      } else {
        var _v16 = n.d - p.d; // 颜色角度都没变化


        if (eq && _v16 === 0) {
          return;
        }

        temp[1] = _v16;
      }
    } else if (p.k === 'radial') {
      var _isArrP = Array.isArray(p.z);

      var _isArrN = Array.isArray(n.z);

      if (_isArrN !== _isArrP) {
        return;
      }

      temp[2] = []; // sketch中a点到b点特殊格式表达，z是数组忽略p和s

      if (_isArrP) {
        // 距离中心外形全等
        if (eq && equalArr(p.z, n.z)) {
          return;
        }

        for (var _i13 = 0; _i13 < 5; _i13++) {
          var pz = p.z[_i13]; // 半径比例省略为1

          if (pz === undefined) {
            pz = 1;
          }

          var nz = n.z[_i13];

          if (nz === undefined) {
            nz = 1;
          }

          temp[2].push(nz - pz);
        }
      } else {
        if (eq && p.z === n.z && p.s === n.s && equalArr(p.p, n.p)) {
          return;
        }

        for (var _i14 = 0; _i14 < 2; _i14++) {
          var pp = p.p[_i14];
          var np = n.p[_i14];

          if (pp.u === np.u) {
            temp[2].push(np.v - pp.v);
          } else {
            var _v17 = calByUnit(pp, np, target[_i14 ? 'clientWidth' : 'clientHeight'], target.root);

            temp[2].push(_v17 || 0);
          }
        }
      }
    } else if (p.k === 'conic') {
      if (eq && p.d === n.d && equalArr(p.p, n.p)) {
        return;
      }

      temp[1] = n.d - p.d;
      temp[2] = [];

      for (var _i15 = 0; _i15 < 2; _i15++) {
        var _pp = p.p[_i15];
        var _np = n.p[_i15];

        if (_pp[1] === _np[1]) {
          temp[2].push(_np[0] - _pp[0]);
        } else {
          var _v18 = calByUnit(_pp, _np, target[_i15 ? 'clientWidth' : 'clientHeight'], target.root);

          temp[2].push(_v18 || 0);
        }
      }
    }

    return temp;
  }
  /**
   * 计算两帧之间不相同的变化，存入transition，相同的忽略
   * 同时不变化的key也得存入fixed
   */


  function calFrame(prev, next, keys, target) {
    var hasTp;
    keys.forEach(function (k) {
      if (k === TRANSLATE_PATH) {
        hasTp = true;
      }

      var ts = calDiff(prev, next, k, target); // 可以形成过渡的才会产生结果返回

      if (ts) {
        prev.transition.push(ts);
        prev.keys.push(k);
      } else {
        prev.fixed.push(k);
      }
    }); // translatePath需特殊处理translate，防止被覆盖

    if (hasTp) {
      var i = prev.keys.indexOf(TRANSLATE_X$1);

      if (i === -1) {
        prev.keys.push(TRANSLATE_X$1);
      }

      i = prev.keys.indexOf(TRANSLATE_Y$1);

      if (i === -1) {
        prev.keys.push(TRANSLATE_Y$1);
      }

      i = prev.fixed.indexOf(TRANSLATE_X$1);

      if (i > -1) {
        prev.fixed.splice(i, 1);
      }

      i = prev.fixed.indexOf(TRANSLATE_Y$1);

      if (i > -1) {
        prev.fixed.splice(i, 1);
      }
    }

    return next;
  }

  function binarySearch(i, j, time, frames) {
    while (i < j) {
      if (i === j - 1) {
        if (frames[j].time <= time) {
          return j;
        }

        return i;
      }

      var middle = i + (j - i >> 1);
      var _frame = frames[middle];

      if (_frame.time === time) {
        return middle;
      }

      if (_frame.time > time) {
        j = Math.max(middle - 1, i);
      } else {
        i = Math.min(middle, j);
      }
    }

    return i;
  }

  function getEasing(ea) {
    var timingFunction;

    if (ea) {
      if (timingFunction = /^\s*steps\s*\(\s*(\d+)(?:\s*,\s*(\w+))?\s*\)/i.exec(ea)) {
        var steps = parseInt(timingFunction[1]);
        var stepsD = timingFunction[2];

        timingFunction = function timingFunction(percent) {
          // steps有效定义正整数
          if (steps && steps > 0) {
            var per = 1 / steps;
            var n = stepsD === 'start' ? Math.ceil(percent / per) : Math.floor(percent / per);
            return n / steps;
          }

          return percent;
        };
      } else {
        timingFunction = easing.getEasing(ea);
      }
    }

    return timingFunction;
  }
  /**
   * 根据百分比和缓动函数计算中间态样式
   * 当easing定义为steps时，优先计算
   * @param frame 当前帧
   * @param percent 到下一帧时间的百分比
   * @param target vd
   * @return {[]} 发生变更的样式key
   */


  function calIntermediateStyle(frame, percent, target) {
    var style = frame.style;
    var transition = frame.transition;
    var timingFunction = frame.timingFunction;

    if (timingFunction && timingFunction !== linear) {
      percent = timingFunction(percent);
    } // 同一关键帧同一percent可以不刷新，比如diff为0时，或者steps情况


    if (frame.lastPercent === percent) {
      return [];
    }

    frame.lastPercent = percent;
    var currentStyle = target.__currentStyle,
        currentProps = target.__currentProps,
        res = frame.keys.slice(0);

    var _loop = function _loop(i, len) {
      var item = transition[i];
      var k = item.k,
          v = item.v,
          st = item.st,
          cl = item.cl; // transform特殊处理，只有1个matrix，有可能不存在，需给默认矩阵

      if (k === TRANSFORM$4) {
        if (!st || !st.length) {
          st = style[k] = [{
            k: MATRIX$2,
            v: mx.identity()
          }];
        }

        if (!cl || !cl.length) {
          cl = frame.clone[k] = [{
            k: MATRIX$2,
            v: mx.identity()
          }];
        }

        for (var _i17 = 0; _i17 < 16; _i17++) {
          st[0].v[_i17] = cl[0].v[_i17] + v[_i17] * percent;
        }

        currentStyle[k] = st;
      } else if (k === ROTATE_3D$1) {
        st[0] = cl[0] + v[0] * percent;
        st[1] = cl[1] + v[1] * percent;
        st[2] = cl[2] + v[2] * percent;
        st[3].v = cl[3].v + v[3] * percent;
        currentStyle[k] = st;
      } else if (k === FILTER$3) {
        for (var _i18 = 0, _len9 = v.length; _i18 < _len9; _i18++) {
          var _item = v[_i18];

          if (_item) {
            var k2 = st[_i18].k,
                v2 = st[_i18].v; // 只有dropShadow是多个数组，存放x/y/blur/spread/color

            if (k2 === 'dropShadow') {
              v2[0].v += _item[0] * percent;
              v2[1].v += _item[1] * percent;
              v2[2].v += _item[2] * percent;
              v2[3].v += _item[3] * percent;
              var c1 = v2[4],
                  c2 = _item[4];
              c1[0] += c2[0] * percent;
              c1[1] += c2[1] * percent;
              c1[2] += c2[2] * percent;
              c1[3] += c2[3] * percent;
            } // 其它都是带单位单值
            else {
              v2.v += _item * percent;
            }
          }
        }

        currentStyle[k] = st;
      } else if (k === TRANSFORM_ORIGIN$3 || k === PERSPECTIVE_ORIGIN$2 || isRadiusKey(k)) {
        if (v[0] !== 0) {
          st[0].v = cl[0].v + v[0] * percent;
        }

        if (v[1] !== 0) {
          st[1].v = cl[1].v + v[1] * percent;
        }

        currentStyle[k] = st;
      } else if (k === BACKGROUND_POSITION_X$1 || k === BACKGROUND_POSITION_Y$1 || k === STROKE_WIDTH$7) {
        st.forEach(function (item, i) {
          if (v[i]) {
            item.v = cl[i].v + v[i] * percent;
          }
        });
        currentStyle[k] = st;
      } else if (k === BOX_SHADOW$1) {
        for (var _i19 = 0, _len10 = Math.min(st.length, v.length); _i19 < _len10; _i19++) {
          if (!v[_i19]) {
            continue;
          } // x/y/blur/spread


          for (var j = 0; j < 4; j++) {
            st[_i19][j].v = cl[_i19][j].v + v[_i19][j] * percent;
          } // rgba


          for (var _j5 = 0; _j5 < 4; _j5++) {
            st[_i19][4][_j5] = cl[_i19][4][_j5] + v[_i19][4][_j5] * percent;
          }
        }

        currentStyle[k] = st;
      } else if (k === BACKGROUND_SIZE$1) {
        st.forEach(function (item, i) {
          var o = v[i];

          if (o) {
            item[0].v = cl[i][0].v + o[0] * percent;
            item[1].v = cl[i][1].v + o[1] * percent;
          }
        });
        currentStyle[k] = st;
      } else if (k === OPACITY$4 || k === Z_INDEX$3) {
        st = cl + v * percent; // 精度问题可能会超过[0,1]区间

        if (k === OPACITY$4) {
          if (st < 0) {
            st = 0;
          } else if (st > 1) {
            st = 1;
          }
        }

        currentStyle[k] = st;
      } // 特殊的曲线运动计算，转换为translateXY，出现在最后一定会覆盖原本的translate防重
      else if (k === TRANSLATE_PATH) {
        var t = 1 - percent;

        if (v.length === 8) {
          currentStyle[TRANSLATE_X$1] = {
            v: v[0].v * t * t * t + 3 * v[2].v * percent * t * t + 3 * v[4].v * percent * percent * t + v[6].v * percent * percent * percent,
            u: PX$6
          };
          currentStyle[TRANSLATE_Y$1] = {
            v: v[1].v * t * t * t + 3 * v[3].v * percent * t * t + 3 * v[5].v * percent * percent * t + v[7].v * percent * percent * percent,
            u: PX$6
          };
        } else if (v.length === 6) {
          currentStyle[TRANSLATE_X$1] = {
            v: v[0].v * t * t + 2 * v[2].v * percent * t + v[4].v * percent * percent,
            u: PX$6
          };
          currentStyle[TRANSLATE_Y$1] = {
            v: v[1].v * t * t + 3 * v[3].v * percent * t + v[5].v * percent * percent,
            u: PX$6
          };
        }
      } else if (isLengthKey(k) || isExpandKey(k)) {
        st.v = cl + v * percent;
        currentStyle[k] = st;
      } else if (isGradientKey(k)) {
        st.forEach(function (st2, i) {
          var v2 = v[i];

          if (!v2) {
            return;
          }

          var cli = cl[i].v;

          if (st2.u === GRADIENT$2) {
            st2 = st2.v;

            var _v19 = _slicedToArray(v2, 4),
                c = _v19[0],
                d = _v19[1],
                p = _v19[2],
                z = _v19[3];

            for (var _j6 = 0, _len11 = Math.min(st2.v.length, c.length); _j6 < _len11; _j6++) {
              var a = st2.v[_j6];
              var b = c[_j6];
              a[0][0] = cli.v[_j6][0][0] + b[0][0] * percent;
              a[0][1] = cli.v[_j6][0][1] + b[0][1] * percent;
              a[0][2] = cli.v[_j6][0][2] + b[0][2] * percent;
              a[0][3] = cli.v[_j6][0][3] + b[0][3] * percent;

              if (a[1] && b[1]) {
                a[1].v = cli.v[_j6][1].v + b[1] * percent;
              }
            }

            if (st2.k === 'linear' && st2.d !== undefined && d !== undefined) {
              if (Array.isArray(d)) {
                st2.d[0] = cli.d[0] + d[0] * percent;
                st2.d[1] = cli.d[1] + d[1] * percent;
                st2.d[2] = cli.d[2] + d[2] * percent;
                st2.d[3] = cli.d[3] + d[3] * percent;
              } else {
                st2.d = cli.d + d * percent;
              }
            } else if (st2.k === 'radial') {
              if (st2.z !== undefined && z !== undefined) {
                st2.z[0] = cli.z[0] + z[0] * percent;
                st2.z[1] = cli.z[1] + z[1] * percent;
                st2.z[2] = cli.z[2] + z[2] * percent;
                st2.z[3] = cli.z[3] + z[3] * percent;
                st2.z[4] = cli.z[4] + z[4] * percent;
              } else if (st2.p !== undefined && p !== undefined) {
                st2.p[0].v = cli.p[0].v + p[0] * percent;
                st2.p[1].v = cli.p[1].v + p[1] * percent;
              }
            } else if (st2.k === 'conic' && st2.d !== undefined && d !== undefined) {
              st2.d = cli.d + d * percent;
              st2.p[0][0] = cli.p[0] + p[0] * percent;
              st2.p[1][0] = cli.p[1] + p[1] * percent;
            }
          } // fill纯色
          else {
            st2 = st2.v;
            st2[0] = cli[0] + v2[0] * percent;
            st2[1] = cli[1] + v2[1] * percent;
            st2[2] = cli[2] + v2[2] * percent;
            st2[3] = cli[3] + v2[3] * percent;
          }
        });
        currentStyle[k] = st;
      } // color可能超限[0,255]，但浏览器已经做了限制，无需关心
      else if (isColorKey(k)) {
        var _t = st.v;
        _t[0] = cl[0] + v[0] * percent;
        _t[1] = cl[1] + v[1] * percent;
        _t[2] = cl[2] + v[2] * percent;
        _t[3] = cl[3] + v[3] * percent;
        currentStyle[k] = st;
      } else if (GEOM$1.hasOwnProperty(k)) {
        var tagName = target.tagName;

        if (GEOM$1[k][tagName] && isFunction$6(GEOM$1[k][tagName].calIncrease)) {
          var fn = GEOM$1[k][tagName].calIncrease;

          if (target.isMulti) {
            st = st.map(function (item, i) {
              return fn(item, v[i], percent);
            });
          } else {
            st = fn(st, v, percent);
          }
        } else if (target.isMulti) {
          if (k === 'points' || k === 'controls') {
            for (var _i20 = 0, _len12 = Math.min(st.length, v.length); _i20 < _len12; _i20++) {
              var o = st[_i20];
              var n = v[_i20];
              var cli = cl[_i20];

              if (!isNil$a(o) && !isNil$a(n)) {
                for (var _j7 = 0, len2 = Math.min(o.length, n.length); _j7 < len2; _j7++) {
                  var o2 = o[_j7];
                  var n2 = n[_j7];

                  if (!isNil$a(o2) && !isNil$a(n2)) {
                    for (var _k5 = 0, len3 = Math.min(o2.length, n2.length); _k5 < len3; _k5++) {
                      if (!isNil$a(o2[_k5]) && !isNil$a(n2[_k5])) {
                        o2[_k5] = cli[_j7][_k5] + n2[_k5] * percent;
                      }
                    }
                  }
                }
              }
            }
          } else if (k === 'controlA' || k === 'controlB') {
            v.forEach(function (item, i) {
              var st2 = st[i];

              if (!isNil$a(item[0]) && !isNil$a(st2[0])) {
                st2[0] = cl[i][0] + item[0] * percent;
              }

              if (!isNil$a(item[1]) && !isNil$a(st2[1])) {
                st2[1] = cl[i][1] + item[1] * percent;
              }
            });
          } else {
            v.forEach(function (item, i) {
              if (!isNil$a(item) && !isNil$a(st[i])) {
                st[i] = cl[i] + item * percent;
              }
            });
          }
        } else {
          if (k === 'points' || k === 'controls') {
            for (var _i21 = 0, _len13 = Math.min(st.length, v.length); _i21 < _len13; _i21++) {
              var _o = st[_i21];
              var _n = v[_i21];

              if (!isNil$a(_o) && !isNil$a(_n)) {
                for (var _j8 = 0, _len14 = Math.min(_o.length, _n.length); _j8 < _len14; _j8++) {
                  if (!isNil$a(_o[_j8]) && !isNil$a(_n[_j8])) {
                    _o[_j8] = cl[_i21][_j8] + _n[_j8] * percent;
                  }
                }
              }
            }
          } else if (k === 'controlA' || k === 'controlB') {
            if (!isNil$a(st[0]) && !isNil$a(v[0])) {
              st[0] = cl[0] + v[0] * percent;
            }

            if (!isNil$a(st[1]) && !isNil$a(v[1])) {
              st[1] = cl[1] + v[1] * percent;
            }
          } else {
            if (!isNil$a(st) && !isNil$a(v)) {
              st = cl + v * percent;
            }
          }
        }

        currentProps[k] = st;
      } // string的直接量，在不同帧之间可能存在变化，同帧变化后不再改变
      else {
        if (currentStyle[k] !== st) {
          currentStyle[k] = st;
        } else {
          var _j9 = res.indexOf(k);

          res.splice(_j9, 1);
        }
      }
    };

    for (var i = 0, len = transition.length; i < len; i++) {
      _loop(i);
    } // 无变化的也得检查是否和当前相等，防止跳到一个不变化的帧上，而前一帧有变化的情况


    var fixed = frame.fixed;

    for (var _i16 = 0, _len8 = fixed.length; _i16 < _len8; _i16++) {
      var k = fixed[_i16];

      var _isGeom = GEOM$1.hasOwnProperty(k);

      if (!equalStyle$1(k, style[k], _isGeom ? currentProps[k] : currentStyle[k], target)) {
        if (GEOM$1.hasOwnProperty(k)) {
          currentProps[k] = style[k];
        } else {
          currentStyle[k] = style[k];
        }

        res.push(k);
      }
    }

    return res;
  }
  /**
   * 最后一帧无法计算transition，对整体keys的style进行对比
   */


  function calLastStyle(style, target, keys) {
    var currentStyle = target.__currentStyle,
        currentProps = target.__currentProps,
        res = [];

    for (var i = 0, len = keys.length; i < len; i++) {
      var k = keys[i],
          v = style[k];

      var _isGeom2 = GEOM$1.hasOwnProperty(k);

      if (!equalStyle$1(k, v, _isGeom2 ? currentProps[k] : currentStyle[k], target)) {
        if (_isGeom2) {
          currentProps[k] = v;
        } else {
          currentStyle[k] = v;
        }

        res.push(k);
      }
    }

    return res;
  }

  function gotoOverload(options, cb) {
    if (isFunction$6(options)) {
      cb = options;
      options = {};
    }

    return [options || {}, cb];
  }

  function frameCb(self) {
    self.emit(Event.FRAME, self.__isChange);

    if (self.__firstPlay) {
      self.__firstPlay = false;
      self.emit(Event.PLAY);
    }

    var cb = self.__playCb;

    if (isFunction$6(cb)) {
      cb(self.__isChange); // 清理要检查，gotoAndStop()这种cb回调中直接再次调用goto的话cb会不一致不能删除

      if (self.__playCb === cb) {
        self.__playCb = null;
      }
    }
  }

  var uuid$2 = 0;

  var Animation = /*#__PURE__*/function (_Event) {
    _inherits(Animation, _Event);

    function Animation(target, list, options) {
      var _this;

      _this = _Event.call(this) || this;
      _this.__id = uuid$2++;
      list = clone$1(list || []);

      if (Array.isArray(list)) {
        list = list.filter(function (item) {
          return item && isObject$1(item);
        });
      } // 动画过程另外一种形式，object描述k-v形式
      else if (list && isObject$1(list)) {
        var nl = [];
        Object.keys(list).forEach(function (k) {
          var v = list[k];

          if (Array.isArray(v)) {
            for (var i = 0, len = v.length; i < len; i++) {
              var o = nl[i] = nl[i] || {
                offset: i / (len - 1)
              };
              o[k] = v[i];
            }
          }
        });
        list = nl;
      } else {
        list = [];
      }

      if (isNumber(options)) {
        _this.__options = {
          duration: options
        };
        options = _this.__options;
      }

      var op = _this.__options = options || {
        duration: 0
      };
      _this.__begin = true;
      _this.__playState = 'idle';
      _this.__target = target;
      _this.__root = target.root;
      _this.__isChange = false; // 每帧是否有变化，无变化不刷新也会触发frame事件

      _this.__firstPlay = true;
      _this.__firstEnter = true;
      var iterations = _this.iterations = op.iterations;
      var duration = _this.duration = op.duration;

      var _this$__init = _this.__init(list, iterations, duration, op.easing, target),
          _this$__init2 = _slicedToArray(_this$__init, 4),
          frames = _this$__init2[0],
          framesR = _this$__init2[1],
          keys = _this$__init2[2],
          originStyle = _this$__init2[3];

      _this.__frames = frames;
      _this.__framesR = framesR;
      _this.__keys = keys;
      _this.__originStyle = originStyle;
      _this.__isDelay = false;
      _this.__outBeginDelay = false;
      _this.__playCount = 0;
      var fps = parseInt(op.fps) || 0;

      if (fps <= 0) {
        fps = 60;
      }

      _this.fps = fps;
      _this.spfLimit = op.spfLimit;
      _this.delay = op.delay;
      _this.endDelay = op.endDelay;
      _this.playbackRate = op.playbackRate;
      _this.fill = op.fill;
      _this.iterations = op.iterations;
      _this.direction = op.direction;
      _this.easing = op.easing;
      _this.__currentFrames = {
        reverse: true,
        'alternate-reverse': true
      }.hasOwnProperty(op.direction) ? framesR : frames; // 时间戳

      _this.__timestamp = frame.__now;
      return _this;
    }

    _createClass(Animation, [{
      key: "__init",
      value: function __init(list, iterations, duration, easing, target) {
        if (list.length < 1) {
          return [[], [], [], {}];
        } // 过滤时间非法的，过滤后续offset<=前面的


        var offset = -1;

        var _loop2 = function _loop2(_i22, _len15) {
          var current = list[_i22];

          if (current.hasOwnProperty('offset')) {
            current.offset = parseFloat(current.offset) || 0;
            current.offset = Math.max(0, current.offset);
            current.offset = Math.min(1, current.offset); // 超过区间[0,1]

            if (isNaN(current.offset) || current.offset < 0 || current.offset > 1) {
              list.splice(_i22, 1);
              _i22--;
              _len15--;
              i = _i22;
              len = _len15;
              return "continue";
            } // <=前面的
            else if (current.offset <= offset) {
              list.splice(_i22, 1);
              _i22--;
              _len15--;
              i = _i22;
              len = _len15;
              return "continue";
            }
          } // 缩写处理


          Object.keys(current).forEach(function (k) {
            if (abbr$1.hasOwnProperty(k)) {
              abbr$1.toFull(current, k);
            }
          }); // 检查key合法性

          Object.keys(current).forEach(function (k) {
            if (k !== 'easing' && k !== 'offset' && !o$2.isValid(target.tagName, k)) {
              delete current[k];
            }
          });
          i = _i22;
          len = _len15;
        };

        for (var i = 0, len = list.length; i < len; i++) {
          var _ret = _loop2(i, len);

          if (_ret === "continue") continue;
        } // 只有1帧复制出来变成2帧方便运行


        if (list.length === 1) {
          list[0] = clone$1(list[0]);

          if (list[0].offset === 1) {
            list.unshift({
              offset: 0
            });
          } else {
            var copy = clone$1(list[0]);
            copy.offset = 1;
            list.push(copy);
          }
        } // 强制clone防止同引用
        else {
          list.forEach(function (item, i) {
            list[i] = clone$1(item);
          });
        } // 首尾时间偏移强制为[0, 1]，不是的话前后加空帧


        var first = list[0];

        if (first.hasOwnProperty('offset') && first.offset > 0) {
          first = {
            offset: 0
          };
          list.unshift(first);
        } else {
          first.offset = 0;
        }

        var last = list[list.length - 1];

        if (last.hasOwnProperty('offset') && last.offset < 1) {
          last = {
            offset: 1
          };
          list.push(last);
        } else {
          last.offset = 1;
        } // 计算没有设置offset的时间


        for (var _i23 = 1, _len16 = list.length; _i23 < _len16; _i23++) {
          var start = list[_i23]; // 从i=1开始offset一定>0，找到下一个有offset的，均分中间无声明的

          if (!start.hasOwnProperty('offset')) {
            var end = void 0;
            var j = _i23 + 1;

            for (; j < _len16; j++) {
              end = list[j];

              if (end.hasOwnProperty('offset')) {
                break;
              }
            }

            var num = j - _i23 + 1;
            start = list[_i23 - 1];
            var per = (end.offset - start.offset) / num;

            for (var k = _i23; k < j; k++) {
              var item = list[k];
              item.offset = start.offset + per * (k + 1 - _i23);
            }

            _i23 = j;
          }
        }

        var frames = []; // 换算每一关键帧样式标准化

        list.forEach(function (item) {
          frames.push(framing(item, duration, easing));
        }); // 为方便两帧之间计算变化，强制统一所有帧的css属性相同，没有写的为节点的当前样式currentStyle

        var keys = unify(frames, target);
        inherit(frames, keys, target);
        var framesR = clone$1(frames).reverse(); // 存储原本样式以便恢复用

        var style = target.style,
            props = target.props;
        var originStyle = {};
        keys.forEach(function (k) {
          if (isGeom$1(target.tagName, k)) {
            originStyle[k] = props[k];
          }

          originStyle[k] = style[k];
        }); // 再计算两帧之间的变化，存入transition/fixed属性

        var length = frames.length;
        var prev = frames[0];

        for (var _i24 = 1; _i24 < length; _i24++) {
          var next = frames[_i24];
          prev = calFrame(prev, next, keys, target);
        } // 反向存储帧的倒排结果


        framesR.forEach(function (item) {
          item.time = duration - item.time;
          item.transition = [];
        });
        prev = framesR[0];

        for (var _i25 = 1; _i25 < length; _i25++) {
          var _next = framesR[_i25];
          prev = calFrame(prev, _next, keys, target);
        }

        return [frames, framesR, keys, originStyle];
      }
    }, {
      key: "__clean",
      value: function __clean(isFinish) {
        this.__cancelTask();

        this.__nextTime = 0;

        if (isFinish) {
          // gotoAndStop到一个很大的时间的话，也需要防止超过
          this.__currentTime = this.__delay + this.__duration * this.__iterations + this.__endDelay;
          this.__playState = 'finished';
        } else {
          this.__playCount = this.__currentTime = 0;
          this.__playState = 'idle';
        }
      }
    }, {
      key: "play",
      value: function play(cb) {
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var playState = this.__playState;
        var frames = this.__frames;

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        if (playState === 'running') {
          return this;
        }

        this.__cancelTask();

        this.__playCb = cb;
        this.__playState = 'running'; // 每次play调用标识第一次运行，需响应play事件和回调

        this.__firstPlay = true;
        this.__firstEnter = true;
        this.__playCount = 0; // 防止finish/cancel事件重复触发，每次播放重置

        this.__hasFin = false;
        this.__hasCancel = false; // 只有第一次调用会进初始化，另外finish/cancel视为销毁也会重新初始化

        if (!this.__enterFrame) {
          this.__enterFrame = true;
          var framesR = this.__framesR;
          var direction = this.__direction; // 初始化根据方向确定帧序列

          this.__currentFrames = {
            reverse: true,
            'alternate-reverse': true
          }.hasOwnProperty(direction) ? framesR : frames;
          this.__currentTime = this.__nextTime = this.__fpsTime = 0;
        } // 添加每帧回调且立刻执行，本次执行调用refreshTask也是下一帧再渲染，frame的每帧都是下一帧
        // frame.offFrame(this);


        frame.onFrame(this);
        this.__startTime = frame.__now;
        this.__end = false;
        return this;
      }
    }, {
      key: "__before",
      value: function __before(diff) {
        this.__timestamp = frame.__now;
        var target = this.__target;
        var fps = this.__fps;
        var currentFrames = this.__currentFrames;
        var iterations = this.__iterations;
        var stayBegin = this.__stayBegin;
        var stayEnd = this.__stayEnd;
        var delay = this.__delay;
        var root = this.__root;
        var duration = this.__duration;
        var endDelay = this.__endDelay;
        var length = currentFrames.length;
        var playbackRate = this.__playbackRate;
        var spfLimit = this.__spfLimit;
        var currentTime = this.__currentTime = this.__nextTime;
        this.__isChange = false; // 定帧限制每帧时间间隔最大为spf

        if (spfLimit) {
          if (spfLimit === true) {
            diff = Math.min(diff, 1000 / fps);
          } else if (spfLimit > 0) {
            diff = Math.min(diff, spfLimit);
          }
        } // 播放时间累加，并且考虑播放速度加成


        if (playbackRate !== 1 && playbackRate > 0) {
          diff *= playbackRate;
        } // 用本帧和上帧时间差，计算累加运行时间currentTime，以便定位当前应该处于哪个时刻


        this.__nextTime += diff; // 增加的fps功能，当<60时计算跳帧，每帧运行依旧累加时间，达到fps时重置，第一帧强制不跳

        if (!this.__firstEnter && fps < 60) {
          diff = this.__fpsTime += diff;

          if (diff < 1000 / fps) {
            this.__inFps = true;
            return;
          }

          this.__fpsTime = 0;
        }

        this.__firstEnter = false; // delay仅第一次生效等待

        if (currentTime < delay) {
          if (stayBegin && !this.__isDelay) {
            var _currentFrame = this.__currentFrame = currentFrames[0];

            var _keys = calLastStyle(_currentFrame.style, target, this.__keys);

            this.__isChange = !!_keys.length;
            genBeforeRefresh(_keys, root, target, null);
          }

          this.__begin = false; // 默认是true，delay置false防触发
          // 即便不刷新，依旧执行帧回调，同时标明让后续第一帧响应begin

          this.__outBeginDelay = true;
          this.__isDelay = true;
          return;
        }

        this.__isDelay = false; // 减去delay，计算在哪一帧

        currentTime -= delay;

        if (this.__outBeginDelay) {
          this.__outBeginDelay = false;
          this.__begin = true;
        } // 超过duration非尾轮需处理回到开头，触发新一轮动画事件，这里可能时间间隔非常大直接跳过几轮


        var playCount = Math.min(iterations - 1, Math.floor(currentTime / duration));
        currentTime -= duration * playCount; // 如果发生轮换，需重新确定正反向

        if (this.__playCount < playCount) {
          this.__begin = true;
          this.__playCount = playCount;
          var direction = this.__direction;
          var frames = this.__frames;
          var framesR = this.__framesR; // 有正反向播放需要重设帧序列

          if (direction === 'alternate' || direction === 'alternate-reverse') {
            var isEven = playCount % 2 === 0;

            if (direction === 'alternate') {
              currentFrames = this.__currentFrames = isEven ? frames : framesR;
            } else {
              currentFrames = this.__currentFrames = isEven ? framesR : frames;
            }
          }
        }

        var isLastCount = playCount >= iterations - 1; // 只有2帧可优化，否则2分查找当前帧

        var i, frameTime;

        if (length === 2) {
          i = currentTime < duration ? 0 : 1;
          frameTime = duration;
        } else {
          i = binarySearch(0, length - 1, currentTime, currentFrames);
          frameTime = currentFrames[i].time;
        } // 最后一帧结束动画，仅最后一轮才会进入，需处理endDelay


        var isLastFrame = isLastCount && i === length - 1;
        var percent = 0;

        if (isLastFrame) ; // 否则根据目前到下一帧的时间差，计算百分比，再反馈到变化数值上
        else if (length === 2) {
          percent = currentTime / duration;
        } else {
          var total = currentFrames[i + 1].time - frameTime;
          percent = (currentTime - frameTime) / total;
        }

        var inEndDelay,
            currentFrame = currentFrames[i]; // 对比前后两帧是否为同一关键帧，不是则清除之前关键帧上的percent标识

        if (this.__currentFrame !== currentFrame) {
          this.__currentFrame && (this.__currentFrame.lastPercent = -1);
          this.__currentFrame = currentFrame;
        }
        /** 这里要考虑全几种场景：
         * 1. 单次播放无endDelay且fill不停留（有/无差异，下同）
         * 2. 单次播放无endDelay且fill停留
         * 3. 单次播放有endDelay且fill不停留
         * 4. 单次播放有endDelay且fill停留
         * 5. 多次播放无endDelay且fill不停留（尾次/非尾次，下同）
         * 6. 多次播放无endDelay且fill停留
         * 7. 多次播放有endDelay且fill不停留
         * 8. 多次播放有endDelay且fill停留
         */


        var needClean;
        var keys;

        if (isLastFrame) {
          inEndDelay = currentTime < duration + endDelay; // 停留对比最后一帧，endDelay可能会多次进入这里，第二次进入样式相等不再重绘

          if (stayEnd) {
            keys = calLastStyle(currentFrame.style, target, this.__keys);
          } // 不停留或超过endDelay则计算还原，有endDelay且fill模式不停留会再次进入这里
          else {
            keys = calLastStyle(this.__originStyle, target, this.__keys);
          } // 进入endDelay或结束阶段触发end事件，注意只触发一次，防重在触发的地方做


          this.__nextEnd = true;

          if (!inEndDelay) {
            this.__playCount++;
            this.__finished = true;
            frame.offFrame(this);
            needClean = true;
            this.__nextTime = 0;
          }
        } else {
          keys = calIntermediateStyle(currentFrame, percent, target);
        }

        this.__isChange = !keys.length; // 无论两帧之间是否有变化，都生成计算结果赋给style，去重在root做

        genBeforeRefresh(keys, root, target, null);

        if (needClean) {
          var playCb = this.__playCb;

          this.__clean(true); // 丑陋的做法，防止gotoAndStop()这样的cb被clean()掉


          if (playCb) {
            this.__playCb = playCb;
          }
        }
      }
    }, {
      key: "__after",
      value: function __after() {
        if (this.__inFps) {
          this.__inFps = false;
          return;
        }

        frameCb(this);

        if (this.__begin) {
          this.__begin = false;
          this.emit(Event.BEGIN, this.__playCount);
        } // end事件只触发一次，末轮进入endDelay或直接结束时


        if (this.__nextEnd && !this.__end) {
          this.__end = true;
          this.emit(Event.END, this.__playCount - 1);
        }

        if (this.__finished) {
          this.__begin = this.__end = this.__isDelay = this.__finished = this.__inFps = this.__enterFrame = false;
          this.__playState = 'finished';
          this.emit(Event.FINISH, this.__isChange);
        }
      }
    }, {
      key: "pause",
      value: function pause(silence) {
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var pending = this.pending;

        if (isDestroyed || duration <= 0 || pending) {
          return this;
        }

        this.__playState = 'paused';

        this.__cancelTask();

        if (!silence) {
          this.emit(Event.PAUSE);
        }

        return this;
      }
    }, {
      key: "resume",
      value: function resume(cb) {
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var playState = this.__playState;

        if (isDestroyed || duration <= 0 || playState !== 'paused') {
          return this;
        }

        return this.play(cb);
      }
    }, {
      key: "finish",
      value: function finish(cb) {
        var _this2 = this;

        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var playState = this.__playState;
        var frames = this.__frames;

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        if (playState === 'finished') {
          if (isFunction$6(cb)) {
            cb();
          }

          return this;
        } // 先清除所有回调任务，多次调用finish也会清除只留最后一次


        this.__clean(true);

        this.__begin = this.__end = this.__isDelay = this.__finished = this.__inFps = this.__enterFrame = false;
        this.__playState = 'finished';
        var root = this.__root;

        if (root) {
          var target = this.__target;
          var style; // 是否停留在最后一帧

          if (this.__stayEnd) {
            var framesR = this.__framesR;
            var direction = this.__direction;
            var iterations = this.__iterations;

            if ('reverse'.indexOf(direction) > -1) {
              var _ref = [framesR, frames];
              frames = _ref[0];
              framesR = _ref[1];
            }

            if (iterations === Infinity || iterations % 2) {
              style = frames[frames.length - 1].style;
            } else {
              style = framesR[framesR.length - 1].style;
            }
          } else {
            style = this.__originStyle;
          }

          var keys = calLastStyle(style, target, this.__keys);
          this.__isChange = !keys.length;
          genBeforeRefresh(keys, root, target, function () {
            frameCb(_this2);

            _this2.emit(Event.FINISH, _this2.__isChange);

            if (isFunction$6(cb)) {
              cb(_this2.__isChange);
            }
          });
        }

        return this;
      }
    }, {
      key: "cancel",
      value: function cancel(cb) {
        var _this3 = this;

        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var playState = this.__playState;
        var frames = this.__frames;

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        if (playState === 'idle') {
          if (isFunction$6(cb)) {
            cb();
          }

          return this;
        }

        this.__clean();

        this.__begin = this.__end = this.__isDelay = this.__finished = this.__inFps = this.__enterFrame = false;
        this.__playState = 'idle';
        var root = this.__root;

        if (root) {
          var target = this.__target;
          var keys = calLastStyle(this.__originStyle, target, this.__keys);
          this.__isChange = !keys.length;
          genBeforeRefresh(keys, root, target, function () {
            frameCb(_this3);

            _this3.emit(Event.CANCEL, _this3.__isChange);

            if (isFunction$6(cb)) {
              cb(_this3.__isChange);
            }
          });
        }

        return this;
      }
    }, {
      key: "gotoAndPlay",
      value: function gotoAndPlay(v, options, cb) {
        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var frames = this.__frames;
        var delay = this.__delay;
        var endDelay = this.__endDelay;

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        var _gotoOverload = gotoOverload(options, cb);

        var _gotoOverload2 = _slicedToArray(_gotoOverload, 2);

        options = _gotoOverload2[0];
        cb = _gotoOverload2[1];

        // 计算出时间点直接累加播放
        this.__goto(v, options.isFrame, options.excludeDelay);

        if (v > duration + delay + endDelay) {
          return this.finish(cb);
        }

        return this.play(cb);
      }
    }, {
      key: "gotoAndStop",
      value: function gotoAndStop(v, options, cb) {
        var _this4 = this;

        var isDestroyed = this.__isDestroyed;
        var duration = this.__duration;
        var frames = this.__frames;
        var delay = this.__delay;
        var endDelay = this.__endDelay;

        if (isDestroyed || duration <= 0 || frames.length < 1) {
          return this;
        }

        var _gotoOverload3 = gotoOverload(options, cb);

        var _gotoOverload4 = _slicedToArray(_gotoOverload3, 2);

        options = _gotoOverload4[0];
        cb = _gotoOverload4[1];
        v = this.__goto(v, options.isFrame, options.excludeDelay);

        if (v > duration + delay + endDelay) {
          return this.finish(cb);
        } // 先play一帧，回调里模拟暂停


        return this.play(function () {
          _this4.__playState = 'paused';

          _this4.__cancelTask();

          if (isFunction$6(cb)) {
            cb();
          }
        });
      } // 返回不包含delay且去除多轮的时间

    }, {
      key: "__goto",
      value: function __goto(v, isFrame, excludeDelay) {
        var iterations = this.__iterations;
        var duration = this.__duration;
        this.__playState = 'paused'; // this.__cancelTask(); // 应该不需要，gotoAndXxx都会调用play()，里面有

        if (isNaN(v) || v < 0) {
          throw new Error('Param of gotoAnd(Play/Stop) is illegal: ' + v);
        }

        if (isFrame) {
          v = (v - 1) / this.spf;
        }

        if (excludeDelay) {
          v += this.__delay;
        } // 在时间范围内设置好时间，复用play直接跳到播放点


        this.__nextTime = v;
        v -= this.__delay; // 超过时间长度需要累加次数，这里可以超过iterations，因为设定也许会非常大

        var playCount = 0;

        while (v >= duration && playCount < iterations - 1) {
          playCount++;
          v -= duration;
        }

        this.__playCount = playCount; // 防止play()重置时间和当前帧组，提前计算好

        this.__enterFrame = true;
        var frames = this.__frames;
        var framesR = this.__framesR;
        var direction = this.__direction;

        if ({
          alternate: true,
          'alternate-reverse': true
        }.hasOwnProperty(direction)) {
          var isEven = playCount % 2 === 0;

          if (direction === 'alternate') {
            this.__currentFrames = isEven ? frames : framesR;
          } else {
            this.__currentFrames = isEven ? framesR : frames;
          }
        }

        return v;
      }
    }, {
      key: "addControl",
      value: function addControl() {
        var root = this.root;

        if (!root) {
          return;
        }

        var ac = root.animateController;

        if (ac) {
          ac.add(this);
        }
      }
    }, {
      key: "removeControl",
      value: function removeControl() {
        var root = this.__root;

        if (!root) {
          return;
        }

        var ac = root.__animateController;

        if (ac) {
          ac.remove(this);
        }
      }
    }, {
      key: "__setTarget",
      value: function __setTarget(target) {
        this.__target = target;
      }
    }, {
      key: "__cancelTask",
      value: function __cancelTask() {
        frame.offFrame(this);
        this.__playCb = null;
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.__isDestroyed) {
          return;
        }

        this.removeControl();

        this.__clean();

        this.__target = this.__root = null;
        this.__startTime = 0;
        this.__isDestroyed = true;
      }
    }, {
      key: "__checkModify",
      value: function __checkModify() {
        if (this.__playState !== 'idle' && this.__playState !== 'finished') {
          inject.warn('Modification will not come into effect when animation is running');
        }
      }
    }, {
      key: "id",
      get: function get() {
        return this.__id;
      }
    }, {
      key: "target",
      get: function get() {
        return this.__target;
      }
    }, {
      key: "root",
      get: function get() {
        return this.__root;
      }
    }, {
      key: "keys",
      get: function get() {
        return this.__keys;
      }
    }, {
      key: "options",
      get: function get() {
        return this.__options;
      }
    }, {
      key: "duration",
      get: function get() {
        return this.__duration;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);

        if (this.__duration !== v) {
          this.__duration = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "delay",
      get: function get() {
        return this.__delay;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);

        if (this.__delay !== v) {
          this.__delay = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "endDelay",
      get: function get() {
        return this.__endDelay;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);

        if (this.__endDelay !== v) {
          this.__endDelay = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "fps",
      get: function get() {
        return this.__fps;
      },
      set: function set(v) {
        v = parseInt(v) || 60;

        if (this.__fps !== v) {
          if (v <= 0) {
            v = 60;
          }

          this.__fps = v;
        }

        return v;
      }
    }, {
      key: "spf",
      get: function get() {
        return 1 / this.fps;
      }
    }, {
      key: "iterations",
      get: function get() {
        return this.__iterations;
      },
      set: function set(v) {
        if (v === Infinity || util.isString(v) && v.toLowerCase() === 'infinity') {
          v = Infinity;
        } else {
          v = parseInt(v);

          if (isNaN(v) || v < 0) {
            v = 1;
          }
        }

        if (this.__iterations !== v) {
          this.__iterations = v;
        }

        return v;
      }
    }, {
      key: "fill",
      get: function get() {
        return this.__fill;
      },
      set: function set(v) {
        v = v || 'none';

        if (this.__fill !== v) {
          this.__fill = v;

          this.__checkModify();
        }

        this.__stayBegin = {
          backwards: true,
          both: true
        }.hasOwnProperty(v);
        this.__stayEnd = {
          forwards: true,
          both: true
        }.hasOwnProperty(v);
        return v;
      }
    }, {
      key: "direction",
      get: function get() {
        return this.__direction;
      },
      set: function set(v) {
        v = v || 'normal';

        if (this.__direction !== v) {
          this.__direction = v;

          this.__checkModify();
        }

        return v;
      }
    }, {
      key: "frames",
      get: function get() {
        return this.__frames;
      }
    }, {
      key: "framesR",
      get: function get() {
        return this.__framesR;
      }
    }, {
      key: "playbackRate",
      get: function get() {
        return this.__playbackRate;
      },
      set: function set(v) {
        v = parseFloat(v) || 1;

        if (v <= 0) {
          v = 1;
        }

        if (this.__playbackRate !== v) {
          this.__playbackRate = v;
        }

        return v;
      }
    }, {
      key: "easing",
      get: function get() {
        return this.__easing;
      },
      set: function set(v) {
        this.__easing = v;
      }
    }, {
      key: "startTime",
      get: function get() {
        return this.__startTime;
      }
    }, {
      key: "currentTime",
      get: function get() {
        return this.__currentTime;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);

        if (this.__currentTime !== v) {
          this.__currentTime = v;
          this.__nextTime = v;
        }

        return v;
      }
    }, {
      key: "nextTime",
      get: function get() {
        return this.__nextTime;
      },
      set: function set(v) {
        v = Math.max(0, parseFloat(v) || 0);

        if (this.__nextTime !== v) {
          this.__nextTime = v;
        }

        return v;
      }
    }, {
      key: "timestamp",
      get: function get() {
        return this.__timestamp;
      }
    }, {
      key: "pending",
      get: function get() {
        return this.__playState !== 'running';
      }
    }, {
      key: "finished",
      get: function get() {
        return this.__playState === 'finished';
      }
    }, {
      key: "playState",
      get: function get() {
        return this.__playState;
      }
    }, {
      key: "playCount",
      get: function get() {
        return this.__playCount;
      },
      set: function set(v) {
        v = Math.max(0, parseInt(v) || 0);

        if (this.__playCount !== v) {
          this.__playCount = v;
        }

        return v;
      }
    }, {
      key: "isDestroyed",
      get: function get() {
        return this.__isDestroyed;
      }
    }, {
      key: "animating",
      get: function get() {
        var playState = this.__playState;

        if (playState === 'idle') {
          return false;
        }

        return playState !== 'finished' || this.__stayEnd || this.__stayBegin;
      }
    }, {
      key: "spfLimit",
      get: function get() {
        return this.__spfLimit;
      },
      set: function set(v) {
        if (util.isNumber(v) || /^\d/.test(v)) {
          v = Math.max(0, parseInt(v) || 0);
        } else {
          v = !!v;
        }

        if (this.__spfLimit !== v) {
          this.__spfLimit = v;
        }

        return v;
      }
    }]);

    return Animation;
  }(Event);

  var int2rgba$2 = util.int2rgba;
  var canvasPolygon$3 = painter.canvasPolygon,
      svgPolygon$3 = painter.svgPolygon;

  function renderBoxShadow(xom, renderMode, ctx, data, x1, y1, x2, y2, w, h) {
    var dx = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 0;
    var dy = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;

    var _data = _slicedToArray(data, 6),
        x = _data[0],
        y = _data[1],
        sigma = _data[2],
        spread = _data[3],
        color = _data[4],
        inset = _data[5];

    var c = int2rgba$2(color);
    var n = Math.abs(sigma) * 2 + Math.abs(spread) * 2 + Math.abs(x) * 2 + Math.abs(y) * 2; // box本身坐标顺时针

    var box = [[x1, y1], [x2, y1], [x2, y2], [x1, y2], [x1, y1]]; // 算上各种偏移/扩散的最外层坐标，且逆时针

    var outer = [[x1 - n, y1 - n], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n]];

    if (color[3] > 0) {
      if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
        ctx.save();
        ctx.beginPath(); // inset裁剪box外面

        if (inset === 'inset') {
          var xa = x1 + x + spread;
          var ya = y1 + y + spread;
          var xb = x2 + x - spread;
          var yb = y2 + y - spread;
          var spreadBox = [[xa, ya], [xb, ya], [xb, yb], [xa, yb]]; // 是否相交判断需要绘制

          var cross = geom$1.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [spreadBox[0][0], spreadBox[0][1], spreadBox[2][0], spreadBox[2][1]]);

          if (!cross) {
            return;
          }

          cross = [[cross[0], cross[1]], [cross[2], cross[1]], [cross[2], cross[3]], [cross[0], cross[3]], [cross[0], cross[1]]]; // 扩散区域类似边框填充

          if (spread) {
            canvasPolygon$3(ctx, cross);
            canvasPolygon$3(ctx, box.slice(0).reverse());
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== c) {
              ctx.fillStyle = c;
            }

            canvasPolygon$3(ctx, box);
            ctx.fill();
            ctx.closePath();
            ctx.restore();
            ctx.save();
            ctx.beginPath();
            canvasPolygon$3(ctx, cross);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowColor = c;
            ctx.shadowBlur = sigma; // 画在外围的空心矩形，宽度要比blur大，n考虑了这一情况取了最大值

            canvasPolygon$3(ctx, [[xa, ya], [xb, ya], [xb, yb], [x1 - n, yb], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, yb], [xa, yb], [xa, ya]]);
          } else {
            canvasPolygon$3(ctx, box);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowOffsetX = x;
            ctx.shadowOffsetY = y;
            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$3(ctx, [[x1, y1], [x2, y1], [x2, y2], [x1 - n, y2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, y2], [x1, y2], [x1, y1]]);
          }
        } // outset需裁减掉box本身的内容，clip()非零环绕显示box外的阴影内容，fill()绘制在内无效
        else {
          var _xa = x1 + x - spread;

          var _ya = y1 + y - spread;

          var _xb = x2 + x + spread;

          var _yb = y2 + y + spread;

          var blurBox = [[_xa, _ya], [_xb, _ya], [_xb, _yb], [_xa, _yb]];

          var _cross = geom$1.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [blurBox[0][0], blurBox[0][1], blurBox[2][0], blurBox[2][1]]); // 分为是否有spread，因模糊成本spread区域将没有模糊


          if (spread) {
            // 扩散区域类似边框填充
            canvasPolygon$3(ctx, box);
            canvasPolygon$3(ctx, blurBox.slice(0).reverse());
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== c) {
              ctx.fillStyle = c;
            }

            canvasPolygon$3(ctx, blurBox);
            ctx.fill();
            ctx.closePath();
            ctx.restore();
            ctx.save();
            ctx.beginPath(); // 阴影部分看相交情况裁剪，有相交时逆时针绘制相交区域即可排除之

            if (_cross) {
              canvasPolygon$3(ctx, [[_cross[0], _cross[1]], [_cross[2], _cross[1]], [_cross[2], _cross[3]], [_cross[0], _cross[3]], [_cross[0], _cross[1]]].reverse());
            }

            canvasPolygon$3(ctx, box);
            canvasPolygon$3(ctx, blurBox);
            canvasPolygon$3(ctx, outer);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$3(ctx, blurBox);
          } else {
            canvasPolygon$3(ctx, box);
            canvasPolygon$3(ctx, outer);
            ctx.clip();
            ctx.closePath();
            ctx.beginPath();

            if (ctx.fillStyle !== '#FFF') {
              ctx.fillStyle = '#FFF';
            }

            ctx.shadowOffsetX = x;
            ctx.shadowOffsetY = y;
            ctx.shadowColor = c;
            ctx.shadowBlur = sigma;
            canvasPolygon$3(ctx, box);
          }
        }

        ctx.fill();
        ctx.closePath();
        ctx.restore();
      } else if (renderMode === mode.SVG) {
        var d = blur.outerSize(sigma);

        if (inset === 'inset') {
          var _xa2 = x1 + x + spread;

          var _ya2 = y1 + y + spread;

          var _xb2 = x2 + x - spread;

          var _yb2 = y2 + y - spread;

          var _spreadBox = [[_xa2, _ya2], [_xb2, _ya2], [_xb2, _yb2], [_xa2, _yb2]];

          var _cross2 = geom$1.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [_spreadBox[0][0], _spreadBox[0][1], _spreadBox[2][0], _spreadBox[2][1]]);

          if (!_cross2) {
            return;
          }

          _cross2 = [[_cross2[0], _cross2[1]], [_cross2[2], _cross2[1]], [_cross2[2], _cross2[3]], [_cross2[0], _cross2[3]], [_cross2[0], _cross2[1]]];

          if (spread) {
            var v = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', 0], ['dy', 0], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            xom.__cacheDefs.push(v);

            var filter = ctx.add(v);
            var v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(_cross2) + svgPolygon$3(box.slice(0).reverse())], ['fill', '#FFF']]
              }]
            };
            var clip = ctx.add(v2);

            xom.__cacheDefs.push(v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(box)], ['fill', c], ['clip-path', 'url(#' + clip + ')']]
            });
            v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(_cross2)], ['fill', '#FFF']]
              }]
            };
            clip = ctx.add(v);

            xom.__cacheDefs.push(v);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3([[_xa2, _ya2], [_xb2, _ya2], [_xb2, _yb2], [x1 - n, _yb2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, _yb2], [_xa2, _yb2], [_xa2, _ya2]])], ['fill', '#FFF'], ['filter', 'url(#' + filter + ')'], ['clip-path', 'url(#' + clip + ')']]
            });
          } else {
            var _v = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', x], ['dy', y], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter = ctx.add(_v);

            xom.__cacheDefs.push(_v);

            _v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box)], ['fill', '#FFF']]
              }]
            };

            var _clip = ctx.add(_v);

            xom.__cacheDefs.push(_v);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3([[x1, y1], [x2, y1], [x2, y2], [x1 - n, y2], [x1 - n, y2 + n], [x2 + n, y2 + n], [x2 + n, y1 - n], [x1 - n, y1 - n], [x1 - n, y2], [x1, y2], [x1, y1]])], ['fill', '#FFF'], ['filter', 'url(#' + _filter + ')'], ['clip-path', 'url(#' + _clip + ')']]
            });
          }
        } else {
          var _xa3 = x1 + x - spread;

          var _ya3 = y1 + y - spread;

          var _xb3 = x2 + x + spread;

          var _yb3 = y2 + y + spread;

          var _blurBox = [[_xa3, _ya3], [_xb3, _ya3], [_xb3, _yb3], [_xa3, _yb3]];

          var _cross3 = geom$1.getRectsIntersection([box[0][0], box[0][1], box[2][0], box[2][1]], [_blurBox[0][0], _blurBox[0][1], _blurBox[2][0], _blurBox[2][1]]);

          if (spread) {
            var _v2 = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', 0], ['dy', 0], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter2 = ctx.add(_v2);

            xom.__cacheDefs.push(_v2);

            _v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box) + svgPolygon$3(_blurBox.slice(0).reverse())], ['fill', '#FFF']]
              }]
            };

            var _clip2 = ctx.add(_v2);

            xom.__cacheDefs.push(_v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(_blurBox)], ['fill', c], ['clip-path', 'url(#' + _clip2 + ')']]
            });
            _v2 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', (_cross3 ? svgPolygon$3([[_cross3[0], _cross3[1]], [_cross3[2], _cross3[1]], [_cross3[2], _cross3[3]], [_cross3[0], _cross3[3]], [_cross3[0], _cross3[1]]].reverse()) : '') + svgPolygon$3(box) + svgPolygon$3(_blurBox) + svgPolygon$3(outer)], ['fill', '#FFF']]
              }]
            };
            _clip2 = ctx.add(_v2);

            xom.__cacheDefs.push(_v2);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(_blurBox)], ['fill', '#FFF'], ['filter', 'url(#' + _filter2 + ')'], ['clip-path', 'url(#' + _clip2 + ')']]
            });
          } else {
            var _v3 = {
              tagName: 'filter',
              props: [['x', -d / w], ['y', -d / h], ['width', 1 + d * 2 / w], ['height', 1 + d * 2 / h]],
              children: [{
                tagName: 'feDropShadow',
                props: [['dx', x], ['dy', y], ['stdDeviation', sigma * 0.5], ['flood-color', c]]
              }]
            };

            var _filter3 = ctx.add(_v3);

            xom.__cacheDefs.push(_v3);

            _v3 = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$3(box) + svgPolygon$3(outer)], ['fill', '#FFF']]
              }]
            };

            var _clip3 = ctx.add(_v3);

            xom.__cacheDefs.push(_v3);

            xom.virtualDom.bb.push({
              type: 'item',
              tagName: 'path',
              props: [['d', svgPolygon$3(box)], ['fill', '#FFF'], ['filter', 'url(#' + _filter3 + ')'], ['clip-path', 'url(#' + _clip3 + ')']]
            });
          }
        }
      }
    }
  }

  var bs = {
    renderBoxShadow: renderBoxShadow
  };

  var hash = {};

  function mbmName$2(v) {
    if (v) {
      if (hash.hasOwnProperty(v)) {
        return hash[v];
      }

      return hash[v] = v.replace(/[A-Z]/, function ($0) {
        return '-' + $0.toLowerCase();
      });
    }
  }

  function isValidMbm$2(v) {
    if (v === 'normal') {
      return false;
    }

    return v === 'multiply' || v === 'screen' || v === 'overlay' || v === 'darken' || v === 'lighten' || v === 'colorDodge' || v === 'color-dodge' || v === 'colorBurn' || v === 'color-burn' || v === 'hardLight' || v === 'hard-light' || v === 'softLight' || v === 'soft-light' || v === 'difference' || v === 'exclusion' || v === 'hue' || v === 'saturation' || v === 'color' || v === 'luminosity';
  }

  var mbm = {
    mbmName: mbmName$2,
    isValidMbm: isValidMbm$2
  };

  var svgPolygon$2 = painter.svgPolygon;
  var CANVAS$1 = mode.CANVAS,
      SVG$1 = mode.SVG,
      WEBGL$1 = mode.WEBGL;
  var normalize = css.normalize,
      equalStyle = css.equalStyle;
  var STYLE_KEY = enums.STYLE_KEY,
      STYLE_RV_KEY = enums.STYLE_RV_KEY,
      style2Upper = enums.style2Upper,
      _enums$STYLE_KEY$8 = enums.STYLE_KEY,
      BORDER_TOP_LEFT_RADIUS$1 = _enums$STYLE_KEY$8.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS$1 = _enums$STYLE_KEY$8.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS$1 = _enums$STYLE_KEY$8.BORDER_BOTTOM_LEFT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS$1 = _enums$STYLE_KEY$8.BORDER_BOTTOM_RIGHT_RADIUS,
      PADDING_LEFT$5 = _enums$STYLE_KEY$8.PADDING_LEFT,
      PADDING_RIGHT$4 = _enums$STYLE_KEY$8.PADDING_RIGHT,
      PADDING_TOP$3 = _enums$STYLE_KEY$8.PADDING_TOP,
      PADDING_BOTTOM$2 = _enums$STYLE_KEY$8.PADDING_BOTTOM,
      MARGIN_LEFT$5 = _enums$STYLE_KEY$8.MARGIN_LEFT,
      MARGIN_TOP$3 = _enums$STYLE_KEY$8.MARGIN_TOP,
      MARGIN_BOTTOM$3 = _enums$STYLE_KEY$8.MARGIN_BOTTOM,
      MARGIN_RIGHT$4 = _enums$STYLE_KEY$8.MARGIN_RIGHT,
      BORDER_LEFT_WIDTH$5 = _enums$STYLE_KEY$8.BORDER_LEFT_WIDTH,
      BORDER_TOP_WIDTH$3 = _enums$STYLE_KEY$8.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$2 = _enums$STYLE_KEY$8.BORDER_BOTTOM_WIDTH,
      BORDER_RIGHT_WIDTH$4 = _enums$STYLE_KEY$8.BORDER_RIGHT_WIDTH,
      TOP$3 = _enums$STYLE_KEY$8.TOP,
      RIGHT$2 = _enums$STYLE_KEY$8.RIGHT,
      BOTTOM$3 = _enums$STYLE_KEY$8.BOTTOM,
      LEFT$2 = _enums$STYLE_KEY$8.LEFT,
      POSITION$3 = _enums$STYLE_KEY$8.POSITION,
      DISPLAY$6 = _enums$STYLE_KEY$8.DISPLAY,
      WIDTH$5 = _enums$STYLE_KEY$8.WIDTH,
      HEIGHT$5 = _enums$STYLE_KEY$8.HEIGHT,
      MATRIX$1 = _enums$STYLE_KEY$8.MATRIX,
      TRANSLATE_X = _enums$STYLE_KEY$8.TRANSLATE_X,
      TRANSLATE_Y = _enums$STYLE_KEY$8.TRANSLATE_Y,
      TRANSLATE_Z = _enums$STYLE_KEY$8.TRANSLATE_Z,
      TRANSFORM$3 = _enums$STYLE_KEY$8.TRANSFORM,
      SCALE_X = _enums$STYLE_KEY$8.SCALE_X,
      SCALE_Y = _enums$STYLE_KEY$8.SCALE_Y,
      SCALE_Z = _enums$STYLE_KEY$8.SCALE_Z,
      ROTATE_X = _enums$STYLE_KEY$8.ROTATE_X,
      ROTATE_Y = _enums$STYLE_KEY$8.ROTATE_Y,
      ROTATE_Z = _enums$STYLE_KEY$8.ROTATE_Z,
      SKEW_X = _enums$STYLE_KEY$8.SKEW_X,
      SKEW_Y = _enums$STYLE_KEY$8.SKEW_Y,
      PERSPECTIVE$1 = _enums$STYLE_KEY$8.PERSPECTIVE,
      PERSPECTIVE_ORIGIN$1 = _enums$STYLE_KEY$8.PERSPECTIVE_ORIGIN,
      ROTATE_3D = _enums$STYLE_KEY$8.ROTATE_3D,
      TRANSFORM_ORIGIN$2 = _enums$STYLE_KEY$8.TRANSFORM_ORIGIN,
      BACKGROUND_POSITION_X = _enums$STYLE_KEY$8.BACKGROUND_POSITION_X,
      BACKGROUND_POSITION_Y = _enums$STYLE_KEY$8.BACKGROUND_POSITION_Y,
      BACKGROUND_SIZE = _enums$STYLE_KEY$8.BACKGROUND_SIZE,
      BACKGROUND_COLOR = _enums$STYLE_KEY$8.BACKGROUND_COLOR,
      BACKGROUND_IMAGE = _enums$STYLE_KEY$8.BACKGROUND_IMAGE,
      BACKGROUND_REPEAT = _enums$STYLE_KEY$8.BACKGROUND_REPEAT,
      BOX_SHADOW = _enums$STYLE_KEY$8.BOX_SHADOW,
      OPACITY$3 = _enums$STYLE_KEY$8.OPACITY,
      Z_INDEX$2 = _enums$STYLE_KEY$8.Z_INDEX,
      BORDER_TOP_STYLE = _enums$STYLE_KEY$8.BORDER_TOP_STYLE,
      BORDER_RIGHT_STYLE = _enums$STYLE_KEY$8.BORDER_RIGHT_STYLE,
      BORDER_BOTTOM_STYLE = _enums$STYLE_KEY$8.BORDER_BOTTOM_STYLE,
      BORDER_LEFT_STYLE = _enums$STYLE_KEY$8.BORDER_LEFT_STYLE,
      FILTER$2 = _enums$STYLE_KEY$8.FILTER,
      OVERFLOW$2 = _enums$STYLE_KEY$8.OVERFLOW,
      MIX_BLEND_MODE$3 = _enums$STYLE_KEY$8.MIX_BLEND_MODE,
      TEXT_OVERFLOW = _enums$STYLE_KEY$8.TEXT_OVERFLOW,
      BORDER_TOP_COLOR = _enums$STYLE_KEY$8.BORDER_TOP_COLOR,
      BORDER_BOTTOM_COLOR = _enums$STYLE_KEY$8.BORDER_BOTTOM_COLOR,
      BORDER_LEFT_COLOR = _enums$STYLE_KEY$8.BORDER_LEFT_COLOR,
      BORDER_RIGHT_COLOR = _enums$STYLE_KEY$8.BORDER_RIGHT_COLOR,
      FONT_STYLE = _enums$STYLE_KEY$8.FONT_STYLE,
      COLOR$1 = _enums$STYLE_KEY$8.COLOR,
      VISIBILITY$4 = _enums$STYLE_KEY$8.VISIBILITY,
      POINTER_EVENTS$1 = _enums$STYLE_KEY$8.POINTER_EVENTS,
      BORDER_TOP = _enums$STYLE_KEY$8.BORDER_TOP,
      BORDER_RIGHT = _enums$STYLE_KEY$8.BORDER_RIGHT,
      BORDER_BOTTOM = _enums$STYLE_KEY$8.BORDER_BOTTOM,
      BORDER_LEFT = _enums$STYLE_KEY$8.BORDER_LEFT,
      BACKGROUND_CLIP = _enums$STYLE_KEY$8.BACKGROUND_CLIP,
      FONT_SIZE$2 = _enums$STYLE_KEY$8.FONT_SIZE,
      FONT_FAMILY$1 = _enums$STYLE_KEY$8.FONT_FAMILY,
      LINE_HEIGHT$2 = _enums$STYLE_KEY$8.LINE_HEIGHT,
      TEXT_STROKE_COLOR$1 = _enums$STYLE_KEY$8.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH$1 = _enums$STYLE_KEY$8.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER$1 = _enums$STYLE_KEY$8.TEXT_STROKE_OVER,
      FONT_WEIGHT$1 = _enums$STYLE_KEY$8.FONT_WEIGHT,
      FLEX_DIRECTION$1 = _enums$STYLE_KEY$8.FLEX_DIRECTION,
      JUSTIFY_CONTENT$1 = _enums$STYLE_KEY$8.JUSTIFY_CONTENT,
      ALIGN_ITEMS$1 = _enums$STYLE_KEY$8.ALIGN_ITEMS,
      ALIGN_SELF$1 = _enums$STYLE_KEY$8.ALIGN_SELF,
      FLEX_GROW$1 = _enums$STYLE_KEY$8.FLEX_GROW,
      FLEX_SHRINK$1 = _enums$STYLE_KEY$8.FLEX_SHRINK,
      LINE_CLAMP$1 = _enums$STYLE_KEY$8.LINE_CLAMP,
      ORDER$1 = _enums$STYLE_KEY$8.ORDER,
      FLEX_WRAP$1 = _enums$STYLE_KEY$8.FLEX_WRAP,
      ALIGN_CONTENT$1 = _enums$STYLE_KEY$8.ALIGN_CONTENT,
      TEXT_ALIGN$1 = _enums$STYLE_KEY$8.TEXT_ALIGN,
      LETTER_SPACING = _enums$STYLE_KEY$8.LETTER_SPACING,
      WHITE_SPACE$1 = _enums$STYLE_KEY$8.WHITE_SPACE,
      WRITING_MODE$2 = _enums$STYLE_KEY$8.WRITING_MODE;
  var AUTO$4 = o$4.AUTO,
      PX$5 = o$4.PX,
      PERCENT$4 = o$4.PERCENT,
      INHERIT$1 = o$4.INHERIT,
      NUMBER$1 = o$4.NUMBER,
      RGBA$1 = o$4.RGBA,
      STRING = o$4.STRING,
      REM$4 = o$4.REM,
      VW$4 = o$4.VW,
      VH$4 = o$4.VH,
      VMAX$4 = o$4.VMAX,
      VMIN$4 = o$4.VMIN,
      DEG = o$4.DEG,
      GRADIENT$1 = o$4.GRADIENT;
  var int2rgba$1 = util.int2rgba,
      rgba2int = util.rgba2int,
      joinArr$1 = util.joinArr,
      isNil$9 = util.isNil,
      isFunction$5 = util.isFunction;
  var calRelative = css.calRelative,
      calNormalLineHeight = css.calNormalLineHeight,
      calFontFamily = css.calFontFamily,
      spreadBoxShadow = css.spreadBoxShadow,
      spreadFilter$1 = css.spreadFilter;
  var GEOM = o$2.GEOM;
  var mbmName$1 = mbm.mbmName,
      isValidMbm$1 = mbm.isValidMbm;
  var point2d = mx.point2d;
  var contain$3 = o$1.contain,
      TF$1 = o$1.TRANSFORM,
      REFLOW$2 = o$1.REFLOW,
      REPAINT$3 = o$1.REPAINT,
      TX = o$1.TRANSLATE_X,
      TY = o$1.TRANSLATE_Y,
      TZ = o$1.TRANSLATE_Z,
      TRANSFORM_ALL$3 = o$1.TRANSFORM_ALL,
      CACHE$3 = o$1.CACHE;

  function getFirstEmptyInlineWidth(xom) {
    var n = 0;
    var flowChildren = xom.flowChildren;
    var length = flowChildren.length;

    for (var i = 0; i < length; i++) {
      var child = flowChildren[i];

      if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
        if (child.flowChildren && child.flowChildren.length) {
          n += getFirstEmptyInlineWidth(child);
          break;
        } else if (child.__isInline) {
          n += child.outerWidth;
        }
      } else {
        break;
      }
    }

    return n;
  }

  function getLastEmptyInlineWidth(xom) {
    var n = 0;
    var flowChildren = xom.flowChildren;
    var length = flowChildren.length;

    for (var i = length - 1; i >= 0; i--) {
      var child = flowChildren[i];

      if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
        if (child.flowChildren && child.flowChildren.length) {
          n += getLastEmptyInlineWidth(child);
          break;
        } else {
          n += child.outerWidth;
        }
      } else {
        break;
      }
    }

    return n;
  }

  var Xom = /*#__PURE__*/function (_Node) {
    _inherits(Xom, _Node);

    function Xom(tagName) {
      var _this;

      var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _this = _Node.call(this) || this; // 构建工具中都是arr，手写可能出现hash情况

      if (Array.isArray(props)) {
        _this.props = util.arr2hash(props);
      } else {
        _this.props = props;
      }

      _this.__tagName = tagName;
      _this.__style = _this.props.style || {}; // style被解析后的k-v形式

      _this.__currentStyle = {}; // 动画过程中绘制一开始会merge动画样式

      _this.__computedStyle = {}; // 类似getComputedStyle()将currentStyle计算好数值赋给

      _this.__listener = {};
      Object.keys(_this.props).forEach(function (k) {
        var v = _this.props[k];

        if (/^on[a-zA-Z]/.test(k)) {
          k = k.slice(2).toLowerCase();
          _this.listener[k] = v;
        }
      });
      _this.__animationList = [];
      _this.__loadBgi = {
        // 刷新回调函数，用以destroy取消用
        cb: function cb() {}
      };
      _this.__cacheStyle = {}; // 是否缓存重新计算computedStyle的样式key

      _this.__cacheDefs = []; // svg专用，缓存渲染时使用已有的defs，diff过程用，否则会defs被清空

      var isClip = _this.__isClip = !!_this.props.clip;
      _this.__isMask = isClip || !!_this.props.mask;
      _this.__refreshLevel = REFLOW$2;
      _this.__limitCache = false;
      _this.__isInline = false;
      _this.__hasContent = false;
      _this.__opacity = 1;
      _this.__matrix = [];
      _this.__matrixEvent = [];
      _this.__perspectiveMatrix = [];
      _this.__frameAnimateList = [];
      _this.__contentBoxList = []; // inline存储内容用

      _this.__cacheAsBitmap = !!_this.props.cacheAsBitmap;
      _this.__cache = _this.__cacheTotal = _this.__cacheFilter = _this.__cacheMask = _this.__cacheOverflow = null;
      _this.__layoutData = null; // 缓存上次布局x/y/w/h数据

      _this.__hasComputeReflow = false; // 每次布局计算缓存标，使得每次开始只computeReflow一次

      _this.__parentLineBox = null; // inline时指向

      _this.__fontRegister = {}; // 优先级字体尚未加载时记录回调hash，销毁时删除回调

      return _this;
    }

    _createClass(Xom, [{
      key: "__structure",
      value: function __structure(lv, j) {
        var res = _get(_getPrototypeOf(Xom.prototype), "__structure", this).call(this, lv, j);

        if (this.__hasMask) {
          res.hasMask = this.__hasMask;
        }

        return res;
      }
    }, {
      key: "__modifyStruct",
      value: function __modifyStruct() {} // 设置margin/padding的实际值，layout时执行，inline的垂直方向仍然计算值，但在布局时被忽略

    }, {
      key: "__mp",
      value: function __mp(currentStyle, computedStyle, w) {
        var _this2 = this;

        ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
          var a = STYLE_KEY[style2Upper('margin' + k)];
          var b = STYLE_KEY[style2Upper('padding' + k)];
          computedStyle[a] = _this2.__calSize(currentStyle[a], w, true);
          computedStyle[b] = _this2.__calSize(currentStyle[b], w, true);
        });
      }
    }, {
      key: "__calSize",
      value: function __calSize(v, w, includePercent) {
        if (v.u === PX$5) {
          return v.v;
        } else if (v.u === PERCENT$4) {
          if (includePercent) {
            return v.v * w * 0.01;
          }
        } else if (v.u === REM$4 || v.u === REM$4) {
          return v.v * this.__root.computedStyle[FONT_SIZE$2];
        } else if (v.u === VW$4) {
          return v.v * this.__root.width * 0.01;
        } else if (v.u === VH$4) {
          return v.v * this.__root.height * 0.01;
        } else if (v.u === VMAX$4) {
          return v.v * Math.max(this.__root.width, this.__root.height) * 0.01;
        } else if (v.u === VMIN$4) {
          return v.v * Math.min(this.__root.width, this.__root.height) * 0.01;
        }

        return 0;
      }
    }, {
      key: "__computeReflow",
      value: function __computeReflow() {
        var _this3 = this;

        if (this.__hasComputeReflow) {
          return;
        }

        this.__hasComputeReflow = true;
        var currentStyle = this.__currentStyle,
            computedStyle = this.__computedStyle,
            parent = this.__domParent;
        var isRoot = !parent;
        var parentComputedStyle = parent && parent.__computedStyle; // 继承的特殊处理，根节点用默认值

        [FONT_SIZE$2, FONT_FAMILY$1, FONT_WEIGHT$1, WRITING_MODE$2].forEach(function (k) {
          var v = currentStyle[k]; // ff特殊处理

          if (k === FONT_FAMILY$1) {
            if (v.u === INHERIT$1) {
              computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : parentComputedStyle[k];
            } else {
              computedStyle[k] = v.v;
              var ff = v.v.split(/\s*,\s*/); // 从左到右即声明的字体优先级

              for (var i = 0, len = ff.length; i < len; i++) {
                var item = ff[i].replace(/^['"]/, '').replace(/['"]$/, '');

                if (o$3.hasRegister(item)) {
                  // 如果已经注册加载了，或者注册且本地支持的，说明可用
                  if (o$3.hasLoaded(item) || inject.checkSupportFontFamily(item)) {
                    break;
                  }
                } // 不可用的都特殊记住等待注册回调__loadFontCallback


                _this3.__fontRegister[item] = true;
                o$3.onRegister(item, _this3);
              }
            }
          } else if (v.u === INHERIT$1) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : parentComputedStyle[k];
          } // 只有fontSize会有%
          else if (v.u === PERCENT$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : parentComputedStyle[k] * v.v * 0.01;
          } else if (v.u === REM$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : _this3.root.computedStyle[FONT_SIZE$2] * v.v;
          } else if (v.u === VW$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : _this3.root.width * 0.01 * v.v;
          } else if (v.u === VH$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : _this3.root.height * 0.01 * v.v;
          } else if (v.u === VMAX$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : Math.max(_this3.root.width, _this3.root.height) * 0.01 * v.v;
          } else if (v.u === VMIN$4) {
            computedStyle[k] = isRoot ? reset.INHERIT[STYLE_RV_KEY[k]] : Math.min(_this3.root.width, _this3.root.height) * 0.01 * v.v;
          } else {
            computedStyle[k] = v.v;
          }
        });
        [BORDER_TOP_WIDTH$3, BORDER_RIGHT_WIDTH$4, BORDER_BOTTOM_WIDTH$2, BORDER_LEFT_WIDTH$5].forEach(function (k) {
          // border-width不支持百分比
          var item = currentStyle[k];
          computedStyle[k] = _this3.__calSize(item, 0, false);
        });
        [POSITION$3, DISPLAY$6, FLEX_DIRECTION$1, JUSTIFY_CONTENT$1, ALIGN_ITEMS$1, ALIGN_SELF$1, FLEX_GROW$1, FLEX_SHRINK$1, LINE_CLAMP$1, ORDER$1, FLEX_WRAP$1, ALIGN_CONTENT$1, OVERFLOW$2, TEXT_OVERFLOW].forEach(function (k) {
          computedStyle[k] = currentStyle[k];
        }); // writingMode特殊判断inline

        if (parentComputedStyle && computedStyle[WRITING_MODE$2] !== parentComputedStyle[WRITING_MODE$2] && computedStyle[DISPLAY$6] === 'inline') {
          computedStyle[DISPLAY$6] = 'inlineBlock';
        } // 匿名块对象


        if (computedStyle[POSITION$3] === 'absolute' || parentComputedStyle && parentComputedStyle[DISPLAY$6] === 'flex') {
          if (['block', 'flex'].indexOf(computedStyle[DISPLAY$6]) === -1) {
            computedStyle[DISPLAY$6] = 'block';
          }
        }

        var textAlign = currentStyle[TEXT_ALIGN$1];

        if (textAlign.u === INHERIT$1) {
          computedStyle[TEXT_ALIGN$1] = isRoot ? 'left' : parentComputedStyle[TEXT_ALIGN$1];
        } else {
          computedStyle[TEXT_ALIGN$1] = textAlign.v;
        }

        var fontSize = computedStyle[FONT_SIZE$2];
        var lineHeight = currentStyle[LINE_HEIGHT$2]; // lineHeight继承很特殊，数字和normal不同于普通单位

        if (lineHeight.u === INHERIT$1) {
          if (isRoot) {
            computedStyle[LINE_HEIGHT$2] = calNormalLineHeight(computedStyle);
          } else {
            var p = parent;
            var ph;

            while (p) {
              ph = p.currentStyle[LINE_HEIGHT$2];

              if (ph.u !== INHERIT$1) {
                break;
              }

              p = p.domParent;
            } // 到root还是inherit或normal，或者中途遇到了normal，使用normal


            if ([AUTO$4, INHERIT$1].indexOf(ph.u) > -1) {
              computedStyle[LINE_HEIGHT$2] = calNormalLineHeight(computedStyle);
            } // 数字继承
            else if (ph.u === NUMBER$1) {
              computedStyle[LINE_HEIGHT$2] = Math.max(ph.v, 0) * fontSize;
            } // 单位继承
            else {
              computedStyle[LINE_HEIGHT$2] = parentComputedStyle[LINE_HEIGHT$2];
            }
          }
        } else if (lineHeight.u === NUMBER$1) {
          computedStyle[LINE_HEIGHT$2] = Math.max(lineHeight.v, 0) * fontSize || calNormalLineHeight(computedStyle);
        } // 防止为0
        else {
          var v = Math.max(this.__calSize(lineHeight, fontSize, true), 0);
          computedStyle[LINE_HEIGHT$2] = v || calNormalLineHeight(computedStyle);
        }

        var letterSpacing = currentStyle[LETTER_SPACING];

        if (letterSpacing.u === INHERIT$1) {
          computedStyle[LETTER_SPACING] = isRoot ? 0 : parentComputedStyle[LETTER_SPACING];
        } else {
          computedStyle[LETTER_SPACING] = this.__calSize(letterSpacing, fontSize, true);
        } //whiteSpace


        var whiteSpace = currentStyle[WHITE_SPACE$1];

        if (whiteSpace.u === INHERIT$1) {
          computedStyle[WHITE_SPACE$1] = isRoot ? 'normal' : parentComputedStyle[WHITE_SPACE$1];
        } else {
          computedStyle[WHITE_SPACE$1] = whiteSpace.v;
        }

        var width = currentStyle[WIDTH$5],
            height = currentStyle[HEIGHT$5];
        this.__width = this.__height = 0; // 布局前固定尺寸的线设置好，子元素percent尺寸要用到，flex的子元素侧轴stretch也要特殊提前处理，认为定高

        if (width.u !== AUTO$4) {
          this.__width = computedStyle[WIDTH$5] = this.__calSize(width, isRoot ? this.__width : parent.__width, true);
        }

        if (height.u !== AUTO$4) {
          this.__height = computedStyle[HEIGHT$5] = this.__calSize(height, isRoot ? this.__height : parent.__height, true);
        } else {
          var p = this.__domParent;

          if (p) {
            var crs = p.__currentStyle;
            var alignSelf = currentStyle[ALIGN_SELF$1]; // flex的子元素stretch提前处理认为高度，以便其子元素%高度计算

            if (crs[DISPLAY$6] === 'flex' && p.__height) {
              if (crs[FLEX_DIRECTION$1].indexOf('row') > -1 && (alignSelf === 'stretch' || crs[ALIGN_ITEMS$1] === 'stretch' && alignSelf === 'auto')) {
                this.__height = p.__height;
              }
            }
          }
        }
      }
    }, {
      key: "__emitFontRegister",
      value: function __emitFontRegister(fontFamily) {
        var node = this,
            fontRegister = node.__fontRegister;

        if (node.__isDestroyed) {
          return;
        }

        delete fontRegister[fontFamily];
        var root = node.root,
            currentStyle = node.currentStyle;

        if (!root) {
          return;
        }

        var v = currentStyle[FONT_FAMILY$1];

        if (v.u === INHERIT$1) {
          return;
        }

        var ff = v.v.split(/\s*,\s*/);

        for (var i = 0, len = ff.length; i < len; i++) {
          var item = ff[i].replace(/^['"]/, '').replace(/['"]$/, '');

          if (item === fontFamily) {
            // 加载成功回调可能没注册信息，需要多判断一下
            if (o$3.hasRegister(item)) {
              root.__addUpdate(node, {
                focus: o$1.REFLOW
              });
            } // 后面低优先级的无需再看


            return;
          } // 有更高优先级的已经支持了，回调刷新无效
          else if (o$3.hasRegister(item) && (o$3.hasLoaded(item) || inject.checkSupportFontFamily(item))) {
            return;
          }
        }
      } // dom常用的几种尺寸赋值

    }, {
      key: "__ioSize",
      value: function __ioSize(w, h) {
        var computedStyle = this.computedStyle; // 可能不传，在虚拟布局时用不到

        if (!isNil$9(w)) {
          this.__width = computedStyle[WIDTH$5] = w;
          this.__clientWidth = w += computedStyle[PADDING_LEFT$5] + computedStyle[PADDING_RIGHT$4];
          this.__offsetWidth = w += computedStyle[BORDER_LEFT_WIDTH$5] + computedStyle[BORDER_RIGHT_WIDTH$4];
          this.__outerWidth = w + computedStyle[MARGIN_LEFT$5] + computedStyle[MARGIN_RIGHT$4];
        }

        if (!isNil$9(h)) {
          this.__height = computedStyle[HEIGHT$5] = h;
          this.__clientHeight = h += computedStyle[PADDING_TOP$3] + computedStyle[PADDING_BOTTOM$2];
          this.__offsetHeight = h += computedStyle[BORDER_TOP_WIDTH$3] + computedStyle[BORDER_BOTTOM_WIDTH$2];
          this.__outerHeight = h + computedStyle[MARGIN_TOP$3] + computedStyle[MARGIN_BOTTOM$3];
        }
      } // 为basis的b/min/max添加mpb，只有当b未显示指定等于w/content时才加，同时返回mpb值

    }, {
      key: "__addMBP",
      value: function __addMBP(isDirectionRow, w, currentStyle, computedStyle, res, isDirectItem) {
        var marginLeft = currentStyle[MARGIN_LEFT$5],
            marginTop = currentStyle[MARGIN_TOP$3],
            marginRight = currentStyle[MARGIN_RIGHT$4],
            marginBottom = currentStyle[MARGIN_BOTTOM$3],
            paddingLeft = currentStyle[PADDING_LEFT$5],
            paddingTop = currentStyle[PADDING_TOP$3],
            paddingRight = currentStyle[PADDING_RIGHT$4],
            paddingBottom = currentStyle[PADDING_BOTTOM$2];
        var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$2],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5];
        var mbp = this.__calSize(marginLeft, w, isDirectItem) + this.__calSize(marginRight, w, isDirectItem) + this.__calSize(paddingLeft, w, isDirectItem) + this.__calSize(paddingRight, w, isDirectItem) + borderLeftWidth + borderRightWidth;

        if (isDirectionRow) {
          res = res.map(function (item) {
            return item + mbp;
          });
        } else {
          var _mbp = this.__calSize(marginTop, w, isDirectItem) + this.__calSize(marginBottom, w, isDirectItem) + this.__calSize(paddingTop, w, isDirectItem) + this.__calSize(paddingBottom, w, isDirectItem) + borderTopWidth + borderBottomWidth;

          res = res.map(function (item) {
            return item + _mbp;
          });
        }

        return res;
      }
    }, {
      key: "__layout",
      value: function __layout(data, isAbs, isColumn, isRow) {
        this.__layoutFlow(data, isAbs, isColumn, isRow);
      } // absolute且无尺寸时，isAbs标明先假布局一次计算尺寸，还有flex列计算时isColumn假布局，flex横计算时writingMode垂直假布局

    }, {
      key: "__layoutFlow",
      value: function __layoutFlow(data, isAbs, isColumn, isRow) {
        this.__computeReflow();

        var __isDestroyed = this.__isDestroyed,
            __currentStyle = this.__currentStyle,
            __computedStyle = this.__computedStyle,
            __ellipsis = this.__ellipsis; // 虚拟省略号每次清除

        if (__ellipsis) {
          this.__ellipsis = null;
        }

        this.__parentLineBox = null;
        this.__isIbFull = this.__isUprightIbFull = false;
        var display = __computedStyle[DISPLAY$6],
            position = __computedStyle[POSITION$3];
        this.__layoutData = {
          x: data.x,
          y: data.y,
          w: data.w,
          h: data.h,
          lx: data.lx,
          ly: data.ly,
          isUpright: data.isUpright,
          // 从Root开始，父级的书写模式需每层传递
          container: data.container
        }; // 防止display:none不统计mask，isVirtual忽略，abs/flex布局后续会真正来走一遍

        if (!isAbs && !isColumn && !isRow) {
          this.clearCache();
          this.__cacheStyle = {};
          this.__refreshLevel = REFLOW$2;
          this.__limitCache = false;
          this.__isInline = false;
          var next = this.next; // mask关系只有布局才会变更，普通渲染关系不会改变，clip也是mask的一种

          if (!this.__isMask && next && next.__isMask) {
            var count = 0;

            while (next) {
              if (next.__isMask) {
                count++;
              } else {
                break;
              }

              next = next.next;
            }

            this.__hasMask = count;
          }
        }

        this.__ox = this.__oy = 0;

        if (__isDestroyed || display === 'none') {
          this.__x = data.x;
          this.__y = data.y;

          this.__layoutNone();

          this.__hasComputeReflow = false;
          return;
        } // absolute特殊，在自己布局时已计算相对于容器的mbp


        if (position !== 'absolute') {
          this.__mp(__currentStyle, __computedStyle, data.w);
        } // 只有inline会继承计算行数，其它都是原样返回


        var lineClampCount = data.lineClampCount || 0; // 4种布局，默认block，inlineBlock基本可以复用inline逻辑，除了尺寸

        if (display === 'flex') {
          data.lineClampCount = 0;

          this.__layoutFlex(data, isAbs, isColumn, isRow);
        } else if (display === 'inlineBlock') {
          data.lineClampCount = 0;

          this.__layoutInline(data, isAbs, isColumn, isRow);
        } else if (display === 'inline') {
          lineClampCount = this.__layoutInline(data, isAbs, isColumn, isRow, true);
        } else {
          data.lineClampCount = 0;

          this.__layoutBlock(data, isAbs, isColumn, isRow);
        } // 非虚拟布局才执行，防止重复


        if (!isAbs && !isColumn && !isRow) {
          // relative渲染时做偏移，百分比基于父元素，若父元素没有定高则为0
          if (position === 'relative') {
            var top = __currentStyle[TOP$3],
                right = __currentStyle[RIGHT$2],
                bottom = __currentStyle[BOTTOM$3],
                left = __currentStyle[LEFT$2];
            var parent = this.parent;

            if (top.u !== AUTO$4) {
              var n = calRelative(__currentStyle, TOP$3, top, parent);

              this.__offsetY(n, false, null);

              __computedStyle[TOP$3] = n;
              __computedStyle[BOTTOM$3] = 'auto';
            } else if (bottom.u !== AUTO$4) {
              var _n = calRelative(__currentStyle, BOTTOM$3, bottom, parent);

              this.__offsetY(-_n, false, null);

              __computedStyle[BOTTOM$3] = _n;
              __computedStyle[TOP$3] = 'auto';
            } else {
              __computedStyle[TOP$3] = __computedStyle[BOTTOM$3] = 'auto';
            }

            if (left.u !== AUTO$4) {
              var _n2 = calRelative(__currentStyle, LEFT$2, left, parent, true);

              this.__offsetX(_n2, false, null);

              __computedStyle[LEFT$2] = _n2;
              __computedStyle[RIGHT$2] = 'auto';
            } else if (right.u !== AUTO$4) {
              var _n3 = calRelative(__currentStyle, RIGHT$2, right, parent, true);

              this.__offsetX(-_n3, false, null);

              __computedStyle[RIGHT$2] = _n3;
              __computedStyle[LEFT$2] = 'auto';
            } else {
              __computedStyle[LEFT$2] = __computedStyle[RIGHT$2] = 'auto';
            }
          } else if (position !== 'absolute') {
            __computedStyle[TOP$3] = __computedStyle[BOTTOM$3] = __computedStyle[LEFT$2] = __computedStyle[RIGHT$2] = 'auto';
          } // 计算结果存入computedStyle和6个坐标，inline在其inlineSize特殊处理


          var x = this.__sx = this.__x + this.__ox;
          var y = this.__sy = this.__y + this.__oy;

          if (!this.__isInline) {
            x = this.__sx1 = x + __computedStyle[MARGIN_LEFT$5];
            x = this.__sx2 = x + __computedStyle[BORDER_LEFT_WIDTH$5];
            x = this.__sx3 = x + __computedStyle[PADDING_LEFT$5];
            x = this.__sx4 = x + this.__width;
            x = this.__sx5 = x + __computedStyle[PADDING_RIGHT$4];
            this.__sx6 = x + __computedStyle[BORDER_RIGHT_WIDTH$4];
            y = this.__sy1 = y + __computedStyle[MARGIN_TOP$3];
            y = this.__sy2 = y + __computedStyle[BORDER_TOP_WIDTH$3];
            y = this.__sy3 = y + __computedStyle[PADDING_TOP$3];
            y = this.__sy4 = y + this.__height;
            y = this.__sy5 = y + __computedStyle[PADDING_BOTTOM$2];
            this.__sy6 = y + __computedStyle[BORDER_BOTTOM_WIDTH$2];
          }

          __computedStyle[WIDTH$5] = this.__width;
          __computedStyle[HEIGHT$5] = this.__height; // abs为parse的根节点时特殊自己执行，前提是真布局

          if (position !== 'absolute') {
            this.__execAr();
          }

          this.__hasComputeReflow = false;
        }

        return lineClampCount;
      }
    }, {
      key: "__layoutStyle",
      value: function __layoutStyle() {
        var currentStyle = this.__currentStyle;
        var computedStyle = this.__computedStyle;
        var cacheStyle = this.__cacheStyle;

        this.__calStyle(o$1.REFLOW, currentStyle, computedStyle, cacheStyle);

        this.__calPerspective(currentStyle, computedStyle, cacheStyle);
      }
    }, {
      key: "__execAr",
      value: function __execAr() {
        // 动态json引用时动画暂存，第一次布局时处理这些动画到root的animateController上
        var ar = this.__animateRecords;

        if (ar) {
          this.__animateRecords = null; // parse没有dom时，animate的target引用都是json，vd后生成需重新赋值

          ar.list.forEach(function (item) {
            if (item.target.vd instanceof Xom) {
              item.target = item.target.vd;
            }
          });
          var ac = ar.controller || this.root.animateController; // 不自动播放进入记录列表，初始化并等待手动调用

          if (ar.options && ar.options.autoPlay === false) {
            ac.__records2 = ac.__records2.concat(ar.list);
            ac.init(ac.__records2, ac.list2);
          } else {
            ac.__records = ac.__records.concat(ar.list);

            ac.__playAuto();
          }
        }
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        this.__computeReflow();

        var __computedStyle = this.__computedStyle;
        __computedStyle[DISPLAY$6] = 'none';

        this.__reset0();

        this.__hasComputeReflow = false;
      }
    }, {
      key: "__reset0",
      value: function __reset0() {
        var __computedStyle = this.__computedStyle;
        __computedStyle[MARGIN_TOP$3] = __computedStyle[MARGIN_RIGHT$4] = __computedStyle[MARGIN_BOTTOM$3] = __computedStyle[MARGIN_LEFT$5] = __computedStyle[BORDER_TOP_WIDTH$3] = __computedStyle[BORDER_RIGHT_WIDTH$4] = __computedStyle[BORDER_BOTTOM_WIDTH$2] = __computedStyle[BORDER_LEFT_WIDTH$5] = __computedStyle[PADDING_TOP$3] = __computedStyle[PADDING_RIGHT$4] = __computedStyle[PADDING_BOTTOM$2] = __computedStyle[PADDING_LEFT$5] = __computedStyle[WIDTH$5] = __computedStyle[HEIGHT$5] = this.__width = this.__height = this.__clientWidth = this.__clientHeight = this.__offsetWidth = this.__offsetHeight = this.__outerWidth = this.__outerHeight = 0;
      } // 预先计算是否是固定宽高，布局点位和尺寸考虑margin/border/padding

    }, {
      key: "__preLayout",
      value: function __preLayout(data, isInline) {
        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h,
            w2 = data.w2,
            h2 = data.h2,
            w3 = data.w3,
            h3 = data.h3,
            lx = data.lx,
            ly = data.ly,
            lineBoxManager = data.lineBoxManager,
            _data$endSpace = data.endSpace,
            endSpace = _data$endSpace === void 0 ? 0 : _data$endSpace,
            isParentVertical = data.isUpright,
            container = data.container;
        this.__x = x;
        this.__y = y;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var width = currentStyle[WIDTH$5],
            height = currentStyle[HEIGHT$5];
        var position = computedStyle[POSITION$3];
        var borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$2],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
            marginTop = computedStyle[MARGIN_TOP$3],
            marginRight = computedStyle[MARGIN_RIGHT$4],
            marginBottom = computedStyle[MARGIN_BOTTOM$3],
            marginLeft = computedStyle[MARGIN_LEFT$5],
            paddingTop = computedStyle[PADDING_TOP$3],
            paddingRight = computedStyle[PADDING_RIGHT$4],
            paddingBottom = computedStyle[PADDING_BOTTOM$2],
            paddingLeft = computedStyle[PADDING_LEFT$5],
            writingMode = computedStyle[WRITING_MODE$2];
        var isUpright = writingMode.indexOf('vertical') === 0; // 除了auto外都是固定宽高度

        var fixedWidth;
        var fixedHeight; // 绝对定位是left+right这种其实等于定义了width，但不能修改原始style，存入特殊变量标识

        if (w2 !== undefined) {
          fixedWidth = true;
          w = w2;
        } // flex时也会用到，子级得出目标主尺寸后按这个来
        else if (w3 !== undefined) {
          fixedWidth = true;
          w = w3;
        } else if (width.u !== AUTO$4 && !isInline) {
          fixedWidth = true; // abs的百分比尺寸相对于container

          if (position === 'absolute' && width.u === PERCENT$4) {
            w = this.__calSize(width, container.__clientWidth, true);
          } else {
            w = this.__calSize(width, w, true);
          }
        }

        if (h2 !== undefined) {
          fixedHeight = true;
          h = h2;
        } else if (h3 !== undefined) {
          fixedHeight = true;
          h = h3;
        } // height的百分比需要parent有值不能auto，或者parent的flex定高且侧轴stretch时；abs的百分比相对于container
        else if (height.u !== AUTO$4 && !isInline) {
          if (position === 'absolute' && height.u === PERCENT$4) {
            h = this.__calSize(height, container.__clientHeight, true);
          } else {
            var p = this.__domParent;

            if (height.u === PERCENT$4) {
              // 一般都是0，除了定高，或者flex的stretch
              if (p.height) {
                fixedHeight = true;
                h = this.__calSize(height, p.height || 0, true);
              }
            } else {
              fixedHeight = true;
              h = this.__calSize(height, h, true);
            }
          }
        } // margin/border/padding影响x和y和尺寸，注意inline的y不受mpb影响（垂直模式则是x）


        if (!isInline) {
          x += borderLeftWidth + marginLeft + paddingLeft;
          y += borderTopWidth + marginTop + paddingTop;
        } else {
          if (isUpright) {
            y += borderTopWidth + marginTop + paddingTop;
          } else {
            x += borderLeftWidth + marginLeft + paddingLeft;
          }
        }

        data.x = x;
        data.y = y; // inline的w/h很特殊，需不考虑inline自身水平的mpb以便换行，因为mpb只在首尾行生效，所以首尾需特殊处理中间忽略
        // 当嵌套inline时更加复杂，假如inline有尾部mpb，最后一行需考虑，如果此inline是父的最后一个且父有mpb需叠加

        var selfEndSpace = 0;

        if (isInline) {
          if (isUpright) {
            selfEndSpace = paddingBottom + borderBottomWidth + marginBottom;
          } else {
            selfEndSpace = paddingRight + borderRightWidth + marginRight;
          }
        } // 传入w3/h3时，flex的item已知目标主尺寸，需减去mbp，其一定是block，和inline互斥


        if (!isInline) {
          if (width.u === AUTO$4 || w3 !== undefined) {
            w -= borderLeftWidth + borderRightWidth + marginLeft + marginRight + paddingLeft + paddingRight;
          }

          if (height.u === AUTO$4 || h3 !== undefined) {
            h -= borderTopWidth + borderBottomWidth + marginTop + marginBottom + paddingTop + paddingBottom;
          }
        }

        return {
          fixedWidth: fixedWidth,
          fixedHeight: fixedHeight,
          x: x,
          y: y,
          w: w,
          h: h,
          lx: lx,
          ly: ly,
          lineBoxManager: lineBoxManager,
          endSpace: endSpace,
          selfEndSpace: selfEndSpace,
          isParentVertical: isParentVertical,
          isUpright: isUpright
        };
      } // 处理margin:xx auto居中对齐或右对齐

    }, {
      key: "__marginAuto",
      value: function __marginAuto(style, data, isUpright) {
        var position = style[POSITION$3],
            display = style[DISPLAY$6],
            marginTop = style[MARGIN_TOP$3],
            marginBottom = style[MARGIN_BOTTOM$3],
            marginLeft = style[MARGIN_LEFT$5],
            marginRight = style[MARGIN_RIGHT$4],
            width = style[WIDTH$5],
            height = style[HEIGHT$5];

        if (position !== 'absolute' && (display === 'block' || display === 'flex')) {
          if (isUpright) {
            if ((height.u !== AUTO$4 || this.isReplaced) && marginTop.u === AUTO$4 && marginBottom.u === AUTO$4) {
              var oh = this.outerHeight;

              if (oh < data.h) {
                this.__offsetY((data.h - oh) * 0.5, false, null);
              }
            }
          } else {
            if ((width.u !== AUTO$4 || this.isReplaced) && marginLeft.u === AUTO$4 && marginRight.u === AUTO$4) {
              var ow = this.outerWidth;

              if (ow < data.w) {
                this.__offsetX((data.w - ow) * 0.5, false, null);
              }
            }
          }
        }
      }
    }, {
      key: "__calMatrix",
      value: function __calMatrix(lv, __currentStyle, __computedStyle, __cacheStyle) {
        var _this4 = this;

        var __sx1 = this.__sx1,
            __sy1 = this.__sy1,
            __offsetWidth = this.__offsetWidth,
            __offsetHeight = this.__offsetHeight;

        if (this.__isInline) {
          __computedStyle[TRANSFORM_ORIGIN$2] = [__sx1, __sy1];
          return __cacheStyle[MATRIX$1] = this.__matrix = mx.identity();
        }

        var matrixCache = __cacheStyle[MATRIX$1]; // tx/ty/tz变化特殊优化

        if (matrixCache && lv < REFLOW$2 && !contain$3(lv, TF$1)) {
          var x = 0,
              y = 0,
              z = 0;
          var transform$1 = __computedStyle[TRANSFORM$3];

          if (contain$3(lv, TX)) {
            var v = __currentStyle[TRANSLATE_X];

            if (!v) {
              v = 0;
            } else if (v.u === PX$5) {
              v = v.v;
            } else {
              v = this.__calSize(v, this.__offsetWidth, true);
            }

            x = v - __computedStyle[TRANSLATE_X];
            __computedStyle[TRANSLATE_X] = v;
            transform$1[12] += x;
            matrixCache[12] += x;
          }

          if (contain$3(lv, TY)) {
            var _v = __currentStyle[TRANSLATE_Y];

            if (!_v) {
              _v = 0;
            } else if (_v.u === PX$5) {
              _v = _v.v;
            } else {
              _v = this.__calSize(_v, this.__offsetHeight, true);
            }

            y = _v - __computedStyle[TRANSLATE_Y];
            __computedStyle[TRANSLATE_Y] = _v;
            transform$1[13] += y;
            matrixCache[13] += y;
          }

          if (contain$3(lv, TZ)) {
            var _v2 = __currentStyle[TRANSLATE_Z];

            if (!_v2) {
              _v2 = 0;
            } else if (_v2.u === PX$5) {
              _v2 = _v2.v;
            } else {
              _v2 = this.__calSize(_v2, this.__offsetWidth, true);
            }

            z = _v2 - __computedStyle[TRANSLATE_Z];
            __computedStyle[TRANSLATE_Z] = _v2;
            transform$1[14] += z;
            matrixCache[14] += z;
          }
        } // 先根据cache计算需要重新计算的computedStyle
        else {
          if (__cacheStyle[TRANSFORM_ORIGIN$2] === undefined) {
            __cacheStyle[TRANSFORM_ORIGIN$2] = true;
            matrixCache = null;
            __computedStyle[TRANSFORM_ORIGIN$2] = __currentStyle[TRANSFORM_ORIGIN$2].map(function (item, i) {
              return _this4.__calSize(item, i ? __offsetHeight : __offsetWidth, true);
            });
          }

          if (__cacheStyle[TRANSFORM$3] === undefined || __cacheStyle[TRANSLATE_X] === undefined || __cacheStyle[TRANSLATE_Y] === undefined || __cacheStyle[TRANSLATE_Z] === undefined || __cacheStyle[ROTATE_X] === undefined || __cacheStyle[ROTATE_Y] === undefined || __cacheStyle[ROTATE_Z] === undefined || __cacheStyle[ROTATE_3D] === undefined || __cacheStyle[SCALE_X] === undefined || __cacheStyle[SCALE_Y] === undefined || __cacheStyle[SCALE_Z] === undefined || __cacheStyle[SKEW_X] === undefined || __cacheStyle[SKEW_Y] === undefined) {
            __cacheStyle[TRANSFORM$3] = __cacheStyle[TRANSLATE_X] = __cacheStyle[TRANSLATE_Y] = __cacheStyle[TRANSLATE_Z] = __cacheStyle[ROTATE_X] = __cacheStyle[ROTATE_Y] = __cacheStyle[ROTATE_Z] = __cacheStyle[SCALE_X] = __cacheStyle[SCALE_Y] = __cacheStyle[SCALE_Z] = __cacheStyle[SKEW_X] = __cacheStyle[SKEW_Y] = true;
            matrixCache = null;
            var matrix; // transform相对于自身

            if (__currentStyle[TRANSFORM$3] && __currentStyle[TRANSFORM$3].length) {
              matrix = transform.calMatrix(__currentStyle[TRANSFORM$3], __offsetWidth, __offsetHeight, this.__root);
            } // 没有transform则看是否有扩展的css独立变换属性
            else {
              var temp = [];
              [TRANSLATE_X, TRANSLATE_Y, TRANSLATE_Z, ROTATE_X, ROTATE_Y, ROTATE_Z, ROTATE_3D, SKEW_X, SKEW_Y, SCALE_X, SCALE_Y, SCALE_Z].forEach(function (k) {
                // 删除之前遗留的
                __computedStyle[k] = undefined;
                var v = __currentStyle[k];

                if (isNil$9(v)) {
                  return;
                }

                if (k === ROTATE_3D) {
                  __computedStyle[k] = [v[0], v[1], v[2], v[3].v];

                  if (v[3].v === 0) {
                    return;
                  }

                  temp.push({
                    k: k,
                    v: v
                  });
                  return;
                }

                __computedStyle[k] = v.v;

                if (k === ROTATE_X || k === ROTATE_Y || k === ROTATE_Z) {
                  if (v.v !== 0) {
                    temp.push({
                      k: k,
                      v: v
                    });
                  }

                  return;
                } // scale为1和其它为0避免计算浪费


                var isScale = k === SCALE_X || k === SCALE_Y || k === SCALE_Z;

                if (v.v === 1 && isScale || !isScale && v.v === 0) {
                  return;
                }

                var p = k === TRANSLATE_X || k === TRANSLATE_Z ? __offsetWidth : __offsetHeight;
                __computedStyle[k] = _this4.__calSize(v, p, true);
                temp.push({
                  k: k,
                  v: v
                });
              });

              if (temp.length) {
                matrix = transform.calMatrix(temp, __offsetWidth, __offsetHeight, this.__root);
              }
            }

            __computedStyle[TRANSFORM$3] = matrix || mx.identity();
          }

          if (!matrixCache) {
            var m = __computedStyle[TRANSFORM$3];

            var tfo = __computedStyle[TRANSFORM_ORIGIN$2].slice(0);

            tfo[0] += __sx1 || 0;
            tfo[1] += __sy1 || 0;
            matrixCache = __cacheStyle[MATRIX$1] = transform.calMatrixByOrigin(m, tfo);
          }
        }

        return this.__matrix = matrixCache;
      }
      /**
       * 将currentStyle计算为computedStyle，同时存入cacheStyle可缓存的结果防止无变更重复计算，返回背景渲染范围
       */

    }, {
      key: "__calStyle",
      value: function __calStyle(lv, __currentStyle, __computedStyle, __cacheStyle) {
        var _this5 = this;

        var __sx1 = this.__sx1,
            __sx2 = this.__sx2,
            __sx3 = this.__sx3,
            __sx4 = this.__sx4,
            __sx5 = this.__sx5,
            __sx6 = this.__sx6,
            __sy1 = this.__sy1,
            __sy2 = this.__sy2,
            __sy3 = this.__sy3,
            __sy4 = this.__sy4,
            __sy5 = this.__sy5,
            __sy6 = this.__sy6;
        this.__bbox = null;
        var bx1 = __sx1,
            by1 = __sy1,
            bx2 = __sx6,
            by2 = __sy6;
        var backgroundClip = __computedStyle[BACKGROUND_CLIP] = __currentStyle[BACKGROUND_CLIP]; // 默认border-box

        if (backgroundClip === 'paddingBox') {
          bx1 = __sx2;
          by1 = __sy2;
          bx2 = __sx5;
          by2 = __sy5;
        } else if (backgroundClip === 'contentBox') {
          bx1 = __sx3;
          by1 = __sy3;
          bx2 = __sx4;
          by2 = __sy4;
        }

        var isInline = this.__isInline;

        if (isInline && !this.__contentBoxList.length) {
          isInline = false;
        } // 这些直接赋值的不需要再算缓存


        [OPACITY$3, Z_INDEX$2, BORDER_TOP_STYLE, BORDER_RIGHT_STYLE, BORDER_BOTTOM_STYLE, BORDER_LEFT_STYLE, BACKGROUND_REPEAT, OVERFLOW$2, MIX_BLEND_MODE$3, TEXT_OVERFLOW, BACKGROUND_CLIP].forEach(function (k) {
          __computedStyle[k] = __currentStyle[k];
        });

        if (isNil$9(__cacheStyle[FILTER$2])) {
          this.__calFilter(__currentStyle, __computedStyle, __cacheStyle);
        } // 特殊的判断，MATRIX不存在于样式key中，所有的transform共用一个


        if (isNil$9(__cacheStyle[MATRIX$1]) || contain$3(lv, TRANSFORM_ALL$3)) {
          this.__calMatrix(lv, __currentStyle, __computedStyle, __cacheStyle);
        }

        if (isNil$9(__cacheStyle[BACKGROUND_POSITION_X])) {
          __cacheStyle[BACKGROUND_POSITION_X] = true;
          var bgX = __currentStyle[BACKGROUND_POSITION_X];
          __computedStyle[BACKGROUND_POSITION_X] = (bgX || []).map(function (item) {
            if (item.u === PERCENT$4) {
              return item.v + '%';
            }

            return _this5.__calSize(item, bx2 - bx1, true);
          });
        }

        if (isNil$9(__cacheStyle[BACKGROUND_POSITION_Y])) {
          __cacheStyle[BACKGROUND_POSITION_Y] = true;
          var bgY = __currentStyle[BACKGROUND_POSITION_Y];
          __computedStyle[BACKGROUND_POSITION_Y] = (bgY || []).map(function (item) {
            if (item.u === PERCENT$4) {
              return item.v + '%';
            }

            return _this5.__calSize(item, by2 - by1, true);
          });
        }

        if (isNil$9(__cacheStyle[BACKGROUND_SIZE])) {
          __cacheStyle[BACKGROUND_SIZE] = true;
          __computedStyle[BACKGROUND_SIZE] = (__currentStyle[BACKGROUND_SIZE] || []).map(function (item) {
            if (Array.isArray(item)) {
              // 每项是x/y2个
              return item.map(function (item2, i) {
                if (item2.u === AUTO$4) {
                  return -1;
                } else if (item2.u === STRING) {
                  return item2.v === 'contain' ? -2 : -3;
                }

                return _this5.__calSize(item2, i ? by2 - by1 : bx2 - bx1, true);
              });
            }
          });
        }

        if (isNil$9(__cacheStyle[BACKGROUND_IMAGE])) {
          var bgI = __currentStyle[BACKGROUND_IMAGE];
          __computedStyle[BACKGROUND_IMAGE] = bgI.map(function (item) {
            if (item) {
              return item.v;
            }

            return null;
          });
          __cacheStyle[BACKGROUND_IMAGE] = bgI.map(function (bgi, i) {
            if (!bgi) {
              return null;
            } // 防止隐藏不加载背景图


            if (bgi.u === STRING) {
              var loadBgi = _this5.__loadBgi[i] = _this5.__loadBgi[i] || {};
              var cache = inject.IMG[bgi.v];

              if (cache && cache.state === inject.LOADED) {
                loadBgi.url = bgi.v;
                loadBgi.source = cache.source;
                loadBgi.width = cache.width;
                loadBgi.height = cache.height;
              } else if (loadBgi.url !== bgi.v) {
                // 可能改变导致多次加载，每次清空，成功后还要比对url是否相同
                loadBgi.url = bgi.v;
                loadBgi.source = null;
                var node = _this5;
                var root = _this5.__root;
                var ctx = _this5.ctx;
                inject.measureImg(bgi.v, function (data) {
                  // 还需判断url，防止重复加载时老的替换新的，失败不绘制bgi
                  if (data.success && data.url === loadBgi.url && !_this5.isDestroyed) {
                    loadBgi.source = data.source;
                    loadBgi.width = data.width;
                    loadBgi.height = data.height;
                    __cacheStyle[BACKGROUND_IMAGE] = undefined;

                    root.__addUpdate(node, {
                      focus: REPAINT$3
                    });
                  }
                }, {
                  ctx: ctx,
                  root: root,
                  width: bx2 - bx1,
                  height: by2 - by1
                });
              }

              return true;
            } else if (!isInline && bgi.v && bgi.u === GRADIENT$1) {
              // gradient在渲染时才生成
              return true;
            }
          });
        }

        if (isNil$9(__cacheStyle[BOX_SHADOW])) {
          __cacheStyle[BOX_SHADOW] = true;
          __computedStyle[BOX_SHADOW] = (__currentStyle[BOX_SHADOW] || []).map(function (item) {
            return item.map(function (item2, i) {
              if (i > 3) {
                return item2;
              }

              return _this5.__calSize(item2, i === 0 ? bx2 - bx1 : by2 - by1, true);
            });
          });
        }

        [BACKGROUND_COLOR, BORDER_TOP_COLOR, BORDER_RIGHT_COLOR, BORDER_BOTTOM_COLOR, BORDER_LEFT_COLOR].forEach(function (k) {
          if (isNil$9(__cacheStyle[k])) {
            __cacheStyle[k] = int2rgba$1(__computedStyle[k] = __currentStyle[k].v);
          }
        }); // 圆角边计算

        if (isNil$9(__cacheStyle[BORDER_TOP_LEFT_RADIUS$1]) || isNil$9(__cacheStyle[BORDER_TOP_RIGHT_RADIUS$1]) || isNil$9(__cacheStyle[BORDER_BOTTOM_RIGHT_RADIUS$1]) || isNil$9(__cacheStyle[BORDER_BOTTOM_LEFT_RADIUS$1])) {
          __cacheStyle[BORDER_TOP_LEFT_RADIUS$1] = __cacheStyle[BORDER_TOP_RIGHT_RADIUS$1] = __cacheStyle[BORDER_BOTTOM_RIGHT_RADIUS$1] = __cacheStyle[BORDER_BOTTOM_LEFT_RADIUS$1] = true; // 非替代的inline计算看contentBox首尾

          if (isInline) {
            border.calBorderRadiusInline(this.__contentBoxList, __currentStyle, __computedStyle, this.__root);
          } // 普通block整体计算
          else {
            border.calBorderRadius(this.__offsetWidth, this.__offsetHeight, __currentStyle, __computedStyle, this.__root);
          }
        } // width/style/radius影响border，color不影响渲染缓存


        var btlr = __computedStyle[BORDER_TOP_LEFT_RADIUS$1];
        var btrr = __computedStyle[BORDER_TOP_RIGHT_RADIUS$1];
        var bbrr = __computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1];
        var bblr = __computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1];
        var borderTopWidth = __computedStyle[BORDER_TOP_WIDTH$3];
        var borderRightWidth = __computedStyle[BORDER_RIGHT_WIDTH$4];
        var borderBottomWidth = __computedStyle[BORDER_BOTTOM_WIDTH$2];
        var borderLeftWidth = __computedStyle[BORDER_LEFT_WIDTH$5];
        ['Top', 'Right', 'Bottom', 'Left'].forEach(function (k) {
          k = 'border' + k;
          var k2 = STYLE_KEY[style2Upper(k)];
          var kw = STYLE_KEY[style2Upper(k + 'Width')];
          var ks = STYLE_KEY[style2Upper(k + 'Style')]; // width/style变更影响border重新计算

          if (isNil$9(__cacheStyle[kw])) {
            __cacheStyle[kw] = true;
            __cacheStyle[k2] = undefined;
          }

          if (isNil$9(__cacheStyle[ks])) {
            __cacheStyle[ks] = true;
            __cacheStyle[k2] = undefined;
          }

          if (isNil$9(__cacheStyle[k2])) {
            if (k2 === BORDER_TOP) {
              if (borderTopWidth > 0) {
                if (!isInline) {
                  var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                  var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                  __cacheStyle[k2] = border.calPoints(borderTopWidth, __computedStyle[ks], deg1, deg2, __sx1, __sx2, __sx5, __sx6, __sy1, __sy2, __sy5, __sy6, 0, btlr, btrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_RIGHT) {
              if (borderRightWidth > 0) {
                if (!isInline) {
                  var _deg = Math.atan(borderRightWidth / borderTopWidth);

                  var _deg2 = Math.atan(borderRightWidth / borderBottomWidth);

                  __cacheStyle[k2] = border.calPoints(borderRightWidth, __computedStyle[ks], _deg, _deg2, __sx1, __sx2, __sx5, __sx6, __sy1, __sy2, __sy5, __sy6, 1, btrr, bbrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_BOTTOM) {
              if (borderBottomWidth > 0) {
                if (!isInline) {
                  var _deg3 = Math.atan(borderBottomWidth / borderLeftWidth);

                  var _deg4 = Math.atan(borderBottomWidth / borderRightWidth);

                  __cacheStyle[k2] = border.calPoints(borderBottomWidth, __computedStyle[ks], _deg3, _deg4, __sx1, __sx2, __sx5, __sx6, __sy1, __sy2, __sy5, __sy6, 2, bblr, bbrr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            } else if (k2 === BORDER_LEFT) {
              if (borderLeftWidth > 0) {
                if (!isInline) {
                  var _deg5 = Math.atan(borderLeftWidth / borderTopWidth);

                  var _deg6 = Math.atan(borderLeftWidth / borderBottomWidth);

                  __cacheStyle[k2] = border.calPoints(borderLeftWidth, __computedStyle[ks], _deg5, _deg6, __sx1, __sx2, __sx5, __sx6, __sy1, __sy2, __sy5, __sy6, 3, btlr, bblr);
                }
              } else {
                __cacheStyle[k2] = [];
              }
            }
          }
        }); // 强制计算继承性的

        var parent = this.__domParent;
        var parentComputedStyle = parent && parent.__computedStyle;

        if (__currentStyle[FONT_STYLE].u === INHERIT$1) {
          __computedStyle[FONT_STYLE] = parent ? parentComputedStyle[FONT_STYLE] : 'normal';
        } else if (isNil$9(__cacheStyle[FONT_STYLE])) {
          __computedStyle[FONT_STYLE] = __currentStyle[FONT_STYLE].v;
        }

        __cacheStyle[FONT_STYLE] = __computedStyle[FONT_STYLE];
        var color = __currentStyle[COLOR$1];

        if (color.u === INHERIT$1) {
          var v = __computedStyle[COLOR$1] = parent ? parentComputedStyle[COLOR$1] : rgba2int(reset.INHERIT.color);

          if (v.k) {
            __cacheStyle[COLOR$1] = v;
          } else {
            __cacheStyle[COLOR$1] = int2rgba$1(__computedStyle[COLOR$1]);
          }
        } else if (isNil$9(__cacheStyle[COLOR$1])) {
          if (color.u === GRADIENT$1) {
            __cacheStyle[COLOR$1] = __computedStyle[COLOR$1] = color.v;
          } else {
            __cacheStyle[COLOR$1] = int2rgba$1(__computedStyle[COLOR$1] = rgba2int(color.v));
          }
        }

        var textStrokeColor = __currentStyle[TEXT_STROKE_COLOR$1];

        if (textStrokeColor.u === INHERIT$1) {
          var _v3 = __computedStyle[TEXT_STROKE_COLOR$1] = parent ? parentComputedStyle[TEXT_STROKE_COLOR$1] : rgba2int(reset.INHERIT.textStrokeColor);

          if (_v3.k) {
            __cacheStyle[TEXT_STROKE_COLOR$1] = _v3;
          } else {
            __cacheStyle[TEXT_STROKE_COLOR$1] = int2rgba$1(__computedStyle[TEXT_STROKE_COLOR$1]);
          }
        } else if (isNil$9(__cacheStyle[TEXT_STROKE_COLOR$1])) {
          if (textStrokeColor.u === GRADIENT$1) {
            __cacheStyle[TEXT_STROKE_COLOR$1] = __computedStyle[TEXT_STROKE_COLOR$1] = textStrokeColor.v;
          } else if (textStrokeColor.u === RGBA$1) {
            __cacheStyle[TEXT_STROKE_COLOR$1] = int2rgba$1(__computedStyle[TEXT_STROKE_COLOR$1] = rgba2int(textStrokeColor.v));
          }
        }

        if (__currentStyle[TEXT_STROKE_WIDTH$1].u === INHERIT$1) {
          __computedStyle[TEXT_STROKE_WIDTH$1] = parent ? parentComputedStyle[TEXT_STROKE_WIDTH$1] : reset.INHERIT.textStrokeWidth;
          __cacheStyle[TEXT_STROKE_WIDTH$1] = true;
        } else if (isNil$9(__cacheStyle[TEXT_STROKE_WIDTH$1])) {
          var _v4 = __currentStyle[TEXT_STROKE_WIDTH$1];

          if (_v4.u === REM$4) {
            _v4 = _v4.v * this.__root.__computedStyle[FONT_SIZE$2];
          } else if (_v4.u === VW$4) {
            _v4 = _v4.v * this.__root.width * 0.01;
          } else if (_v4.u === VH$4) {
            _v4 = _v4.v * this.__root.height * 0.01;
          } else if (_v4.u === VMAX$4) {
            _v4 = _v4.v * Math.max(this.__root.width, this.__root.height) * 0.01;
          } else if (_v4.u === VMIN$4) {
            _v4 = _v4.v * Math.min(this.__root.width, this.__root.height) * 0.01;
          } else {
            _v4 = _v4.v;
          }

          __computedStyle[TEXT_STROKE_WIDTH$1] = _v4;
          __cacheStyle[TEXT_STROKE_WIDTH$1] = true;
        }

        if (__currentStyle[TEXT_STROKE_OVER$1].u === INHERIT$1) {
          __cacheStyle[TEXT_STROKE_OVER$1] = __computedStyle[TEXT_STROKE_OVER$1] = parent ? parentComputedStyle[TEXT_STROKE_OVER$1] : reset.INHERIT.textStrokeOver;
        } else {
          __cacheStyle[TEXT_STROKE_OVER$1] = __computedStyle[TEXT_STROKE_OVER$1] = __currentStyle[TEXT_STROKE_OVER$1].v;
        }

        if (__currentStyle[VISIBILITY$4].u === INHERIT$1) {
          __computedStyle[VISIBILITY$4] = parent ? parentComputedStyle[VISIBILITY$4] : 'visible';
        } else if (isNil$9(__cacheStyle[VISIBILITY$4])) {
          __computedStyle[VISIBILITY$4] = __currentStyle[VISIBILITY$4].v;
        }

        __cacheStyle[VISIBILITY$4] = __computedStyle[VISIBILITY$4];

        if (__currentStyle[POINTER_EVENTS$1].u === INHERIT$1) {
          __computedStyle[POINTER_EVENTS$1] = parent ? parentComputedStyle[POINTER_EVENTS$1] : 'auto';
        } else if (isNil$9(__cacheStyle[POINTER_EVENTS$1])) {
          __computedStyle[POINTER_EVENTS$1] = __currentStyle[POINTER_EVENTS$1].v;
        }

        __cacheStyle[POINTER_EVENTS$1] = __computedStyle[POINTER_EVENTS$1];
        this.__bx1 = bx1;
        this.__bx2 = bx2;
        this.__by1 = by1;
        this.__by2 = by2;
        return [bx1, by1, bx2, by2];
      }
    }, {
      key: "__calPerspective",
      value: function __calPerspective(__currentStyle, __computedStyle, __cacheStyle) {
        var _this6 = this;

        this.__perspectiveMatrix = [];
        var rebuild;
        var __sx1 = this.__sx1,
            __sy1 = this.__sy1;

        if (isNil$9(__cacheStyle[PERSPECTIVE$1])) {
          __cacheStyle[PERSPECTIVE$1] = true;
          rebuild = true;
          var v = __currentStyle[PERSPECTIVE$1];
          __computedStyle[PERSPECTIVE$1] = this.__calSize(v, this.clientWidth, true);
        }

        if (isNil$9(__cacheStyle[PERSPECTIVE_ORIGIN$1])) {
          __cacheStyle[PERSPECTIVE_ORIGIN$1] = true;
          rebuild = true;
          __computedStyle[PERSPECTIVE_ORIGIN$1] = __currentStyle[PERSPECTIVE_ORIGIN$1].map(function (item, i) {
            return _this6.__calSize(item, i ? _this6.__offsetHeight : _this6.__offsetWidth, true);
          });
        }

        var ppt = __computedStyle[PERSPECTIVE$1]; // perspective为0无效

        if (rebuild && ppt) {
          var po = __computedStyle[PERSPECTIVE_ORIGIN$1].slice(0);

          po[0] += __sx1 || 0;
          po[1] += __sy1 || 0;
          this.__perspectiveMatrix = transform.calPerspectiveMatrix(ppt, po);
        }

        return this.__perspectiveMatrix;
      }
    }, {
      key: "__calFilter",
      value: function __calFilter(__currentStyle, __computedStyle, __cacheStyle) {
        var _this7 = this;

        __cacheStyle[FILTER$2] = true;
        this.__filterBbox = null;
        return __computedStyle[FILTER$2] = (__currentStyle[FILTER$2] || []).map(function (item) {
          var k = item.k,
              v = item.v;

          if (k === 'dropShadow') {
            var v2 = v.map(function (item2, i) {
              if (i > 3) {
                return item2;
              }

              return _this7.__calSize(item2, i === 0 ? _this7.__bx2 - _this7.__bx1 : _this7.__by2 - _this7.__by1, true);
            });
            return {
              k: k,
              v: v2
            };
          } else {
            // 部分%单位的滤镜强制使用数字
            if (v.u === DEG || v.u === NUMBER$1 || v.u === PERCENT$4) {
              v = v.v;
            } else {
              v = _this7.__calSize(v, _this7.root.width, true);
            }

            return {
              k: k,
              v: v
            };
          }
        });
      }
    }, {
      key: "__calOffscreen",
      value: function __calOffscreen(ctx, __computedStyle) {
        var offscreenBlend,
            offscreenMask,
            offscreenFilter,
            offscreenOverflow,
            root = this.__root;
        var width = root.width,
            height = root.height;
        var origin = ctx;
        var mixBlendMode = __computedStyle[MIX_BLEND_MODE$3],
            filter = __computedStyle[FILTER$2],
            overflow = __computedStyle[OVERFLOW$2],
            display = __computedStyle[DISPLAY$6];

        if (mixBlendMode !== 'normal' && isValidMbm$1(mixBlendMode)) {
          mixBlendMode = mbmName$1(mixBlendMode);
          var c = inject.getCacheCanvas(width, height, null, 'blend');
          offscreenBlend = {
            ctx: ctx,
            target: c,
            mixBlendMode: mixBlendMode
          };
          ctx = c.ctx;
        }

        if (this.__hasMask) {
          var _c = inject.getCacheCanvas(width, height, null, 'mask1');

          offscreenMask = {
            ctx: ctx,
            target: _c
          };
          ctx = _c.ctx;
        }

        if (filter && filter.length) {
          var _c2 = inject.getCacheCanvas(width, height, null, 'filter');

          offscreenFilter = {
            ctx: ctx,
            filter: filter,
            target: _c2
          };
          ctx = _c2.ctx;
        }

        if (overflow === 'hidden' && display !== 'inline') {
          var _c3 = inject.getCacheCanvas(width, height, null, 'overflow');

          var bx1 = this.__bx1;
          var bx2 = this.__bx2;
          var by1 = this.__by1;
          var by2 = this.__by2;
          var borderTopLeftRadius = __computedStyle[BORDER_TOP_LEFT_RADIUS$1],
              borderTopRightRadius = __computedStyle[BORDER_TOP_RIGHT_RADIUS$1],
              borderBottomRightRadius = __computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1],
              borderBottomLeftRadius = __computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1],
              backgroundClip = __computedStyle[BACKGROUND_CLIP],
              borderLeftWidth = __computedStyle[BORDER_LEFT_WIDTH$5],
              borderRightWidth = __computedStyle[BORDER_RIGHT_WIDTH$4],
              borderTopWidth = __computedStyle[BORDER_TOP_WIDTH$3],
              borderBottomWidth = __computedStyle[BORDER_BOTTOM_WIDTH$2],
              paddingTop = __computedStyle[PADDING_TOP$3],
              paddingRight = __computedStyle[PADDING_RIGHT$4],
              paddingBottom = __computedStyle[PADDING_BOTTOM$2],
              paddingLeft = __computedStyle[PADDING_LEFT$5];
          var btlr = borderTopLeftRadius.slice(0);
          var btrr = borderTopRightRadius.slice(0);
          var bbrr = borderBottomRightRadius.slice(0);
          var bblr = borderBottomLeftRadius.slice(0);

          if (backgroundClip === 'paddingBox') {
            btlr[0] -= borderLeftWidth;
            btlr[1] -= borderTopWidth;
            btrr[0] -= borderRightWidth;
            btrr[1] -= borderTopWidth;
            bbrr[0] -= borderRightWidth;
            bbrr[1] -= borderBottomWidth;
            bblr[0] -= borderLeftWidth;
            bblr[1] -= borderBottomWidth;
          } else if (backgroundClip === 'contentBox') {
            btlr[0] -= borderLeftWidth + paddingLeft;
            btlr[1] -= borderTopWidth + paddingTop;
            btrr[0] -= borderRightWidth + paddingRight;
            btrr[1] -= borderTopWidth + paddingTop;
            bbrr[0] -= borderRightWidth + paddingRight;
            bbrr[1] -= borderBottomWidth + paddingBottom;
            bblr[0] -= borderLeftWidth + paddingLeft;
            bblr[1] -= borderBottomWidth + paddingBottom;
          }

          var borderList = border.calRadius(bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);
          offscreenOverflow = {
            ctx: ctx,
            target: _c3,
            matrix: this.__matrixEvent,
            x: this.__sx1,
            y: this.__sy1,
            offsetWidth: this.__offsetWidth,
            offsetHeight: this.__offsetHeight,
            borderList: borderList
          };
          ctx = _c3.ctx;
        } // 无离屏不返回


        if (origin === ctx) {
          return;
        }

        return {
          ctx: ctx,
          offscreenBlend: offscreenBlend,
          offscreenMask: offscreenMask,
          offscreenFilter: offscreenFilter,
          offscreenOverflow: offscreenOverflow
        };
      } // 自定义图形可能需要覆盖判断，所以是public方法

    }, {
      key: "calContent",
      value: function calContent(__currentStyle, __computedStyle) {
        var visibility = __currentStyle[VISIBILITY$4];

        if (visibility !== 'hidden') {
          var bgI = __currentStyle[BACKGROUND_IMAGE];

          if (Array.isArray(bgI)) {
            for (var i = 0, len = bgI.length; i < len; i++) {
              if (bgI[i]) {
                return this.__hasContent = true;
              }
            }
          }

          if (__currentStyle[BACKGROUND_COLOR].v[3] > 0) {
            var width = __computedStyle[WIDTH$5],
                height = __computedStyle[HEIGHT$5],
                paddingTop = __computedStyle[PADDING_TOP$3],
                paddingRight = __computedStyle[PADDING_RIGHT$4],
                paddingBottom = __computedStyle[PADDING_BOTTOM$2],
                paddingLeft = __computedStyle[PADDING_LEFT$5];

            if (width && height || paddingTop || paddingRight || paddingBottom || paddingLeft) {
              return this.__hasContent = true;
            }
          }

          for (var list = ['Top', 'Right', 'Bottom', 'Left'], _i = 0, _len = list.length; _i < _len; _i++) {
            var k = list[_i];

            if (__computedStyle[STYLE_KEY[style2Upper('border' + k + 'Width')]] > 0 && __currentStyle[STYLE_KEY[style2Upper('border' + k + 'Color')]].v[3] > 0) {
              return this.__hasContent = true;
            }
          }

          var _bs = __currentStyle[BOX_SHADOW];

          if (Array.isArray(_bs)) {
            for (var _i2 = 0, _len2 = _bs.length; _i2 < _len2; _i2++) {
              var item = _bs[_i2];

              if (item && item[4][3] > 0) {
                return this.__hasContent = true;
              }
            }
          }
        }

        return this.__hasContent = false;
      }
      /**
       * 渲染基础方法，Dom/Geom公用
       * @param renderMode
       * @see node/mode
       * @param ctx canvas/svg/webgl共用
       * @param dx cache时偏移x
       * @param dy cache时偏移y
       * @return Object
       * sx1/sx2/sx3/sx4/sx5/sx6/sy1/sy2/sy3/sy4/sy5/sy6 坐标
       * break svg判断无变化提前跳出
       */

    }, {
      key: "render",
      value: function render(renderMode, ctx) {
        var _this8 = this;

        var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var isDestroyed = this.__isDestroyed;
        var cacheStyle = this.__cacheStyle;
        var computedStyle = this.__computedStyle;

        if (isDestroyed) {
          return {
            isDestroyed: isDestroyed,
            "break": true
          };
        }

        var virtualDom; // svg设置vd上的lv属性标明<REPAINT时应用缓存，初始化肯定没有

        if (renderMode === SVG$1) {
          virtualDom = this.__virtualDom = {
            bb: [],
            children: [],
            visibility: 'visible'
          };
        }

        var display = computedStyle[DISPLAY$6]; // canvas返回信息，svg已经初始化好了vd

        if (display === 'none') {
          return {
            "break": true
          };
        }

        if (renderMode === WEBGL$1) {
          return {};
        } // 使用sx和sy渲染位置，考虑了relative和translate影响


        var __offsetWidth = this.__offsetWidth,
            __offsetHeight = this.__offsetHeight;
        var paddingTop = computedStyle[PADDING_TOP$3],
            paddingRight = computedStyle[PADDING_RIGHT$4],
            paddingBottom = computedStyle[PADDING_BOTTOM$2],
            paddingLeft = computedStyle[PADDING_LEFT$5],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$5],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$4],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH$3],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH$2];
        var isRealInline = this.__isInline; // 考虑mpb的6个坐标，inline比较特殊单独计算

        var sx1 = this.__sx1;
        var sx2 = this.__sx2;
        var sx3 = this.__sx3;
        var sx4 = this.__sx4;
        var sx5 = this.__sx5;
        var sx6 = this.__sx6;
        var sy1 = this.__sy1;
        var sy2 = this.__sy2;
        var sy3 = this.__sy3;
        var sy4 = this.__sy4;
        var sy5 = this.__sy5;
        var sy6 = this.__sy6;
        var bx1 = this.__bx1;
        var bx2 = this.__bx2;
        var by1 = this.__by1;
        var by2 = this.__by2;
        var res = {
          ctx: ctx,
          dx: dx,
          dy: dy,
          sx1: sx1,
          sx2: sx2,
          sx3: sx3,
          sx4: sx4,
          sx5: sx5,
          sx6: sx6,
          sy1: sy1,
          sy2: sy2,
          sy3: sy3,
          sy4: sy4,
          sy5: sy5,
          sy6: sy6,
          bx1: bx1,
          bx2: bx2,
          by1: by1,
          by2: by2
        }; // cache的canvas模式已经提前计算好了，其它需要现在计算

        var matrix = this.__matrix;
        var backgroundColor = computedStyle[BACKGROUND_COLOR],
            borderTopColor = computedStyle[BORDER_TOP_COLOR],
            borderRightColor = computedStyle[BORDER_RIGHT_COLOR],
            borderBottomColor = computedStyle[BORDER_BOTTOM_COLOR],
            borderLeftColor = computedStyle[BORDER_LEFT_COLOR],
            borderTopLeftRadius = computedStyle[BORDER_TOP_LEFT_RADIUS$1],
            borderTopRightRadius = computedStyle[BORDER_TOP_RIGHT_RADIUS$1],
            borderBottomRightRadius = computedStyle[BORDER_BOTTOM_RIGHT_RADIUS$1],
            borderBottomLeftRadius = computedStyle[BORDER_BOTTOM_LEFT_RADIUS$1],
            visibility = computedStyle[VISIBILITY$4],
            backgroundRepeat = computedStyle[BACKGROUND_REPEAT],
            backgroundImage = computedStyle[BACKGROUND_IMAGE],
            opacity = computedStyle[OPACITY$3],
            filter = computedStyle[FILTER$2],
            backgroundSize = computedStyle[BACKGROUND_SIZE],
            boxShadow = computedStyle[BOX_SHADOW],
            overflow = computedStyle[OVERFLOW$2],
            mixBlendMode = computedStyle[MIX_BLEND_MODE$3],
            backgroundClip = computedStyle[BACKGROUND_CLIP],
            writingMode = computedStyle[WRITING_MODE$2];
        var isUpright = writingMode.indexOf('vertical') === 0;

        if (renderMode === SVG$1) {
          if (opacity === 1) {
            delete virtualDom.opacity;
          } else {
            virtualDom.opacity = opacity;
          }
        } // canvas/svg/事件需要3种不同的matrix


        if (renderMode === SVG$1) {
          if (!mx.isE(matrix)) {
            virtualDom.transform = 'matrix(' + joinArr$1(mx.m2m6(matrix), ',') + ')';
          } else {
            delete virtualDom.transform;
          }

          virtualDom.visibility = visibility;
        }

        if (renderMode === SVG$1) {
          if (mixBlendMode !== 'normal' && isValidMbm$1(mixBlendMode)) {
            mixBlendMode = mbmName$1(mixBlendMode);
            virtualDom.mixBlendMode = mixBlendMode;
          } else {
            delete virtualDom.mixBlendMode;
          }

          if (filter && filter.length) {
            virtualDom.filter = painter.svgFilter(filter);
          } else {
            delete virtualDom.filter;
          }
        } // 根据backgroundClip的不同值要调整bg渲染坐标尺寸，也会影响borderRadius


        var btlr = borderTopLeftRadius.slice(0);
        var btrr = borderTopRightRadius.slice(0);
        var bbrr = borderBottomRightRadius.slice(0);
        var bblr = borderBottomLeftRadius.slice(0);

        if (backgroundClip === 'paddingBox') {
          btlr[0] -= borderLeftWidth;
          btlr[1] -= borderTopWidth;
          btrr[0] -= borderRightWidth;
          btrr[1] -= borderTopWidth;
          bbrr[0] -= borderRightWidth;
          bbrr[1] -= borderBottomWidth;
          bblr[0] -= borderLeftWidth;
          bblr[1] -= borderBottomWidth;
        } else if (backgroundClip === 'contentBox') {
          btlr[0] -= borderLeftWidth + paddingLeft;
          btlr[1] -= borderTopWidth + paddingTop;
          btrr[0] -= borderRightWidth + paddingRight;
          btrr[1] -= borderTopWidth + paddingTop;
          bbrr[0] -= borderRightWidth + paddingRight;
          bbrr[1] -= borderBottomWidth + paddingBottom;
          bblr[0] -= borderLeftWidth + paddingLeft;
          bblr[1] -= borderBottomWidth + paddingBottom;
        } // overflow:hidden，最后判断，filter/mask优先


        var borderList;

        if (overflow === 'hidden' && display !== 'inline') {
          borderList = border.calRadius(bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);

          if (renderMode === SVG$1) {
            var d = svgPolygon$2(borderList) || "M".concat(sx1, ",").concat(sy1, "L").concat(sx1 + __offsetWidth, ",").concat(sy1, "L").concat(sx1 + __offsetWidth, ",").concat(sy1 + __offsetHeight, "L").concat(sx1, ",").concat(sy1 + __offsetHeight, ",L").concat(sx1, ",").concat(sy1);
            var v = {
              tagName: 'clipPath',
              props: [],
              children: [{
                tagName: 'path',
                props: [['d', d]]
              }]
            };
            var id = ctx.add(v);

            this.__cacheDefs.push(v);

            virtualDom.overflow = 'url(#' + id + ')';
          }
        } else if (renderMode === SVG$1) {
          delete virtualDom.overflow;
        } // 隐藏不渲染


        if ((visibility === 'hidden' || res["break"]) && (renderMode === CANVAS$1 || renderMode === WEBGL$1)) {
          res["break"] = true;
          return res;
        }
        /**
         * inline的渲染同block/ib不一样，不是一个矩形区域
         * 它根据内部的contentBox渲染，contentBox是指lineBox中的内容，即TextBox/inline/ib元素
         * 首尾可能不满行，比如从一半开始或一半结束，甚至可能没有内容
         * 两行之间可能不满，如果lineBox的高度>lineHeight的话，另外特殊字体如arial拥有lineGap也会产生间隙，背景色不绘制这个间隙
         * x轴根据contentBox的范围坐标，y则固定和font/lineHeight相关
         * 圆角发生在首尾lineBox处，中间不会有，bgi则产生类似bgc作为mask的效果
         * 另外要注意多个时的顺序，必须依次渲染，后面的bb可能会覆盖前面行的
         */


        if (isRealInline) {
          var contentBoxList = this.contentBoxList;
          var length = contentBoxList.length;

          if (contentBoxList[length - 1] instanceof Ellipsis) {
            length--;
          }

          var hasBgi = backgroundImage.some(function (item) {
            return item;
          });

          if (length) {
            var _ret = function () {
              var fontSize = computedStyle[FONT_SIZE$2],
                  fontFamily = computedStyle[FONT_FAMILY$1],
                  lineHeight = computedStyle[LINE_HEIGHT$2];
              var iw = 0,
                  ih = 0;
              var offscreen,
                  svgBgSymbol = []; // bgi视作inline排满一行绘制，然后按分行拆开给每行

              if (hasBgi) {
                iw = inline.getInlineWidth(_this8, contentBoxList, isUpright);
                ih = lineHeight; // 垂直模式互换，计算时始终按照宽度为主轴计算的

                if (isUpright) {
                  var _ref = [ih, iw];
                  iw = _ref[0];
                  ih = _ref[1];
                }

                if (backgroundClip === 'paddingBox' || backgroundClip === 'padding-box') {
                  if (isUpright) {
                    iw += paddingTop + paddingBottom;
                    ih += paddingLeft + paddingRight;
                  } else {
                    iw += paddingLeft + paddingRight;
                    ih += paddingTop + paddingBottom;
                  }
                } else if (backgroundClip !== 'contentBox' && backgroundClip !== 'content-box') {
                  if (isUpright) {
                    iw += paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
                    ih += paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
                  } else {
                    iw += paddingLeft + paddingRight + borderLeftWidth + borderRightWidth;
                    ih += paddingTop + paddingBottom + borderTopWidth + borderBottomWidth;
                  }
                }

                if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
                  offscreen = inject.getCacheCanvas(iw, ih, '__$$INLINE_BGI$$__');
                }

                var _length = backgroundImage.length;
                backgroundImage.slice(0).reverse().forEach(function (bgi, i) {
                  if (!bgi) {
                    return;
                  }

                  i = _length - 1 - i;

                  if (util.isString(bgi)) {
                    var loadBgi = _this8.__loadBgi[i];

                    if (loadBgi.url === bgi) {
                      var uuid = bg.renderImage(_this8, renderMode, offscreen && offscreen.ctx || ctx, loadBgi, 0, 0, iw, ih, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, true, dx, dy);

                      if (renderMode === SVG$1 && uuid) {
                        svgBgSymbol.push(uuid);
                      }
                    }
                  } else if (bgi.k) {
                    var gd = _this8.__gradient(renderMode, ctx, 0, 0, iw, ih, bgi, dx, dy);

                    if (gd) {
                      if (gd.k === 'conic') {
                        gradient.renderConic(_this8, renderMode, offscreen && offscreen.ctx || ctx, gd.v, 0, 0, iw, lineHeight, btlr, btrr, bbrr, bblr, true);
                      } else {
                        var _uuid = bg.renderBgc(_this8, renderMode, offscreen && offscreen.ctx || ctx, gd.v, null, 0, 0, iw, ih, btlr, btrr, bbrr, bblr, 'fill', true);

                        if (renderMode === SVG$1 && _uuid) {
                          svgBgSymbol.push(_uuid);
                        }
                      }
                    }
                  }
                });
              } // 获取当前dom的baseline，再减去lineBox的baseline得出差值，这样渲染范围y就是lineBox的y+差值为起始，lineHeight为高
              // lineGap，一般为0，某些字体如arial有，渲染高度需减去它，最终是lineHeight - leading，上下均分


              var leading = fontSize * ((o$3.info[calFontFamily(fontFamily)] || {}).lgr || 0) * 0.5;
              var baseline = isUpright ? css.getVerticalBaseline(computedStyle) : css.getBaseline(computedStyle); // 注意只有1个的时候特殊情况，圆角只在首尾行出现

              var isFirst = true;
              var lastContentBox = contentBoxList[0],
                  lastLineBox = lastContentBox.parentLineBox; // bgi需统计宽度累计值，将当前行所处理想单行的x范围位置计算出来，并进行bgi贴图绘制，svg还需统计第几行

              var count = 0;

              for (var i = 0; i < length; i++) {
                var contentBox = contentBoxList[i];

                if (contentBox.parentLineBox !== lastLineBox) {
                  (function () {
                    // 上一行
                    var _inline$getInlineBox = inline.getInlineBox(_this8, isUpright, contentBoxList, lastContentBox, contentBoxList[i - 1], lastLineBox, baseline, lineHeight, leading, isFirst, false, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth),
                        _inline$getInlineBox2 = _slicedToArray(_inline$getInlineBox, 8),
                        ix1 = _inline$getInlineBox2[0],
                        iy1 = _inline$getInlineBox2[1],
                        ix2 = _inline$getInlineBox2[2],
                        iy2 = _inline$getInlineBox2[3],
                        bx1 = _inline$getInlineBox2[4],
                        by1 = _inline$getInlineBox2[5],
                        bx2 = _inline$getInlineBox2[6],
                        by2 = _inline$getInlineBox2[7]; // 要算上开头空白inline，可能有多个和递归嵌套


                    if (isFirst) {
                      var n = getFirstEmptyInlineWidth(_this8);
                      ix1 -= n;
                      bx1 -= n;
                    }

                    if (backgroundColor[3] > 0) {
                      bg.renderBgc(_this8, renderMode, ctx, cacheStyle[BACKGROUND_COLOR], null, ix1, iy1, ix2 - ix1, iy2 - iy1, btlr, [0, 0], [0, 0], bblr, 'fill', false, dx, dy);
                    }

                    var w = ix2 - ix1,
                        h = iy2 - iy1; // 世界参考系的宽高，根据writingMode不同取值使用
                    // canvas的bg位图裁剪

                    if ((renderMode === CANVAS$1 || renderMode === WEBGL$1) && offscreen) {
                      if (isUpright) {
                        ctx.drawImage(offscreen.canvas, 0, count, iw, h, ix1 + dx, iy1 + dy, iw, h);
                      } else {
                        ctx.drawImage(offscreen.canvas, count, 0, w, ih, ix1 + dx, iy1 + dy, w, ih);
                      }
                    } //svg则特殊判断
                    else if (renderMode === SVG$1 && svgBgSymbol.length) {
                      svgBgSymbol.forEach(function (symbol) {
                        if (symbol) {
                          var _v5 = {
                            tagName: 'clipPath',
                            props: [],
                            children: [{
                              tagName: 'path',
                              props: [['d', isUpright ? "M".concat(0, ",", count, "L").concat(ih, ",").concat(count, "L").concat(ih, ",").concat(h + count, "L", 0, ",").concat(h + count, ",L", 0, ",").concat(count) : "M".concat(count, ",", 0, "L").concat(w + count, ",", 0, "L").concat(w + count, ",").concat(ih, "L").concat(count, ",").concat(ih, ",L").concat(count, ",", 0)]]
                            }]
                          };
                          var clip = ctx.add(_v5);

                          _this8.__cacheDefs.push(_v5);

                          virtualDom.bb.push({
                            type: 'item',
                            tagName: 'use',
                            props: [['xlink:href', '#' + symbol], ['x', isUpright ? ix1 : ix1 - count], ['y', isUpright ? iy1 - count : iy1], ['clip-path', 'url(#' + clip + ')']]
                          });
                        }
                      });
                    }

                    count += isUpright ? h : w; // 增加主轴方向的一行/列尺寸

                    if (boxShadow) {
                      boxShadow.forEach(function (item) {
                        bs.renderBoxShadow(_this8, renderMode, ctx, item, bx1, by1, bx2, by2, bx2 - bx1, by2 - by1, dx, dy);
                      });
                    }

                    if (borderTopWidth > 0 && borderTopColor[3] > 0) {
                      var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                      var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                      var list = border.calPoints(borderTopWidth, computedStyle[BORDER_TOP_STYLE], deg1, deg2, bx1, bx1 + borderLeftWidth, bx2, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 0, isFirst ? btlr : [0, 0], [0, 0]);
                      border.renderBorder(_this8, renderMode, ctx, list, cacheStyle[BORDER_TOP_COLOR], dx, dy);
                    }

                    if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
                      var _deg7 = Math.atan(borderBottomWidth / borderLeftWidth);

                      var _deg8 = Math.atan(borderBottomWidth / borderRightWidth);

                      var _list = border.calPoints(borderBottomWidth, computedStyle[BORDER_BOTTOM_STYLE], _deg7, _deg8, bx1, bx1 + borderLeftWidth, bx2, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 2, isFirst ? btlr : [0, 0], [0, 0]);

                      border.renderBorder(_this8, renderMode, ctx, _list, cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
                    }

                    if (isFirst && borderLeftWidth > 0 && borderLeftColor[3] > 0) {
                      var _deg9 = Math.atan(borderLeftWidth / borderTopWidth);

                      var _deg10 = Math.atan(borderLeftWidth / borderBottomWidth);

                      var _list2 = border.calPoints(borderLeftWidth, computedStyle[BORDER_LEFT_STYLE], _deg9, _deg10, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 3, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list2, cacheStyle[BORDER_LEFT_COLOR], dx, dy);
                    }

                    isFirst = false;
                    lastContentBox = contentBox;
                    lastLineBox = contentBox.parentLineBox;
                  })();
                } // 最后一个特殊判断


                if (i === length - 1) {
                  (function () {
                    var _inline$getInlineBox3 = inline.getInlineBox(_this8, isUpright, contentBoxList, lastContentBox, contentBoxList[i], lastLineBox, baseline, lineHeight, leading, isFirst, true, backgroundClip, paddingTop, paddingRight, paddingBottom, paddingLeft, borderTopWidth, borderRightWidth, borderBottomWidth, borderLeftWidth),
                        _inline$getInlineBox4 = _slicedToArray(_inline$getInlineBox3, 8),
                        ix1 = _inline$getInlineBox4[0],
                        iy1 = _inline$getInlineBox4[1],
                        ix2 = _inline$getInlineBox4[2],
                        iy2 = _inline$getInlineBox4[3],
                        bx1 = _inline$getInlineBox4[4],
                        by1 = _inline$getInlineBox4[5],
                        bx2 = _inline$getInlineBox4[6],
                        by2 = _inline$getInlineBox4[7]; // 要算上开头空白inline，可能有多个和递归嵌套


                    if (isFirst) {
                      var _n4 = getFirstEmptyInlineWidth(_this8);

                      ix1 -= _n4;
                      bx1 -= _n4;
                    } // 要算上末尾空白inline，可能有多个和递归嵌套


                    var n = getLastEmptyInlineWidth(_this8);
                    ix2 += n;
                    bx2 += n;

                    if (backgroundColor[3] > 0) {
                      bg.renderBgc(_this8, renderMode, ctx, cacheStyle[BACKGROUND_COLOR], null, ix1, iy1, ix2 - ix1, iy2 - iy1, isFirst ? btlr : [0, 0], btrr, bbrr, isFirst ? bblr : [0, 0], 'fill', false, dx, dy);
                    }

                    var w = ix2 - ix1,
                        h = iy2 - iy1; // canvas的bg位图裁剪

                    if ((renderMode === CANVAS$1 || renderMode === WEBGL$1) && offscreen) {
                      if (isUpright) {
                        ctx.drawImage(offscreen.canvas, 0, count, iw, h, ix1 + dx, iy1 + dy, iw, h);
                      } else {
                        ctx.drawImage(offscreen.canvas, count, 0, w, ih, ix1 + dx, iy1 + dy, w, ih);
                      }
                    } //svg则特殊判断
                    else if (renderMode === SVG$1 && svgBgSymbol.length) {
                      svgBgSymbol.forEach(function (symbol) {
                        if (symbol) {
                          var _v6 = {
                            tagName: 'clipPath',
                            props: [],
                            children: [{
                              tagName: 'path',
                              props: [['d', isUpright ? "M".concat(0, ",", count, "L").concat(ih, ",").concat(count, "L").concat(ih, ",").concat(h + count, "L", 0, ",").concat(h + count, ",L", 0, ",").concat(count) : "M".concat(count, ",", 0, "L").concat(w + count, ",", 0, "L").concat(w + count, ",").concat(ih, "L").concat(count, ",").concat(ih, ",L").concat(count, ",", 0)]]
                            }]
                          };
                          var clip = ctx.add(_v6);

                          _this8.__cacheDefs.push(_v6);

                          virtualDom.bb.push({
                            type: 'item',
                            tagName: 'use',
                            props: [['xlink:href', '#' + symbol], ['x', isUpright ? ix1 : ix1 - count], ['y', isUpright ? iy1 - count : iy1], ['clip-path', 'url(#' + clip + ')']]
                          });
                        }
                      });
                    }

                    if (boxShadow) {
                      boxShadow.forEach(function (item) {
                        bs.renderBoxShadow(_this8, renderMode, ctx, item, bx1, by1, bx2, by2, bx2 - bx1, by2 - by1, dx, dy);
                      });
                    }

                    if (borderTopWidth > 0 && borderTopColor[3] > 0) {
                      var deg1 = Math.atan(borderTopWidth / borderLeftWidth);
                      var deg2 = Math.atan(borderTopWidth / borderRightWidth);
                      var list = border.calPoints(borderTopWidth, computedStyle[BORDER_TOP_STYLE], deg1, deg2, bx1, bx1, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 0, isFirst ? btlr : [0, 0], btrr);
                      border.renderBorder(_this8, renderMode, ctx, list, cacheStyle[BORDER_TOP_COLOR], dx, dy);
                    }

                    if (borderRightWidth > 0 && borderRightColor[3] > 0) {
                      var _deg11 = Math.atan(borderRightWidth / borderTopWidth);

                      var _deg12 = Math.atan(borderRightWidth / borderBottomWidth);

                      var _list3 = border.calPoints(borderRightWidth, computedStyle[BORDER_RIGHT_STYLE], _deg11, _deg12, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 1, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list3, cacheStyle[BORDER_RIGHT_COLOR], dx, dy);
                    }

                    if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
                      var _deg13 = Math.atan(borderBottomWidth / borderLeftWidth);

                      var _deg14 = Math.atan(borderBottomWidth / borderRightWidth);

                      var _list4 = border.calPoints(borderBottomWidth, computedStyle[BORDER_BOTTOM_STYLE], _deg13, _deg14, bx1, bx1, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 2, isFirst ? btlr : [0, 0], btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list4, cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
                    }

                    if (isFirst && borderLeftWidth > 0 && borderLeftColor[3] > 0) {
                      var _deg15 = Math.atan(borderLeftWidth / borderTopWidth);

                      var _deg16 = Math.atan(borderLeftWidth / borderBottomWidth);

                      var _list5 = border.calPoints(borderLeftWidth, computedStyle[BORDER_LEFT_STYLE], _deg15, _deg16, bx1, bx1 + borderLeftWidth, bx2 - borderRightWidth, bx2, by1, by1 + borderTopWidth, by2 - borderBottomWidth, by2, 3, btlr, btrr);

                      border.renderBorder(_this8, renderMode, ctx, _list5, cacheStyle[BORDER_LEFT_COLOR], dx, dy);
                    }
                  })();
                }
              }

              if (offscreen) {
                offscreen.ctx.clearRect(0, 0, iw, ih);
              }

              return {
                v: res
              };
            }();

            if (_typeof(_ret) === "object") return _ret.v;
          } // 无内容且无尺寸的无需渲染
          else if (bx1 === bx2 || by1 === by2) {
            return res;
          }
        } // block渲染，bgc垫底


        if (backgroundColor[3] > 0) {
          bg.renderBgc(this, renderMode, ctx, cacheStyle[BACKGROUND_COLOR], borderList, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr, 'fill', false, dx, dy);
        } // 渐变或图片叠加


        if (backgroundImage) {
          var _length2 = backgroundImage.length;
          backgroundImage.slice(0).reverse().forEach(function (bgi, i) {
            if (!bgi) {
              return;
            }

            i = _length2 - 1 - i;

            if (util.isString(bgi)) {
              var loadBgi = _this8.__loadBgi[i];

              if (loadBgi.url === bgi) {
                bg.renderImage(_this8, renderMode, ctx, loadBgi, bx1, by1, bx2, by2, btlr, btrr, bbrr, bblr, computedStyle, i, backgroundSize, backgroundRepeat, false, dx, dy);
              }
            } else if (bgi.k) {
              var gd = _this8.__gradient(renderMode, ctx, bx1, by1, bx2, by2, bgi, dx, dy);

              if (gd) {
                if (gd.k === 'conic') {
                  gradient.renderConic(_this8, renderMode, ctx, gd.v, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr);
                } else {
                  bg.renderBgc(_this8, renderMode, ctx, gd.v, borderList, bx1, by1, bx2 - bx1, by2 - by1, btlr, btrr, bbrr, bblr, 'fill', false, dx, dy);
                }
              }
            }
          });
        } // boxShadow可能会有多个


        if (boxShadow) {
          boxShadow.forEach(function (item) {
            bs.renderBoxShadow(_this8, renderMode, ctx, item, sx1, sy1, sx6, sy6, sx6 - sx1, sy6 - sy1, dx, dy);
          });
        } // 边框需考虑尖角，两条相交边平分45°夹角


        if (borderTopWidth > 0 && borderTopColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, cacheStyle[BORDER_TOP], cacheStyle[BORDER_TOP_COLOR], dx, dy);
        }

        if (borderRightWidth > 0 && borderRightColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, cacheStyle[BORDER_RIGHT], cacheStyle[BORDER_RIGHT_COLOR], dx, dy);
        }

        if (borderBottomWidth > 0 && borderBottomColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, cacheStyle[BORDER_BOTTOM], cacheStyle[BORDER_BOTTOM_COLOR], dx, dy);
        }

        if (borderLeftWidth > 0 && borderLeftColor[3] > 0) {
          border.renderBorder(this, renderMode, ctx, cacheStyle[BORDER_LEFT], cacheStyle[BORDER_LEFT_COLOR], dx, dy);
        }

        return res;
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.__isDestroyed) {
          return;
        }

        _get(_getPrototypeOf(Xom.prototype), "__destroy", this).call(this);

        this.clearAnimate();
        this.clearFrameAnimate();
        this.clearCache();
        var fontRegister = this.__fontRegister;

        for (var i in fontRegister) {
          if (fontRegister.hasOwnProperty(i)) {
            o$3.offRegister(i, this);
          }
        }

        this.__host = this.__hostRoot = this.__root = this.__prev = this.__next = this.__parent = this.__domParent = null;

        this.__reset0();
      } // 先查找到注册了事件的节点，再捕获冒泡判断增加性能

    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, force) {
        var __isDestroyed = this.__isDestroyed,
            computedStyle = this.__computedStyle,
            __isMask = this.__isMask;

        if (__isDestroyed || computedStyle[DISPLAY$6] === 'none' || e.__stopPropagation || __isMask) {
          return;
        }

        var type = e.event.type;
        var listener = this.listener,
            __hasMask = this.__hasMask;
        var cb;

        if (listener.hasOwnProperty(type)) {
          cb = listener[type];
        } // touchmove之类强制的直接由Root通知即可


        if (force) {
          if (computedStyle[POINTER_EVENTS$1] !== 'none' && isFunction$5(cb) && !e.__stopImmediatePropagation) {
            cb.call(this, e);
          }

          return true;
        } // 非force的判断事件坐标是否在节点内


        if (this.willResponseEvent(e)) {
          // 如果有mask，点在mask上才行，点在clip外才行
          if (__hasMask) {
            var next = this.next;
            var isClip = next.__isClip;
            var hasEmitMask;

            while (next && next.__isMask) {
              if (next.willResponseEvent(e, true)) {
                hasEmitMask = true;
                break;
              }

              next = next.next;
            }

            if (!isClip && !hasEmitMask) {
              return;
            }
          }

          if (isFunction$5(cb) && !e.__stopImmediatePropagation) {
            cb.call(this, e);
          }

          return true;
        }
      }
    }, {
      key: "willResponseEvent",
      value: function willResponseEvent(e, ignore) {
        var x = e.x,
            y = e.y;
        var __sx1 = this.__sx1,
            __sy1 = this.__sy1,
            __offsetWidth = this.__offsetWidth,
            __offsetHeight = this.__offsetHeight,
            __matrixEvent = this.__matrixEvent,
            __computedStyle = this.__computedStyle;

        if (__computedStyle[POINTER_EVENTS$1] === 'none') {
          return;
        }

        var inThis = geom$1.pointInQuadrilateral(x, y, __sx1, __sy1, __sx1 + __offsetWidth, __sy1, __sx1 + __offsetWidth, __sy1 + __offsetHeight, __sx1, __sy1 + __offsetHeight, __matrixEvent);

        if (inThis) {
          if (!e.target && !ignore) {
            e.target = this; // 缓存target给move用

            if (e.event.type === 'touchstart') {
              this.root && (this.root.__touchstartTarget = this);
            }
          }

          return true;
        }
      }
    }, {
      key: "__gradient",
      value: function __gradient(renderMode, ctx, bx1, by1, bx2, by2, bgi) {
        var dx = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var dy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
        var iw = bx2 - bx1;
        var ih = by2 - by1; // 无尺寸无需创建渐变

        if (!iw || !ih) {
          return;
        }

        var k = bgi.k,
            v = bgi.v,
            d = bgi.d,
            s = bgi.s,
            z = bgi.z,
            p = bgi.p;
        var cx = bx1 + iw * 0.5;
        var cy = by1 + ih * 0.5;
        var res = {
          k: k
        };

        if (k === 'linear') {
          var gd = gradient.getLinear(v, d, bx1, by1, cx, cy, iw, ih, this.root, dx, dy);
          res.v = this.__getLg(renderMode, ctx, gd);
        } else if (k === 'radial') {
          var _gd = gradient.getRadial(v, s, z, p, bx1, by1, bx2, by2, this.root, dx, dy);

          if (_gd) {
            res.v = this.__getRg(renderMode, ctx, _gd);

            if (_gd.matrix) {
              res.v = [res.v, _gd.matrix, _gd.cx, _gd.cy];
            }
          }
        } else if (k === 'conic') {
          var bbox = this.bbox;
          var m1 = Math.max(Math.abs(bbox[2] - bbox[0]), Math.abs(bbox[3] - bbox[1]));
          var m2 = Math.max(Math.abs(iw), Math.abs(ih));

          var _gd2 = gradient.getConic(v, d, p, bx1, by1, bx2, by2, m1 / m2, this.root, dx, dy);

          res.v = this.__getCg(renderMode, ctx, _gd2);
        }

        return res;
      }
    }, {
      key: "__getLg",
      value: function __getLg(renderMode, ctx, gd) {
        if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
          var lg = ctx.createLinearGradient(gd.x1, gd.y1, gd.x2, gd.y2);
          gd.stop.forEach(function (item) {
            lg.addColorStop(item[1], int2rgba$1(item[0]));
          });
          return lg;
        } else if (renderMode === SVG$1) {
          var v = {
            tagName: 'linearGradient',
            props: [['x1', gd.x1], ['y1', gd.y1], ['x2', gd.x2], ['y2', gd.y2]],
            children: gd.stop.map(function (item) {
              return {
                tagName: 'stop',
                props: [['stop-color', int2rgba$1(item[0])], ['offset', item[1] * 100 + '%']]
              };
            })
          };
          var uuid = ctx.add(v);

          this.__cacheDefs.push(v);

          return 'url(#' + uuid + ')';
        }
      }
    }, {
      key: "__getRg",
      value: function __getRg(renderMode, ctx, gd) {
        if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
          var rg = ctx.createRadialGradient(gd.cx, gd.cy, 0, gd.tx, gd.ty, gd.r);
          gd.stop.forEach(function (item) {
            rg.addColorStop(item[1], int2rgba$1(item[0]));
          });
          return rg;
        } else if (renderMode === SVG$1) {
          var v = {
            tagName: 'radialGradient',
            props: [['cx', gd.tx], ['cy', gd.ty], ['r', gd.r]],
            children: gd.stop.map(function (item) {
              return {
                tagName: 'stop',
                props: [['stop-color', int2rgba$1(item[0])], ['offset', item[1] * 100 + '%']]
              };
            })
          };

          if (gd.tx !== gd.cx) {
            v.props.push(['fx', gd.cx]);
          }

          if (gd.ty !== gd.cy) {
            v.props.push(['fy', gd.cy]);
          }

          var uuid = ctx.add(v);

          this.__cacheDefs.push(v);

          return 'url(#' + uuid + ')';
        }
      }
    }, {
      key: "__getCg",
      value: function __getCg(renderMode, ctx, gd) {
        var stop = gd.stop;
        var len = stop.length - 1;

        if (stop[len][1] < 1) {
          stop.push([stop[len][0].slice(0), 1]);
        }

        if (stop[0][1] > 0) {
          stop.unshift([stop[0][0].slice(0), 0]);
        } // canvas采用点色值计算法，svg则分360度画块


        var res = [];

        if (renderMode === CANVAS$1 || renderMode === WEBGL$1) {
          return gd;
        }

        return res;
      } // canvas清空自身cache，cacheTotal在Root的自底向上逻辑做，svg仅有cacheTotal

    }, {
      key: "clearCache",
      value: function clearCache(lookUp) {
        var __cacheTotal = this.__cacheTotal;
        var __cacheFilter = this.__cacheFilter;
        var __cacheMask = this.__cacheMask;
        var __cacheOverflow = this.__cacheOverflow;
        var __cache = this.__cache;

        if (__cache) {
          __cache.release();
        }

        if (__cacheTotal) {
          __cacheTotal.release();
        }

        if (__cacheFilter) {
          __cacheFilter.release();
        }

        if (__cacheMask) {
          __cacheMask.release();
        }

        if (__cacheOverflow) {
          __cacheOverflow.release();
        }

        this.__refreshLevel |= CACHE$3;

        if (lookUp) {
          var p = this.__domParent;

          while (p) {
            var _cacheTotal = p.__cacheTotal;
            var _cacheFilter = p.__cacheFilter;
            var _cacheMask = p.__cacheMask;
            var _cacheOverflow = p.__cacheOverflow;
            p.__refreshLevel |= CACHE$3;

            if (_cacheTotal) {
              _cacheTotal.release();
            }

            if (_cacheFilter) {
              _cacheFilter.release();
            }

            if (_cacheMask) {
              _cacheMask.release();
            }

            if (_cacheOverflow) {
              _cacheOverflow.release();
            }

            p = p.__domParent;
          }
        }
      }
    }, {
      key: "updateStyle",
      value: function updateStyle(style, cb) {
        var formatStyle = normalize(style);
        this.updateFormatStyle(formatStyle, cb);
      } // 传入格式化好key/value的样式

    }, {
      key: "updateFormatStyle",
      value: function updateFormatStyle(style, cb) {
        var _this9 = this;

        var root = this.__root,
            currentStyle = this.__currentStyle,
            currentProps = this.__currentProps;
        var keys = [];
        Object.keys(style).forEach(function (i) {
          var isGeom = GEOM.hasOwnProperty(i);

          if (!isGeom) {
            i = parseInt(i);
          }

          if (!equalStyle(i, isGeom ? currentProps[i] : currentStyle[i], style[i], _this9)) {
            if (isGeom) {
              currentProps[i] = style[i];
            } else {
              currentStyle[i] = style[i];
            }

            keys.push(i);
          }
        });

        if (!keys.length || this.__isDestroyed) {
          if (isFunction$5(cb)) {
            cb();
          }

          return;
        }

        if (root) {
          root.__addUpdate(this, {
            keys: keys,
            cb: cb
          });
        }
      }
    }, {
      key: "animate",
      value: function animate(list) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var animation = new Animation(this, list, options);

        if (this.__isDestroyed) {
          animation.__destroy();

          return animation;
        }

        this.__animationList.push(animation);

        if (options.autoPlay === false) {
          return animation;
        }

        return animation.play();
      }
    }, {
      key: "removeAnimate",
      value: function removeAnimate(o) {
        if (o instanceof Animation) {
          var i = this.__animationList.indexOf(o);

          if (i > -1) {
            o.cancel();

            o.__destroy();

            this.__animationList.splice(i, 1);
          }
        }
      }
    }, {
      key: "clearAnimate",
      value: function clearAnimate() {
        this.__animationList.splice(0).forEach(function (o) {
          o.cancel();

          o.__destroy();
        });
      }
    }, {
      key: "frameAnimate",
      value: function frameAnimate(cb) {
        if (isFunction$5(cb)) {
          var list = this.__frameAnimateList; // 防止重复

          for (var i = 0, len = list.length; i < len; i++) {
            if (list[i].__karasFramecb === cb) {
              return cb;
            }
          }

          var enter = {
            __after: function __after(diff) {
              cb(diff);
            },
            __karasFramecb: cb
          };
          list.push(enter);
          frame.onFrame(enter);
          return cb;
        }
      }
    }, {
      key: "removeFrameAnimate",
      value: function removeFrameAnimate(cb) {
        for (var i = 0, list = this.__frameAnimateList, len = list.length; i < len; i++) {
          if (list[i].__karasFramecb === cb) {
            list.splice(i, 1);
            frame.offFrame(cb);
            return;
          }
        }
      }
    }, {
      key: "clearFrameAnimate",
      value: function clearFrameAnimate() {
        this.__frameAnimateList.splice(0).forEach(function (o) {
          frame.offFrame(o);
        });
      }
    }, {
      key: "__deepScan",
      value: function __deepScan(cb, options) {
        return cb(this, options);
      } // isLayout为false时，为relative，true则是absolute等直接改layoutData数据的
      // lv是reflow偏移时传入，需要清除cacheStyle
      // 注意所有的offset/resize都要避免display:none的，比如合并margin导致block的孩子inline因clamp为none时没有layoutData

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        if (this.computedStyle[DISPLAY$6] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Xom.prototype), "__offsetX", this).call(this, diff, isLayout);

        if (isLayout) {
          this.__layoutData.x += diff;
          this.clearCache();
        }

        this.__sx1 += diff;
        this.__sx2 += diff;
        this.__sx3 += diff;
        this.__sx4 += diff;
        this.__sx5 += diff;
        this.__sx6 += diff;

        if (lv) {
          this.__refreshLevel |= lv;

          if (lv >= REFLOW$2) {
            this.__cacheStyle = {};

            this.__calStyle(lv, this.__currentStyle, this.__computedStyle, this.__cacheStyle);
          }
        }
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        if (this.computedStyle[DISPLAY$6] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Xom.prototype), "__offsetY", this).call(this, diff, isLayout);

        if (isLayout) {
          this.__layoutData && (this.__layoutData.y += diff);
          this.clearCache();
        }

        this.__sy1 += diff;
        this.__sy2 += diff;
        this.__sy3 += diff;
        this.__sy4 += diff;
        this.__sy5 += diff;
        this.__sy6 += diff;

        if (lv) {
          this.__refreshLevel |= lv;

          if (lv >= REFLOW$2) {
            this.__cacheStyle = {};

            this.__calStyle(lv, this.__currentStyle, this.__computedStyle, this.__cacheStyle);
          }
        }
      }
    }, {
      key: "__resizeX",
      value: function __resizeX(diff, lv) {
        if (this.computedStyle[DISPLAY$6] === 'none') {
          return;
        }

        this.computedStyle.width = this.__width += diff;
        this.__clientWidth += diff;
        this.__offsetWidth += diff;
        this.__outerWidth += diff;
        this.__layoutData && (this.__layoutData.w += diff);
        this.__sx4 += diff;
        this.__sx5 += diff;
        this.__sx6 += diff;

        if (diff < 0) {
          this.__limitCache = false;
        }

        if (lv) {
          this.__refreshLevel |= lv;

          if (lv >= REFLOW$2) {
            this.__cacheStyle = {};

            this.__calStyle(lv, this.__currentStyle, this.__computedStyle, this.__cacheStyle);
          }
        }

        this.clearCache();
      }
    }, {
      key: "__resizeY",
      value: function __resizeY(diff, lv) {
        if (this.__computedStyle[DISPLAY$6] === 'none') {
          return;
        }

        this.__computedStyle.height = this.__height += diff;
        this.__clientHeight += diff;
        this.__offsetHeight += diff;
        this.__outerHeight += diff;
        this.__layoutData.h += diff;
        this.__sy4 += diff;
        this.__sy5 += diff;
        this.__sy6 += diff;

        if (diff < 0) {
          this.__limitCache = false;
        }

        if (lv) {
          this.__refreshLevel |= lv;

          if (lv >= REFLOW$2) {
            this.__cacheStyle = {};

            this.__calStyle(lv, this.__currentStyle, this.__computedStyle, this.__cacheStyle);
          }
        }

        this.clearCache();
      }
    }, {
      key: "getComputedStyle",
      value: function getComputedStyle(key) {
        var computedStyle = this.__computedStyle;
        var res = {};
        var keys = [];

        if (key) {
          var temp;

          if (Array.isArray(key)) {
            temp = key;
          } else {
            temp = [key];
          }

          temp.forEach(function (k) {
            if (abbr$1.hasOwnProperty(k)) {
              abbr$1[k].forEach(function (k) {
                keys.push(STYLE_KEY[style2Upper(k)]);
              });
            } else {
              keys.push(STYLE_KEY[style2Upper(k)]);
            }
          });
        } else {
          keys = Object.keys(computedStyle);
        }

        keys.forEach(function (k) {
          if (GEOM.hasOwnProperty(k)) {
            res[k] = computedStyle[k];
          } else {
            res[STYLE_RV_KEY[k]] = computedStyle[k];
          }
        });
        return res;
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect(includeBbox) {
        var box;

        if (includeBbox) {
          box = this.bbox;
        } else {
          var __sx1 = this.__sx1,
              __sy1 = this.__sy1,
              __offsetWidth = this.__offsetWidth,
              __offsetHeight = this.__offsetHeight;
          box = [__sx1, __sy1, __sx1 + __offsetWidth, __sy1 + __offsetHeight];
        }

        var matrixEvent = this.matrixEvent;
        var p1 = point2d(mx.calPoint([box[0], box[1]], matrixEvent));
        var p2 = point2d(mx.calPoint([box[2], box[1]], matrixEvent));
        var p3 = point2d(mx.calPoint([box[2], box[3]], matrixEvent));
        var p4 = point2d(mx.calPoint([box[0], box[3]], matrixEvent));
        return {
          left: Math.min(p1[0], Math.min(p2[0], Math.min(p3[0], p4[0]))),
          top: Math.min(p1[1], Math.min(p2[1], Math.min(p3[1], p4[1]))),
          right: Math.max(p1[0], Math.max(p2[0], Math.max(p3[0], p4[0]))),
          bottom: Math.max(p1[1], Math.max(p2[1], Math.max(p3[1], p4[1]))),
          points: [p1, p2, p3, p4]
        };
      } // img和geom返回false，在inline布局时判断是否是真的inline

    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return true;
      }
    }, {
      key: "remove",
      value: function remove(cb) {
        var root = this.__root;
        var parent = this.isShadowRoot ? this.hostRoot.__parent : this.__parent;
        var i;

        if (parent) {
          // 移除component的shadowRoot视为移除component
          var target = this.isShadowRoot ? this.hostRoot : this;
          i = parent.__children.indexOf(target);

          parent.__children.splice(i, 1);

          i = parent.__zIndexChildren.indexOf(target);

          parent.__zIndexChildren.splice(i, 1);

          var __prev = this.__prev,
              __next = this.__next;

          if (__prev) {
            __prev.__next = __next;
          }

          if (__next) {
            __next.__prev = __prev;
          }
        }

        if (this.__isDestroyed) {
          if (isFunction$5(cb)) {
            cb();
          }

          return;
        }

        parent.__deleteStruct(this, i); // 不可见仅改变数据结构


        if (this.__computedStyle[DISPLAY$6] === 'none' || parent.__computedStyle[DISPLAY$6] === 'none') {
          this.__destroy();

          if (isFunction$5(cb)) {
            cb();
          }

          return;
        } // 可见在reflow逻辑做结构关系等


        var res = {
          focus: REFLOW$2,
          removeDom: true,
          cb: cb
        };

        root.__addUpdate(this, res);
      }
    }, {
      key: "tagName",
      get: function get() {
        return this.__tagName;
      }
    }, {
      key: "sx",
      get: function get() {
        return this.__sx;
      }
    }, {
      key: "sy",
      get: function get() {
        return this.__sy;
      }
    }, {
      key: "clientWidth",
      get: function get() {
        return this.__clientWidth || 0;
      }
    }, {
      key: "clientHeight",
      get: function get() {
        return this.__clientHeight || 0;
      }
    }, {
      key: "offsetWidth",
      get: function get() {
        return this.__offsetWidth || 0;
      }
    }, {
      key: "offsetHeight",
      get: function get() {
        return this.__offsetHeight || 0;
      }
    }, {
      key: "outerWidth",
      get: function get() {
        return this.__outerWidth || 0;
      }
    }, {
      key: "outerHeight",
      get: function get() {
        return this.__outerHeight || 0;
      } // 相对自身原点，不考虑margin的范围，>=REPAINT渲染或个别有影响的渲染改变（如blur）清空缓存

    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var __sx1 = this.__sx1,
              __sy1 = this.__sy1,
              __offsetWidth = this.__offsetWidth,
              __offsetHeight = this.__offsetHeight,
              boxShadow = this.__computedStyle[BOX_SHADOW];
          this.__bbox = spreadBoxShadow([__sx1, __sy1, __sx1 + __offsetWidth, __sy1 + __offsetHeight], boxShadow);
        }

        return this.__bbox;
      }
    }, {
      key: "filterBbox",
      get: function get() {
        if (!this.__filterBbox) {
          var bbox = this.__bbox || this.bbox;
          var filter = this.__computedStyle[FILTER$2];
          this.__filterBbox = spreadFilter$1(bbox, filter);
        }

        return this.__filterBbox;
      }
    }, {
      key: "listener",
      get: function get() {
        return this.__listener;
      }
    }, {
      key: "opacity",
      get: function get() {
        return this.__opacity;
      }
    }, {
      key: "matrix",
      get: function get() {
        return this.__matrix;
      }
    }, {
      key: "matrixEvent",
      get: function get() {
        var __domParent = this.__domParent,
            matrix = this.__matrix;

        while (__domParent) {
          matrix = mx.multiply(__domParent.__perspectiveMatrix, matrix);
          matrix = mx.multiply(__domParent.__matrix, matrix);
          __domParent = __domParent.__domParent;
        }

        return matrix;
      }
    }, {
      key: "perspectiveMatrix",
      get: function get() {
        return this.__perspectiveMatrix;
      }
    }, {
      key: "style",
      get: function get() {
        return this.__style;
      }
    }, {
      key: "computedStyle",
      get: function get() {
        return this.__computedStyle;
      }
    }, {
      key: "animationList",
      get: function get() {
        return this.__animationList;
      }
    }, {
      key: "currentStyle",
      get: function get() {
        return this.__currentStyle;
      }
    }, {
      key: "cacheStyle",
      get: function get() {
        return this.__cacheStyle;
      }
    }, {
      key: "isShadowRoot",
      get: function get() {
        return !this.parent && this.host && this.host !== this.root;
      }
    }, {
      key: "contentBoxList",
      get: function get() {
        return this.__contentBoxList;
      }
    }, {
      key: "baseline",
      get: function get() {
        return this.offsetHeight;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        return this.offsetHeight;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        return this.offsetWidth;
      }
    }, {
      key: "isMask",
      get: function get() {
        return this.__isMask;
      }
    }, {
      key: "isClip",
      get: function get() {
        return this.__isClip;
      }
    }, {
      key: "cacheAsBitmap",
      get: function get() {
        return this.__cacheAsBitmap;
      },
      set: function set(v) {
        this.__cacheAsBitmap = !!v;
      }
    }, {
      key: "parentLineBox",
      get: function get() {
        return this.__parentLineBox;
      }
    }]);

    return Xom;
  }(Node);

  var _enums$STYLE_KEY$7 = enums.STYLE_KEY,
      DISPLAY$5 = _enums$STYLE_KEY$7.DISPLAY,
      MARGIN_TOP$2 = _enums$STYLE_KEY$7.MARGIN_TOP,
      MARGIN_BOTTOM$2 = _enums$STYLE_KEY$7.MARGIN_BOTTOM,
      MARGIN_LEFT$4 = _enums$STYLE_KEY$7.MARGIN_LEFT,
      MARGIN_RIGHT$3 = _enums$STYLE_KEY$7.MARGIN_RIGHT,
      BORDER_TOP_WIDTH$2 = _enums$STYLE_KEY$7.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH$1 = _enums$STYLE_KEY$7.BORDER_BOTTOM_WIDTH,
      BORDER_LEFT_WIDTH$4 = _enums$STYLE_KEY$7.BORDER_LEFT_WIDTH,
      BORDER_RIGHT_WIDTH$3 = _enums$STYLE_KEY$7.BORDER_RIGHT_WIDTH,
      PADDING_TOP$2 = _enums$STYLE_KEY$7.PADDING_TOP,
      PADDING_BOTTOM$1 = _enums$STYLE_KEY$7.PADDING_BOTTOM,
      PADDING_LEFT$4 = _enums$STYLE_KEY$7.PADDING_LEFT,
      PADDING_RIGHT$3 = _enums$STYLE_KEY$7.PADDING_RIGHT,
      LINE_HEIGHT$1 = _enums$STYLE_KEY$7.LINE_HEIGHT;
  /**
   * css中常见的概念，一行内容，里面可能有若干不同的内容，仅在布局阶段出现，不参与渲染逻辑
   * 本类是个抽象逻辑概念，会包含Text的内容TextBox和inlineBlock等节点，而内容TextBox则属于Text
   * 一个Text可能因为换行产生多个TextBox，从而形成不同行的内容就属于不同的LineBox
   * 本类属于block（包含flex和inlineBlock，下同）节点下，一个dom会有个专门列表，
   * 包含若干个LineBox保存着若干行文本内容TextBox，不直接关联Text，
   * inline则不会有此对象和列表，其复用最近block父层的，这样解决嵌套问题，
   * block在布局时将列表向孩子传递下去，每遇到block会重新生成
   * 每当发生换行时，专门列表中会新生成一个LineBox，让后续内容继续跟随新的LB
   * LB内部要进行垂直对齐，Text内容较简单x字符底部为baseline，inlineBlock等节点按最后一行baseline
   */

  var LineBox = /*#__PURE__*/function () {
    function LineBox(x, y, lineHeight, baseline, isUpright) {
      this.__list = [];
      this.__x = x;
      this.__y = y;
      this.__lineHeight = lineHeight; // 可能出现空的inline，因此一个inline进入布局时先设置当前lineBox的最小lineHeight/baseline

      this.__baseline = baseline;
      this.__isUpright = isUpright;
      this.__bOffset = 0;
    }

    _createClass(LineBox, [{
      key: "add",
      value: function add(item) {
        this.list.push(item);
        item.__parentLineBox = this;
      }
    }, {
      key: "verticalAlign",
      value: function verticalAlign(isUpright) {
        var baseline = isUpright ? this.verticalBaseline : this.baseline;
        var lineHeight = isUpright ? this.verticalLineHeight : this.lineHeight;
        var increase = lineHeight; // 只有1个也需要对齐，因为可能内嵌了空inline使得baseline发生变化

        if (this.list.length) {
          this.list.forEach(function (item) {
            if (item.isEllipsis) {
              return;
            } // 垂直排版计算不太一样，因为原点坐标系不一样


            if (isUpright) {
              var n = item.verticalBaseline;

              if (n !== baseline) {
                var d = baseline - n;

                item.__offsetX(d, true); // 同下方


                increase = Math.max(increase, item.offsetWidth + d);
              }
            } else {
              var _n = item.baseline;

              if (_n !== baseline) {
                var _d = baseline - _n;

                item.__offsetY(_d, true); // text的话对齐下移可能影响整体高度，在同行有img/ib这样的替换元素下，需记录最大偏移导致的高度调整值
                // 比如一个字符和img，字符下调y即字符的baseline和图片底部对齐，导致高度增加lineHeight和baseline的差值


                increase = Math.max(increase, item.offsetHeight + _d);
              }
            }
          }); // 特殊情况，有img这样的替换元素时，要参与这一行和baseline的对齐扩充，常见于css的img底部额外4px问题
          // 先计算总体baseline和本身baseline差值得出偏移，然后加到本身lineHeight上得出尺寸，再和其它扩充取最大值

          var diff = baseline - this.__baseline;
          increase = Math.max(increase, this.__lineHeight + diff);
        }

        return Math.max(0, increase - lineHeight);
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isAlign) {
        this.__x += diff; // vertical-align或水平情况特殊对齐，可能替换元素img和text导致偏移

        if (isAlign) {
          this.list.forEach(function (item) {
            item.__offsetX(diff, true);
          });
        }
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isAlign) {
        this.__y += diff; // vertical-align情况或水平特殊对齐，可能替换元素img和textBox导致偏移

        if (isAlign) {
          this.list.forEach(function (item) {
            item.__offsetY(diff, true);
          });
        }
      }
      /**
       * 防止非行首空inline，每当遇到inline就设置当前lineBox的lineHeight/baseline，这样有最小值兜底
       * @param l
       * @param b
       * @private
       */

    }, {
      key: "__setLB",
      value: function __setLB(l, b) {
        this.__lineHeight = Math.max(l, this.__lineHeight);
        this.__baseline = Math.max(b, this.__baseline);
      }
    }, {
      key: "__resetLb",
      value: function __resetLb(l, b) {
        this.list.forEach(function (item) {
          var dom = item;

          if (item instanceof TextBox) {
            dom = item.parent.parent;
          }

          var computedStyle = dom.computedStyle;

          while (computedStyle[DISPLAY$5] === 'inline') {
            l = Math.max(l, computedStyle[LINE_HEIGHT$1]);
            b = Math.max(b, css.getBaseline(computedStyle));
            dom = dom.domParent;
            computedStyle = dom.computedStyle;
          }
        });
        this.__lineHeight = l;
        this.__baseline = b;
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__list.length;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "endX",
      get: function get() {
        return this.x + this.width;
      }
    }, {
      key: "endY",
      get: function get() {
        return this.y + this.height;
      }
    }, {
      key: "width",
      get: function get() {
        if (this.isUpright) {
          return this.verticalLineHeight;
        }

        var list = this.list;
        var length = list.length;

        if (length) {
          var first = list[0];
          var last = list[length - 1];
          var x1 = first.x;
          var dom = first instanceof TextBox ? first.parent.domParent : first.domParent; // 因为inline可以嵌套inline，所以一直向上查找到非inline为止，每层inline如果是首个则减去左侧mbp

          while (true) {
            var _list = dom.contentBoxList;
            var _dom$computedStyle = dom.computedStyle,
                display = _dom$computedStyle[DISPLAY$5],
                marginLeft = _dom$computedStyle[MARGIN_LEFT$4],
                borderLeftWidth = _dom$computedStyle[BORDER_LEFT_WIDTH$4],
                paddingLeft = _dom$computedStyle[PADDING_LEFT$4];

            if (display !== 'inline') {
              break;
            }

            if (first === _list[0]) {
              x1 -= marginLeft + borderLeftWidth + paddingLeft;
            }

            dom = dom.domParent;
          }

          var x2 = last.x + last.outerWidth;
          dom = last instanceof TextBox ? last.parent.domParent : last.domParent; // 同向上查非inline，每层inline如果是最后一个则加上右侧mbp

          while (true) {
            var _list2 = dom.contentBoxList;
            var _dom$computedStyle2 = dom.computedStyle,
                _display = _dom$computedStyle2[DISPLAY$5],
                marginRight = _dom$computedStyle2[MARGIN_RIGHT$3],
                borderRightWidth = _dom$computedStyle2[BORDER_RIGHT_WIDTH$3],
                paddingRight = _dom$computedStyle2[PADDING_RIGHT$3];

            if (_display !== 'inline') {
              break;
            }

            if (first === _list2[_list2.length - 1]) {
              x2 += marginRight + borderRightWidth + paddingRight;
            }

            dom = dom.domParent;
          }

          return x2 - x1;
        }

        return 0;
      }
    }, {
      key: "height",
      get: function get() {
        if (!this.isUpright) {
          return this.lineHeight;
        }

        var list = this.list;
        var length = list.length;

        if (length) {
          var first = list[0];
          var last = list[length - 1];
          var y1 = first.y;
          var dom = first instanceof TextBox ? first.parent.domParent : first.domParent; // 因为inline可以嵌套inline，所以一直向上查找到非inline为止，每层inline如果是首个则减去左侧mbp

          while (true) {
            var _list3 = dom.contentBoxList;
            var _dom$computedStyle3 = dom.computedStyle,
                display = _dom$computedStyle3[DISPLAY$5],
                marginTop = _dom$computedStyle3[MARGIN_TOP$2],
                borderTopWidth = _dom$computedStyle3[BORDER_TOP_WIDTH$2],
                paddingTop = _dom$computedStyle3[PADDING_TOP$2];

            if (display !== 'inline') {
              break;
            }

            if (first === _list3[0]) {
              y1 -= marginTop + borderTopWidth + paddingTop;
            }

            dom = dom.domParent;
          }

          var y2 = last.y + last.outerHeight;
          dom = last instanceof TextBox ? last.parent.domParent : last.domParent; // 同向上查非inline，每层inline如果是最后一个则加上右侧mbp

          while (true) {
            var _list4 = dom.contentBoxList;
            var _dom$computedStyle4 = dom.computedStyle,
                _display2 = _dom$computedStyle4[DISPLAY$5],
                marginBottom = _dom$computedStyle4[MARGIN_BOTTOM$2],
                borderBottomWidth = _dom$computedStyle4[BORDER_BOTTOM_WIDTH$1],
                paddingBottom = _dom$computedStyle4[PADDING_BOTTOM$1];

            if (_display2 !== 'inline') {
              break;
            }

            if (first === _list4[_list4.length - 1]) {
              y2 += marginBottom + borderBottomWidth + paddingBottom;
            }

            dom = dom.domParent;
          }

          return y2 - y1;
        }

        return 0;
      }
    }, {
      key: "bOffset",
      get: function get() {
        return this.__bOffset;
      }
    }, {
      key: "baseline",
      get: function get() {
        var baseline = this.__baseline; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          baseline = Math.max(baseline, item.baseline);
        });
        return baseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        var baseline = this.__baseline; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          baseline = Math.max(baseline, item.verticalBaseline);
        });
        return baseline;
      }
    }, {
      key: "lineHeight",
      get: function get() {
        var lineHeight = this.__lineHeight; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          lineHeight = Math.max(lineHeight, item.outerHeight);
        });
        return lineHeight;
      }
    }, {
      key: "verticalLineHeight",
      get: function get() {
        var lineHeight = this.__lineHeight; // 只有TextBox和InlineBlock或replaced

        this.list.forEach(function (item) {
          lineHeight = Math.max(lineHeight, item.outerWidth);
        });
        return lineHeight;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isUpright;
      }
    }]);

    return LineBox;
  }();

  /**
   * 维护一个上下文的LineBox，向LineBox中添加Item以及新增下一行的LineBox，多个LineBox组成一个区域
   * 一个block/inlineBlock拥有一个本类对象，上下文即对应这个dom流，而inline则复用最近非inline父元素的
   * 同时LineBox可能连续也可能不连续，不连续的是中间有block之类的隔离开来
   */

  var LineBoxManager = /*#__PURE__*/function () {
    function LineBoxManager(x, y, lineHeight, baseline, isUpright) {
      this.__x = this.__lastX = x; // last存储目前最后一行LineBox的结尾位置，供后续inline使用

      this.__y = this.__lastY = y;
      this.__max = isUpright ? y : x;
      this.__domList = [];
      this.__domStack = [];
      this.__list = []; // 包含若干LineBox

      this.__isNewLine = true; // 区域内是否是新行，容器dom（block）开头肯定是

      this.__lineHeight = lineHeight;
      this.__baseline = baseline;
      this.__isEnd = true; // 在dom中是否一个区域处在结尾，外部控制

      this.__spreadList = []; // verticalAlign时每个区域增加的y高度

      this.__isVertical = isUpright;
    }
    /**
     * 每次换行时重新生成LineBox存入列表，同时由于flow流当前一定是流（dom）的结尾，设置isEnd
     * @returns {LineBox}
     */


    _createClass(LineBoxManager, [{
      key: "genLineBox",
      value: function genLineBox(x, y) {
        var lineBox = new LineBox(x, y, this.__lineHeight, this.__baseline, this.isUpright);
        this.list.push(lineBox);
        this.__isEnd = true;
        return lineBox;
      }
      /**
       * inline的特殊调用，防止空内容但有mbp的inline不占位，放入一个有lineHeight的空lineBox
       * 只有新行开头时需要，后面的无论是否有内容都会影响lineHeight
       * @param x
       * @param y
       * @param l
       * @param b
       * @returns {LineBox}
       */

    }, {
      key: "genLineBoxByInlineIfNewLine",
      value: function genLineBoxByInlineIfNewLine(x, y, l, b) {
        var lineHeight = Math.max(this.__lineHeight, l);
        var baseline = Math.max(this.__baseline, b);

        if (this.__isNewLine) {
          var lineBox = new LineBox(x, y, lineHeight, baseline, this.isUpright);
          this.list.push(lineBox);
          this.__isEnd = true;
          this.__isNewLine = false;
          return lineBox;
        }
      }
      /**
       * 外部设置为结尾，如一个LineBox后出现一个block，此时会被隔断，不再作为流的末尾
       */

    }, {
      key: "setNotEnd",
      value: function setNotEnd() {
        this.__isEnd = false;
      }
      /**
       * 外部设置新行，下次新生成LineBox
       */

    }, {
      key: "setNewLine",
      value: function setNewLine() {
        this.__isNewLine = true;
      }
      /**
       * 当前LineBox放入一个新项，当新行时（如第一行）产生一个新的LineBox并存入列表
       * 是否新区域和新行都是可以被外部控制，默认第一行是新
       * 当被隔断后会被外部重置新行，这样会生成新的来作为新加项的LineBox
       * 当换行时外部也会调用新行，这样再次添加Item时会自动生成新的LineBox而不是用之前的
       * @param o TextBox/Inline/InlineBlock
       * @param nextNewLine 是否设置newLine，标明下次添加新生成LineBox
       * @returns {LineBox}
       */

    }, {
      key: "addItem",
      value: function addItem(o, nextNewLine) {
        var lineBox,
            isUpright = this.isUpright; // 新行新的lineBox，否则复用最后一个

        if (this.__isNewLine) {
          this.__isNewLine = false;
          lineBox = this.genLineBox(o.x, o.y);
        } else {
          var list = this.list;
          var length = list.length;
          lineBox = list[length - 1];
        } // inline递归过程中所有inline父子顺序列表，每个dom都需要对当前内容保存


        this.__domStack.forEach(function (item) {
          item.__contentBoxList.push(o);
        });

        lineBox.add(o); // 设置结束x的位置给next的inline标记用，o可能是TextBox或inlineBlock，当next新行时注意位置

        if (nextNewLine) {
          this.__isNewLine = true;
          this.__lastX = o.x;
          this.__lastY = o.y + o.outerHeight;
        } else {
          if (isUpright) {
            this.__lastX = o.x;
            this.__lastY = o.y + o.outerHeight;
          } else {
            this.__lastX = o.x + o.outerWidth;
            this.__lastY = o.y;
          }
        }

        this.__max = Math.max(this.__max, isUpright ? o.y + o.outerHeight : o.x + o.outerWidth);
        return lineBox;
      }
    }, {
      key: "horizonAlign",
      value: function horizonAlign(size, textAlign, isUpright) {
        this.list.forEach(function (lineBox) {
          var diff = size - (isUpright ? lineBox.height : lineBox.width);

          if (diff > 0) {
            if (textAlign === 'center') {
              diff *= 0.5;
            }

            if (isUpright) {
              lineBox.__offsetY(diff, true);
            } else {
              lineBox.__offsetX(diff, true);
            }
          }
        });
      }
      /**
       * 垂直对齐过程中，如果遇到占位元素如img，可能会导致每行lineBox高度增加，需返回增加量，
       * next行也需要y偏移
       * @returns {number}
       */

    }, {
      key: "verticalAlign",
      value: function verticalAlign(isUpright) {
        var spreadList = this.__spreadList;
        spreadList.splice(0);
        var spread = 0;
        this.list.forEach(function (lineBox) {
          if (spread) {
            lineBox.__bOffset = spread; // 对齐造成的误差需记录给baseline修正

            if (isUpright) {
              lineBox.__offsetX(spread, true);
            } else {
              lineBox.__offsetY(spread, true);
            }
          }

          spread += lineBox.verticalAlign(isUpright);
          spreadList.push(spread);
        });
        return spread;
      }
    }, {
      key: "addX",
      value: function addX(n) {
        this.__lastX += n;
      }
    }, {
      key: "addY",
      value: function addY(n) {
        this.__lastY += n;
      }
      /**
       * inline递归过程中布局调用，不断出入栈dom对象，获取当前行状态下有哪些dom还在
       * @param dom
       */

    }, {
      key: "pushContentBoxList",
      value: function pushContentBoxList(dom) {
        this.__domList.push(dom);

        this.__domStack.push(dom);
      }
    }, {
      key: "popContentBoxList",
      value: function popContentBoxList() {
        this.__domStack.pop();
      }
    }, {
      key: "__offsetX",
      value: function __offsetX(diff) {
        this.list.forEach(function (lineBox) {
          lineBox.__offsetX(diff);
        });
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff) {
        this.list.forEach(function (lineBox) {
          lineBox.__offsetY(diff);
        });
      }
      /**
       * inline的特殊调用，非行首无论是否有内容都设置lineBox的lineHeight
       * @param l
       * @param b
       * @private
       */

    }, {
      key: "setLbByInlineIfNotNewLine",
      value: function setLbByInlineIfNotNewLine(l, b) {
        var length = this.list.length;

        if (length && !this.isNewLine) {
          this.list[length - 1].__setLB(l, b, false);
        }
      }
    }, {
      key: "size",
      get: function get() {
        return this.list.length;
      }
    }, {
      key: "lastX",
      get: function get() {
        return this.__lastX;
      }
    }, {
      key: "lastY",
      get: function get() {
        return this.__lastY;
      }
    }, {
      key: "endX",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[length - 1].endX;
        }

        return this.__x;
      }
    }, {
      key: "endY",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[length - 1].endY;
        }

        return this.__y;
      }
    }, {
      key: "isEnd",
      get: function get() {
        return this.__isEnd;
      }
    }, {
      key: "isNewLine",
      get: function get() {
        return this.__isNewLine;
      }
    }, {
      key: "breakLine",
      get: function get() {
        return this.list.length > 1;
      }
    }, {
      key: "domList",
      get: function get() {
        return this.__domList;
      }
    }, {
      key: "baseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          var n = 0;

          for (var i = 0; i < length - 1; i++) {
            n += list[i].height;
          } // 需考虑因为verticalAlign造成的lineBox偏移offset值，修正计算正确的baseline


          return n + list[length - 1].baseline + list[length - 1].bOffset;
        }

        return 0;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[0].baseline;
        }

        return 0;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        var list = this.list;
        var length = list.length;

        if (length) {
          return list[0].baseline + list[0].bOffset;
        }

        return 0;
      }
    }, {
      key: "lineHeight",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1].lineHeight;
        }

        return 0;
      }
    }, {
      key: "verticalLineHeight",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1].verticalLineHeight;
        }

        return 0;
      }
    }, {
      key: "lineBox",
      get: function get() {
        var list = this.list;

        if (list.length) {
          return list[list.length - 1];
        }
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "width",
      get: function get() {
        var w = 0;
        this.list.forEach(function (item) {
          w = Math.max(w, item.width);
        });
        return w;
      }
    }, {
      key: "spreadList",
      get: function get() {
        return this.__spreadList;
      }
    }, {
      key: "isUpright",
      get: function get() {
        return this.__isVertical;
      }
    }, {
      key: "max",
      get: function get() {
        return this.__max;
      }
    }]);

    return LineBoxManager;
  }();

  var TAG_NAME = {
    'div': true,
    'p': true,
    'span': true,
    'img': true,
    'b': true,
    'strong': true
  };
  var INLINE = {
    'span': true,
    'img': true,
    'b': true,
    'strong': true
  };
  var BOLD = {
    'b': true,
    'strong': true
  };
  var tag = {
    TAG_NAME: TAG_NAME,
    INLINE: INLINE,
    BOLD: BOLD
  };

  var _enums$STYLE_KEY$6 = enums.STYLE_KEY,
      MARGIN_RIGHT$2 = _enums$STYLE_KEY$6.MARGIN_RIGHT,
      MARGIN_LEFT$3 = _enums$STYLE_KEY$6.MARGIN_LEFT,
      PADDING_RIGHT$2 = _enums$STYLE_KEY$6.PADDING_RIGHT,
      PADDING_LEFT$3 = _enums$STYLE_KEY$6.PADDING_LEFT,
      WIDTH$4 = _enums$STYLE_KEY$6.WIDTH,
      HEIGHT$4 = _enums$STYLE_KEY$6.HEIGHT,
      BORDER_RIGHT_WIDTH$2 = _enums$STYLE_KEY$6.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH$3 = _enums$STYLE_KEY$6.BORDER_LEFT_WIDTH,
      FILL$1 = _enums$STYLE_KEY$6.FILL,
      STROKE = _enums$STYLE_KEY$6.STROKE,
      STROKE_MITERLIMIT = _enums$STYLE_KEY$6.STROKE_MITERLIMIT,
      STROKE_WIDTH$6 = _enums$STYLE_KEY$6.STROKE_WIDTH,
      STROKE_LINECAP = _enums$STYLE_KEY$6.STROKE_LINECAP,
      STROKE_LINEJOIN = _enums$STYLE_KEY$6.STROKE_LINEJOIN,
      STROKE_DASHARRAY = _enums$STYLE_KEY$6.STROKE_DASHARRAY,
      STROKE_DASHARRAY_STR = _enums$STYLE_KEY$6.STROKE_DASHARRAY_STR,
      FILL_RULE = _enums$STYLE_KEY$6.FILL_RULE,
      VISIBILITY$3 = _enums$STYLE_KEY$6.VISIBILITY,
      FLEX_BASIS$2 = _enums$STYLE_KEY$6.FLEX_BASIS;
  var AUTO$3 = o$4.AUTO,
      PX$4 = o$4.PX,
      PERCENT$3 = o$4.PERCENT,
      REM$3 = o$4.REM,
      VW$3 = o$4.VW,
      VH$3 = o$4.VH,
      VMAX$3 = o$4.VMAX,
      VMIN$3 = o$4.VMIN,
      RGBA = o$4.RGBA,
      GRADIENT = o$4.GRADIENT;
  var int2rgba = util.int2rgba,
      isNil$8 = util.isNil,
      joinArr = util.joinArr;
  var canvasPolygon$2 = painter.canvasPolygon,
      svgPolygon$1 = painter.svgPolygon;
  var REGISTER = {};

  var Geom = /*#__PURE__*/function (_Xom) {
    _inherits(Geom, _Xom);

    function Geom(tagName, props) {
      var _this;

      _this = _Xom.call(this, tagName, props) || this;
      _this.__isMulti = !!_this.props.multi;
      _this.__style = css.normalize(_this.style, reset.DOM_ENTRY_SET.concat(reset.GEOM_ENTRY_SET));
      _this.__currentStyle = util.extend({}, _this.__style);
      _this.__currentProps = util.clone(_this.props);
      _this.__cacheProps = {};
      return _this;
    }

    _createClass(Geom, [{
      key: "__tryLayInline",
      value: function __tryLayInline(w, total) {
        this.__computeReflow(); // 无children，直接以style的width为宽度，不定义则为0


        var _this$currentStyle = this.currentStyle,
            width = _this$currentStyle[WIDTH$4],
            marginLeft = _this$currentStyle[MARGIN_LEFT$3],
            marginRight = _this$currentStyle[MARGIN_RIGHT$2],
            paddingLeft = _this$currentStyle[PADDING_LEFT$3],
            paddingRight = _this$currentStyle[PADDING_RIGHT$2],
            _this$computedStyle = this.computedStyle,
            borderLeftWidth = _this$computedStyle[BORDER_LEFT_WIDTH$3],
            borderRightWidth = _this$computedStyle[BORDER_RIGHT_WIDTH$2];

        if (width[1] !== AUTO$3) {
          w -= this.__calSize(width, total, true);
        } // 减去水平mbp


        w -= this.__calSize(marginRight, total, true);
        w -= this.__calSize(paddingRight, total, true);
        w -= borderRightWidth;
        w -= this.__calSize(marginLeft, total, true);
        w -= this.__calSize(paddingLeft, total, true);
        w -= borderLeftWidth;
        return w;
      }
    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexBasis = currentStyle[FLEX_BASIS$2],
            width = currentStyle[WIDTH$4],
            height = currentStyle[HEIGHT$4];
        var main = isDirectionRow ? width : height; // basis3种情况：auto、固定、content，只区分固定和其它

        var isFixed = [PX$4, PERCENT$3, REM$3, VW$3, VH$3, VMAX$3, VMIN$3].indexOf(flexBasis.u) > -1;

        if (isFixed) {
          b = max = min = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } else if ([PX$4, PERCENT$3, REM$3, VW$3, VH$3, VMAX$3, VMIN$3].indexOf(main.u) > -1) {
          b = max = min = this.__calSize(main, isDirectionRow ? w : h, true);
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      }
    }, {
      key: "__layout",
      value: function __layout(data, isAbs, isColumn, isRow) {
        _get(_getPrototypeOf(Geom.prototype), "__layout", this).call(this, data, isAbs, isColumn, isRow);

        this.__layoutStyle();
      }
    }, {
      key: "__layoutBlock",
      value: function __layoutBlock(data, isAbs, isColumn, isRow) {
        var _this$__preLayout = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout.fixedWidth,
            fixedHeight = _this$__preLayout.fixedHeight,
            w = _this$__preLayout.w,
            h = _this$__preLayout.h,
            isParentVertical = _this$__preLayout.isParentVertical,
            isUpright = _this$__preLayout.isUpright;

        var tw = 0,
            th = 0;

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        }

        this.__ioSize(tw, th);

        if (isAbs || isColumn || isRow) {
          return;
        }

        this.__marginAuto(this.currentStyle, data);

        this.__cacheProps = {};
      }
    }, {
      key: "__layoutFlex",
      value: function __layoutFlex(data, isAbs, isColumn, isRow) {
        // 无children所以等同于block
        this.__layoutBlock(data, isAbs, isColumn, isRow);
      }
    }, {
      key: "__layoutInline",
      value: function __layoutInline(data, isAbs, isInline) {
        var _this$__preLayout2 = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout2.fixedWidth,
            fixedHeight = _this$__preLayout2.fixedHeight,
            w = _this$__preLayout2.w,
            h = _this$__preLayout2.h;

        var tw = fixedWidth ? w : 0;
        var th = fixedHeight ? h : 0;

        this.__ioSize(tw, th);

        this.__cacheProps = {};
      }
    }, {
      key: "__calStyle",
      value: function __calStyle(lv, __currentStyle, __computedStyle, __cacheStyle) {
        var _this2 = this;

        var res = _get(_getPrototypeOf(Geom.prototype), "__calStyle", this).call(this, lv, __currentStyle, __computedStyle, __cacheStyle);

        if (isNil$8(__cacheStyle[STROKE_WIDTH$6])) {
          __cacheStyle[STROKE_WIDTH$6] = true;
          var strokeWidth = __currentStyle[STROKE_WIDTH$6] || [];
          var w = this.width;
          __computedStyle[STROKE_WIDTH$6] = strokeWidth.map(function (item) {
            return _this2.__calSize(item, w, true);
          });
        }

        if (isNil$8(__cacheStyle[STROKE_DASHARRAY])) {
          __cacheStyle[STROKE_DASHARRAY] = true;
          __computedStyle[STROKE_DASHARRAY] = __currentStyle[STROKE_DASHARRAY] || [];
          __cacheStyle[STROKE_DASHARRAY_STR] = __computedStyle[STROKE_DASHARRAY].map(function (item) {
            return joinArr(item, ',');
          });
        } // 直接赋值的


        [STROKE_LINECAP, STROKE_LINEJOIN, STROKE_MITERLIMIT, FILL_RULE].forEach(function (k) {
          __computedStyle[k] = __currentStyle[k];
        }); // stroke/fll移至render里处理，因为cache涉及渐变坐标偏移

        [FILL$1, STROKE].forEach(function (k) {
          if (isNil$8(__cacheStyle[k])) {
            var v = __currentStyle[k];
            var cs = __computedStyle[k] = [];

            var _res = __cacheStyle[k] = [];

            if (Array.isArray(v)) {
              v.forEach(function (item) {
                if (item && item.u === GRADIENT) {
                  // let t = this.__gradient(renderMode, ctx, x3, y3, x4, y4, item[0], 0, 0);
                  cs.push(item.v);

                  _res.push(true);
                } else if (item && item.u === RGBA && item.v[3] > 0) {
                  cs.push(item.v);

                  _res.push(int2rgba(item.v));
                } else {
                  cs.push('none');

                  _res.push('none');
                }
              });
            }
          }
        });
        return res;
      }
    }, {
      key: "calContent",
      value: function calContent(currentStyle, computedStyle) {
        // Geom强制有内容
        return computedStyle[VISIBILITY$3] !== 'hidden';
      }
    }, {
      key: "__preSet",
      value: function __preSet(renderMode, res) {
        var _this3 = this;

        var width = this.width,
            height = this.height,
            __cacheStyle = this.__cacheStyle,
            computedStyle = this.computedStyle;
        var cx = res.sx3 + width * 0.5;
        var cy = res.sy3 + height * 0.5;
        var strokeDasharrayStr = __cacheStyle[STROKE_DASHARRAY_STR];
        var fill = computedStyle[FILL$1],
            stroke = computedStyle[STROKE],
            strokeWidth = computedStyle[STROKE_WIDTH$6],
            strokeLinecap = computedStyle[STROKE_LINECAP],
            strokeLinejoin = computedStyle[STROKE_LINEJOIN],
            strokeMiterlimit = computedStyle[STROKE_MITERLIMIT],
            strokeDasharray = computedStyle[STROKE_DASHARRAY],
            fillRule = computedStyle[FILL_RULE];
        stroke = stroke.map(function (item) {
          if (item.k) {
            return _this3.__gradient(renderMode, res.ctx, res.sx3, res.sy3, res.sx4, res.sy4, item, res.dx, res.dy);
          }

          return int2rgba(item);
        });
        fill = fill.map(function (item) {
          if (item.k) {
            return _this3.__gradient(renderMode, res.ctx, res.sx3, res.sy3, res.sx4, res.sy4, item, res.dx, res.dy);
          }

          return int2rgba(item);
        });
        return {
          cx: cx,
          cy: cy,
          stroke: stroke,
          strokeWidth: strokeWidth,
          strokeDasharray: strokeDasharray,
          strokeDasharrayStr: strokeDasharrayStr,
          strokeLinecap: strokeLinecap,
          strokeLinejoin: strokeLinejoin,
          strokeMiterlimit: strokeMiterlimit,
          fill: fill,
          fillRule: fillRule
        };
      }
    }, {
      key: "__preSetCanvas",
      value: function __preSetCanvas(renderMode, ctx, res) {
        var stroke = res.stroke,
            strokeWidth = res.strokeWidth,
            strokeDasharray = res.strokeDasharray,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            fill = res.fill;

        if (renderMode === mode.CANVAS) {
          if (fill) {
            if (fill.k === 'linear') {
              ctx.fillStyle = fill.v;
            } else if (fill.k === 'radial' && !Array.isArray(fill.v)) {
              ctx.fillStyle = fill.v;
            } else if (fill.k === 'conic') ; else if (!fill.k && ctx.fillStyle !== fill) {
              ctx.fillStyle = fill;
            }
          }

          if (stroke) {
            if (stroke.k === 'linear') {
              ctx.strokeStyle = stroke.v;
            } else if (stroke.k === 'radial' && !Array.isArray(stroke.v)) {
              ctx.strokeStyle = stroke.v;
            } else if (stroke.k === 'conic') ; else if (!stroke.k && ctx.strokeStyle !== stroke) {
              ctx.strokeStyle = stroke;
            }
          }

          if (strokeWidth !== undefined && ctx.lineWidth !== strokeWidth) {
            ctx.lineWidth = strokeWidth;
          }

          if (strokeLinecap !== undefined && ctx.lineCap !== strokeLinecap) {
            ctx.lineCap = strokeLinecap;
          }

          if (strokeLinejoin !== undefined && ctx.lineJoin !== strokeLinejoin) {
            ctx.lineJoin = strokeLinejoin;
          }

          if (strokeMiterlimit !== undefined && ctx.miterLimit !== strokeMiterlimit) {
            ctx.miterLimit = strokeMiterlimit;
          } // 小程序没这个方法


          if (util.isFunction(ctx.getLineDash)) {
            if (strokeDasharray && !util.equalArr(ctx.getLineDash(), strokeDasharray)) {
              ctx.setLineDash(strokeDasharray);
            }
          } else if (strokeDasharray) {
            ctx.setLineDash(strokeDasharray);
          }
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Geom.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (renderMode === mode.SVG) {
          this.virtualDom.type = 'geom';
        } // 无论canvas/svg，break可提前跳出省略计算


        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        } // data在无cache时没有提前设置


        var preData = this.__preSet(renderMode, res);

        return Object.assign(res, preData);
      }
    }, {
      key: "__renderPolygon",
      value: function __renderPolygon(renderMode, ctx, res) {
        var fills = res.fill,
            fillRules = res.fillRule,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var list = this.__cacheProps.list,
            isMulti = this.isMulti,
            bbox = this.bbox; // 普通情况下只有1个，按普通情况走

        if (fills.length <= 1 && strokes.length <= 1) {
          var o = {
            fill: fills[0],
            fillRule: fillRules[0],
            stroke: strokes[0],
            strokeWidth: strokeWidths[0],
            strokeDasharray: strokeDasharrays[0],
            strokeDasharrayStr: strokeDasharrayStrs[0],
            strokeLinecap: strokeLinecaps[0],
            strokeLinejoin: strokeLinejoins[0],
            strokeMiterlimit: strokeMiterlimits[0],
            dx: dx,
            dy: dy,
            bbox: bbox
          };

          this.__renderOnePolygon(renderMode, ctx, isMulti, list, o);
        } // 多个需要fill在下面，stroke在上面，依次循环
        else {
          for (var i = 0, len = fills.length; i < len; i++) {
            var fill = fills[i];

            if (fill) {
              var _o = {
                fill: fill,
                fillRule: fillRules[i],
                dx: dx,
                dy: dy,
                bbox: bbox
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, _o);
            }
          }

          for (var _i = 0, _len = strokes.length; _i < _len; _i++) {
            var stroke = strokes[_i];

            if (stroke) {
              var _o2 = {
                stroke: stroke,
                strokeWidth: strokeWidths[_i],
                strokeDasharray: strokeDasharrays[_i],
                strokeDasharrayStr: strokeDasharrayStrs[_i],
                strokeLinecap: strokeLinecaps[_i],
                strokeLinejoin: strokeLinejoins[_i],
                strokeMiterlimit: strokeMiterlimits[_i],
                dx: dx,
                dy: dy,
                bbox: bbox
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, _o2);
            }
          }
        }
      }
    }, {
      key: "__renderOnePolygon",
      value: function __renderOnePolygon(renderMode, ctx, isMulti, list, res) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth;
        var isFillCE = fill && fill.k === 'conic';
        var isStrokeCE = stroke && stroke.k === 'conic'; // 椭圆是array

        var isFillRE = fill && fill.k === 'radial' && Array.isArray(fill.v);
        var isStrokeRE = strokeWidth && strokeWidth > 0 && stroke && stroke.k === 'radial' && Array.isArray(stroke.v);

        if (isFillCE || isStrokeCE) {
          if (isFillCE) {
            this.__conicGradient(renderMode, ctx, list, isMulti, res);
          } else if (fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          }

          if (strokeWidth && strokeWidth > 0 && isStrokeCE) {
            inject.warn('Stroke style can not use conic-gradient');
          } else if (strokeWidth && strokeWidth > 0 && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          }
        } else if (isFillRE || isStrokeRE) {
          if (isFillRE) {
            this.__radialEllipse(renderMode, ctx, list, isMulti, res, 'fill');
          } else if (fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          } // stroke椭圆渐变matrix会变形，降级为圆


          if (strokeWidth && strokeWidth > 0 && isStrokeRE) {
            inject.warn('Stroke style can not use radial-gradient for ellipse');
            res.stroke.v = res.stroke.v[0];

            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          } else if (strokeWidth && strokeWidth > 0 && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, false, true);
          }
        } else {
          this.__drawPolygon(renderMode, ctx, isMulti, list, res, true, true);
        }
      }
    }, {
      key: "__drawPolygon",
      value: function __drawPolygon(renderMode, ctx, isMulti, list, res, isFill, isStroke) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth,
            fillRule = res.fillRule,
            strokeDasharrayStr = res.strokeDasharrayStr,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;

        if (renderMode === mode.CANVAS) {
          this.__preSetCanvas(renderMode, ctx, res);

          ctx.beginPath();

          if (isMulti) {
            list.forEach(function (item) {
              return canvasPolygon$2(ctx, item, dx, dy);
            });
          } else {
            canvasPolygon$2(ctx, list, dx, dy);
          }

          if (isFill && fill && fill !== 'none') {
            ctx.fill(fillRule);
          }

          if (isStroke && stroke && stroke !== 'none' && strokeWidth && strokeWidth > 0) {
            ctx.stroke();
          }

          ctx.closePath();
        } else if (renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            list.forEach(function (item) {
              return d += svgPolygon$1(item);
            });
          } else {
            d = svgPolygon$1(list);
          }

          var props = [['d', d]]; // 2个都没有常出现在多fill/stroke时，也有可能特殊单个故意这样写的

          if ((!fill || fill === 'none') && (!stroke || stroke === 'none')) {
            return;
          }

          if (isFill && fill && fill !== 'none') {
            props.push(['fill', fill.v || fill]);

            if (fillRule && fillRule !== 'nonzero') {
              // evenodd
              props.push(['fill-rule', fillRule]);
            }
          } else {
            props.push(['fill', 'none']);
          }

          if (isStroke && stroke && stroke !== 'none' && strokeWidth && strokeWidth > 0) {
            props.push(['stroke', stroke.v || stroke]);
            props.push(['stroke-width', strokeWidth]);

            this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);
          } else {
            props.push(['stroke-width', 0]);
          }

          this.addGeom('path', props);
        }
      }
    }, {
      key: "__inversePtList",
      value: function __inversePtList(list, isMulti, t) {
        var dx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var dy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

        if (isMulti) {
          return list.map(function (item) {
            if (!item || !item.length) {
              return null;
            }

            return item.map(function (item) {
              if (!item || !item.length) {
                return null;
              }

              var arr = [];

              for (var i = 0, len = item.length; i < len; i += 2) {
                var p = mx.calPoint([item[i] + dx, item[i + 1] + dy], t);
                arr.push(p[0]);
                arr.push(p[1]);
              }

              return arr;
            });
          });
        } else {
          return list.map(function (item) {
            if (!item || !item.length) {
              return null;
            }

            var arr = [];

            for (var i = 0, len = item.length; i < len; i += 2) {
              var p = mx.calPoint([item[i] + dx, item[i + 1] + dy], t);
              arr.push(p[0]);
              arr.push(p[1]);
            }

            return arr;
          });
        }
      }
    }, {
      key: "__radialEllipse",
      value: function __radialEllipse(renderMode, ctx, list, isMulti, res, method) {
        var strokeWidth = res.strokeWidth,
            strokeDasharrayStr = res.strokeDasharrayStr,
            strokeLinecap = res.strokeLinecap,
            strokeLinejoin = res.strokeLinejoin,
            strokeMiterlimit = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;

        var _res$method$v = _slicedToArray(res[method].v, 4),
            color = _res$method$v[0],
            matrix = _res$method$v[1],
            cx = _res$method$v[2],
            cy = _res$method$v[3]; // 椭圆渐变的转换，顶点逆矩阵变换


        var tfo = [cx, cy];
        matrix = transform.calMatrixByOrigin(matrix, tfo);
        var t = mx.inverse(matrix);
        list = this.__inversePtList(list, isMulti, t, dx, dy); // 用正向matrix渲染

        if (renderMode === mode.CANVAS) {
          if (matrix) {
            ctx.save(); // 获取当前matrix，在webgl中为E，在canvas中分无cache和有cache模式

            var me = ctx.getTransform();
            me = [me.a, me.b, 0, 0, me.c, me.d, 0, 0, 0, 0, 1, 0, me.e, me.f, 1, 0];
            matrix = mx.multiply(me, matrix);
            ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
          }

          ctx.beginPath();

          if (ctx[method + 'Style'] !== color) {
            ctx[method + 'Style'] = color;
          }

          if (isMulti) {
            list.forEach(function (item) {
              return painter.canvasPolygon(ctx, item);
            });
          } else {
            canvasPolygon$2(ctx, list);
          }

          ctx[method]();
          ctx.closePath();

          if (matrix) {
            ctx.restore();
          }
        } else if (renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            list.forEach(function (item) {
              return d += svgPolygon$1(item);
            });
          } else {
            d = svgPolygon$1(list);
          }

          var props = [['d', d]];

          if (method === 'fill') {
            props.push(['fill', color]);
            props.push(['strokeWidth', 0]);
          } else if (method === 'stroke') {
            props.push(['fill', 'none']);
            props.push(['stroke', color]);
            props.push(['stroke-width', strokeWidth]);

            this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);
          }

          props.push(['transform', "matrix(".concat(joinArr(mx.m2m6(matrix), ','), ")")]);
          this.addGeom('path', props);
        }
      }
    }, {
      key: "__conicGradient",
      value: function __conicGradient(renderMode, ctx, list, isMulti, res) {
        var _this4 = this;

        var fill = res.fill,
            bbox = res.bbox,
            _res$dx = res.dx,
            dx = _res$dx === void 0 ? 0 : _res$dx,
            _res$dy = res.dy,
            dy = _res$dy === void 0 ? 0 : _res$dy;
        var color = fill.v;

        if (renderMode === mode.CANVAS) {
          var _bbox = _slicedToArray(bbox, 4),
              x1 = _bbox[0],
              y1 = _bbox[1],
              x2 = _bbox[2],
              y2 = _bbox[3];

          var w = x2 - x1,
              h = y2 - y1;
          var offscreen = inject.getCacheCanvas(w, h, '__$$CONIC_GRADIENT$$__');
          var imgData = offscreen.ctx.getImageData(0, 0, w, h);
          gradient$1.getConicGradientImage(w * 0.5, h * 0.5, w, h, fill.v.stop, imgData.data);
          offscreen.ctx.putImageData(imgData, 0, 0);

          if (isMulti) {
            list.forEach(function (item) {
              ctx.save();
              ctx.beginPath();
              canvasPolygon$2(ctx, item, dx, dy);
              ctx.clip();
              ctx.closePath();
              ctx.drawImage(offscreen.canvas, x1 + dx, y1 + dy);
              ctx.restore();
            });
          } else {
            ctx.save();
            ctx.beginPath();
            canvasPolygon$2(ctx, list, dx, dy);
            ctx.clip();
            ctx.closePath();
            ctx.drawImage(offscreen.canvas, x1 + dx, y1 + dy);
            ctx.restore();
          }

          offscreen.ctx.clearRect(0, 0, w, h);
        } else if (renderMode === mode.SVG) {
          if (isMulti) {
            list.forEach(function (item) {
              var v = {
                tagName: 'clipPath',
                children: [{
                  tagName: 'path',
                  props: [['d', svgPolygon$1(item)]]
                }]
              };
              var clip = ctx.add(v);

              _this4.__cacheDefs.push(v);

              color.forEach(function (item) {
                _this4.virtualDom.bb.push({
                  type: 'item',
                  tagName: 'path',
                  props: [['d', svgPolygon$1(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
                });
              });
            });
          } else {
            var v = {
              tagName: 'clipPath',
              children: [{
                tagName: 'path',
                props: [['d', svgPolygon$1(list)]]
              }]
            };
            var clip = ctx.add(v);

            this.__cacheDefs.push(v);

            color.forEach(function (item) {
              _this4.virtualDom.bb.push({
                type: 'item',
                tagName: 'path',
                props: [['d', svgPolygon$1(item[0])], ['fill', item[1]], ['clip-path', 'url(#' + clip + ')']]
              });
            });
          }
        }
      }
    }, {
      key: "__propsStrokeStyle",
      value: function __propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit) {
        if (strokeDasharrayStr) {
          props.push(['stroke-dasharray', strokeDasharrayStr]);
        }

        if (strokeLinecap && strokeLinecap !== 'butt') {
          props.push(['stroke-linecap', strokeLinecap]);
        }

        if (strokeLinejoin && strokeLinejoin !== 'miter') {
          props.push(['stroke-linejoin', strokeLinejoin]);
        }

        if (strokeMiterlimit && strokeMiterlimit !== 4) {
          props.push(['stroke-miterlimit', strokeMiterlimit]);
        }
      } // offset/resize时要多一步清空props上记录的缓存

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__offsetX", this).call(this, diff, isLayout, lv);

        if (lv && lv >= o$1.REFLOW) {
          this.__cacheProps = {};
        }
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__offsetY", this).call(this, diff, isLayout, lv);

        if (lv && lv >= o$1.REFLOW) {
          this.__cacheProps = {};
        }
      }
    }, {
      key: "__resizeX",
      value: function __resizeX(diff, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__resizeX", this).call(this, diff, lv);

        if (lv && lv >= o$1.REFLOW) {
          this.__cacheProps = {};
        }
      }
    }, {
      key: "__resizeY",
      value: function __resizeY(diff, lv) {
        _get(_getPrototypeOf(Geom.prototype), "__resizeY", this).call(this, diff, lv);

        if (lv && lv >= o$1.REFLOW) {
          this.__cacheProps = {};
        }
      }
    }, {
      key: "addGeom",
      value: function addGeom(tagName, props) {
        props = util.hash2arr(props);
        this.virtualDom.children.push({
          type: 'item',
          tagName: tagName,
          props: props
        });
      }
    }, {
      key: "getProps",
      value: function getProps(k) {
        var v = this.currentProps[k];

        if (!isNil$8(v)) {
          return v;
        }

        return this['__' + k];
      }
    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return false;
      }
    }, {
      key: "isMulti",
      get: function get() {
        return this.__isMulti;
      }
    }, {
      key: "currentProps",
      get: function get() {
        return this.__currentProps;
      }
    }], [{
      key: "REGISTER",
      get: function get() {
        return REGISTER;
      }
    }, {
      key: "getRegister",
      value: function getRegister(name) {
        if (name && !util.isString(name) && name.prototype && name.prototype instanceof Geom) {
          return name;
        }

        if (!name || !util.isString(name) || name.charAt(0) !== '$') {
          throw new Error('Invalid param');
        }

        if (!REGISTER.hasOwnProperty(name)) {
          throw new Error("Geom has not register: ".concat(name));
        }

        return REGISTER[name];
      }
    }, {
      key: "register",
      value: function register(name, obj) {
        if (!name || !util.isString(name) || name.charAt(0) !== '$' || !obj.prototype || !(obj.prototype instanceof Geom)) {
          throw new Error('Invalid param');
        }

        if (Geom.hasRegister(name)) {
          throw new Error("Geom has already register: ".concat(name));
        }

        REGISTER[name] = obj;
      }
    }, {
      key: "hasRegister",
      value: function hasRegister(name) {
        return name && REGISTER.hasOwnProperty(name);
      }
    }, {
      key: "delRegister",
      value: function delRegister(name) {
        if (Geom.hasRegister(name)) {
          delete REGISTER[name];
        }
      }
    }]);

    return Geom;
  }(Xom);

  var _enums$STYLE_KEY$5 = enums.STYLE_KEY,
      DISPLAY$4 = _enums$STYLE_KEY$5.DISPLAY,
      TOP$2 = _enums$STYLE_KEY$5.TOP,
      BOTTOM$2 = _enums$STYLE_KEY$5.BOTTOM,
      POSITION$2 = _enums$STYLE_KEY$5.POSITION,
      WIDTH$3 = _enums$STYLE_KEY$5.WIDTH,
      HEIGHT$3 = _enums$STYLE_KEY$5.HEIGHT,
      MARGIN_TOP$1 = _enums$STYLE_KEY$5.MARGIN_TOP,
      MARGIN_BOTTOM$1 = _enums$STYLE_KEY$5.MARGIN_BOTTOM,
      MARGIN_LEFT$2 = _enums$STYLE_KEY$5.MARGIN_LEFT,
      BORDER_TOP_WIDTH$1 = _enums$STYLE_KEY$5.BORDER_TOP_WIDTH,
      PADDING_TOP$1 = _enums$STYLE_KEY$5.PADDING_TOP,
      BORDER_LEFT_WIDTH$2 = _enums$STYLE_KEY$5.BORDER_LEFT_WIDTH,
      PADDING_LEFT$2 = _enums$STYLE_KEY$5.PADDING_LEFT;
  var AUTO$2 = o$4.AUTO,
      PX$3 = o$4.PX,
      REM$2 = o$4.REM,
      VW$2 = o$4.VW,
      VH$2 = o$4.VH,
      VMAX$2 = o$4.VMAX,
      VMIN$2 = o$4.VMIN,
      PERCENT$2 = o$4.PERCENT;
  var REPAINT$2 = o$1.REPAINT,
      REFLOW$1 = o$1.REFLOW,
      CACHE$2 = o$1.CACHE;
  var isRelativeOrAbsolute$1 = css.isRelativeOrAbsolute;

  function clearSvgCache(node, child) {
    if (child) {
      node.__refreshLevel |= REPAINT$2;
    } else {
      node.__refreshLevel |= CACHE$2;
    }

    if (Array.isArray(node.children)) {
      node.children.forEach(function (child) {
        if (child instanceof Component) {
          child = child.shadowRoot;
        }

        clearSvgCache(child, true);
      });
    }
  } // 合并margin，和原本不合并情况下的差值


  function getMergeMargin(topList, bottomList) {
    var total = 0;
    var max = topList[0] || 0;
    var min = topList[0] || 0;
    topList.forEach(function (item) {
      total += item;
      max = Math.max(max, item);
      min = Math.min(min, item);
    });
    bottomList.forEach(function (item) {
      total += item;
      max = Math.max(max, item);
      min = Math.min(min, item);
    }); // 正数取最大，负数取最小，正负则相加

    var target = 0;

    if (max > 0 && min > 0) {
      target = Math.max(max, min);
    } else if (max < 0 && min < 0) {
      target = Math.min(max, min);
    } else if (max !== 0 || min !== 0) {
      target = max + min;
    }

    return {
      target: target,
      // 应该的目标margin
      total: total,
      // 累计的margin
      diff: target - total
    };
  } // 提取出对比节点尺寸是否固定非AUTO


  function isFixedWidthOrHeight(node, k) {
    var c = node.currentStyle[k];
    return c.u !== AUTO$2;
  } // 除了固定尺寸，父级也不能是flex


  function isFixedSize(node, includeParentFlex) {
    var res = isFixedWidthOrHeight(node, WIDTH$3) && isFixedWidthOrHeight(node, HEIGHT$3);

    if (res && includeParentFlex) {
      var parent = node.__domParent;

      if (parent) {
        if (parent.computedStyle[DISPLAY$4] === 'flex') {
          return false;
        }
      }
    }

    return res;
  }

  function getPrevMergeMargin(prev, mtList, mbList) {
    while (prev && !(prev instanceof Text) && !(prev instanceof Component && prev.shadowRoot instanceof Text) && ['block', 'flex'].indexOf(prev.computedStyle[DISPLAY$4]) > -1 && prev.computedStyle[POSITION$2] !== 'absolute') {
      mbList.push(prev.computedStyle[MARGIN_BOTTOM$1]);

      if (prev.offsetHeight > 0) {
        break;
      }

      mtList.push(prev.computedStyle[MARGIN_TOP$1]);
      prev = prev.__prev;
    }
  }

  function getNextMergeMargin(next, mtList, mbList) {
    while (next && !(next instanceof Text) && !(next instanceof Component && next.shadowRoot instanceof Text) && ['block', 'flex'].indexOf(next.computedStyle[DISPLAY$4]) > -1 && next.computedStyle[POSITION$2] !== 'absolute') {
      mtList.push(next.computedStyle[MARGIN_TOP$1]);

      if (next.offsetHeight > 0) {
        break;
      }

      mbList.push(next.computedStyle[MARGIN_BOTTOM$1]);
      next = next.__next;
    }
  }

  function offsetNext(next, diff, parentFixed, absList) {
    while (next) {
      var cs = next.currentStyle; // flow流和auto/px/rem的absolute流需要偏移diff值

      if (cs[POSITION$2] !== 'absolute' || cs[TOP$2].u === AUTO$2 && cs[BOTTOM$2].u === AUTO$2 || cs[TOP$2].u === AUTO$2 && [PX$3, REM$2, VW$2, VH$2, VMAX$2, VMIN$2].indexOf(cs[BOTTOM$2].u) > -1) {
        next.__offsetY(diff, true, REFLOW$1);
      } // absolute中百分比的特殊计算偏移，但要排除parent固定尺寸
      else if (!parentFixed && cs[POSITION$2] === 'absolute' && (cs[TOP$2].u === PERCENT$2 || cs[BOTTOM$2].u === PERCENT$2)) {
        if (cs[TOP$2].u === PERCENT$2) {
          next.__offsetY(diff * 0.01 * cs[TOP$2].v, true, REFLOW$1);
        } else {
          next.__offsetY(diff * (1 - 0.01 * cs[BOTTOM$2].v), true, REFLOW$1);
        }
      } // abs的percent调整，记录


      if (!(cs instanceof Text) && !(cs instanceof Component && cs.shadowRoot instanceof Text)) {
        if (cs[POSITION$2] === 'absolute' && cs[HEIGHT$3].u === PERCENT$2) {
          absList.push(next);
        }
      }

      next = next.__next;
    }

    return diff;
  }
  /**
   * 单独提出共用检测影响的函数，从节点本身开始向上分析影响，找到最上层的影响节点设置其重新布局
   * ---
   * 当一个元素absolute时，其变化不会影响父元素和兄弟元素，直接自己重新layout
   * 当absolute发生改变时，其变化会影响父和兄弟，视作父重新布局
   * 当inline变化时，视为其最近block/flex父变化
   * 当block/flex变化时，往上查找最上层flex视为其变化，如没有flex则影响后面兄弟offset和父resize
   * 以上情况向上查找时遇到父absolute均提前跳出，并layout
   * 上面所有情况即便结束还得额外看是否处于absolute中，是还是标记absolute重新布局
   * 当relative只变化left/top/right/bottom时，自己重新layout
   * ===
   * 返回最上层节点，可能为node自己
   */


  function checkTop(root, node, addDom, removeDom) {
    if (root === node) {
      return root;
    }

    if (node instanceof Text) {
      node = node.__domParent;
    } // add/remove情况abs节点特殊对待不影响其它节点，不能判断display，因为inline会强制block


    if (addDom && node.currentStyle[POSITION$2] === 'absolute') {
      return node;
    }

    if (removeDom && node.computedStyle[POSITION$2] === 'absolute') {
      return node;
    }

    var target = node; // add/remove的相邻出现inline的话，视为父节点reflow

    if (addDom || removeDom) {
      var isSiblingBlock = true;
      var _node = node,
          __prev = _node.__prev,
          __next = _node.__next;

      if (__prev && (__prev instanceof Text || ['inline', 'inlineBlock'].indexOf(__prev.computedStyle[DISPLAY$4]) > -1)) {
        isSiblingBlock = false;
      } else if (__next && (__next instanceof Text || ['inline', 'inlineBlock'].indexOf(__next.computedStyle[DISPLAY$4]) > -1)) {
        isSiblingBlock = false;
      }

      if (!isSiblingBlock) {
        target = node.__domParent;

        if (target === root) {
          return root;
        }
      }
    } // 如果一直是absolute，则不影响其它节点


    if (target.currentStyle[POSITION$2] === 'absolute' && target.computedStyle[POSITION$2] === 'absolute') {
      return target;
    } // inline节点变为最近的父非inline，自身可能会display变化前后状态都要看，
    // absolute不变会影响但被上面if排除，而absolute发生变化则也需要进入这里


    if (['inline', 'inlineBlock'].indexOf(target.currentStyle[DISPLAY$4]) > -1 || ['inline', 'inlineBlock'].indexOf(target.computedStyle[DISPLAY$4]) > -1) {
      do {
        target = target.__domParent;

        if (target === root) {
          return root;
        }
      } // 父节点不会display变化，因为同步检测，只看computedStyle即可
      while (['inline', 'inlineBlock'].indexOf(target.computedStyle[DISPLAY$4]) > -1 && target.computedStyle[POSITION$2] !== 'absolute'); // target已不是inline，父固定宽高跳出直接父进行LAYOUT即可，不影响上下文，但不能是flex孩子，此时固定尺寸无用
      // root也会进这里，因为root强制固定size


      if (isFixedSize(target, true)) {
        return target;
      }
    } // 此时target指向node，如果是inline/absolute变化则是其最近的非inline父


    var parent = target; // 向上检查flex/absolute/fixedSize，以最上层的flex视作其更改，node本身flex不进入

    var top;

    do {
      if (parent === root) {
        break;
      }

      if (parent.computedStyle[DISPLAY$4] === 'flex') {
        top = parent;
      } // 遇到固定size提前跳出，以及absolute也是


      if (parent.computedStyle[POSITION$2] === 'absolute' || isFixedSize(parent, true)) {
        break;
      }

      parent = parent.__domParent;
    } while (parent); // 找到最上层flex，视作其更改


    if (top) {
      target = top;
    }

    return target;
  }
  /**
   * checkReflow之后，节点重新布局对自己next的节点的offset影响，计算偏移量让所有next兄弟offsetY，
   * 以及递归向上父级resize和父级所有next兄弟offsetY
   */


  function checkNext(root, top, node, hasZ, addDom, removeDom) {
    var cps = top.computedStyle,
        crs = top.currentStyle;
    var position = cps[POSITION$2],
        display = cps[DISPLAY$4];
    var isLastAbs = position === 'absolute';
    var isNowAbs = crs[POSITION$2] === 'absolute';
    var isLastNone = display === 'none';
    var isNowNone = crs[DISPLAY$4] === 'none';
    var isLast0 = top.offsetHeight === 0; // none不可见布局无效可以无视，add/remove已提前判断，none时不会进来

    if (isLastNone && isNowNone) {
      return;
    }

    var parent = top.__domParent,
        oldH = top.offsetHeight; // svg在特殊children顺序变化的情况需清除缓存以便diff运行
    // add/remove已提前自己做好，zIndex有效变化也触发，position变更static和非static触发

    var svg = root.renderMode === mode.SVG;

    if (!addDom && !removeDom) {
      if (hasZ && position === 'static' && crs[POSITION$2] === 'static') {
        hasZ = false;
      } else if (position !== crs[POSITION$2] && (position === 'static' || crs[POSITION$2] === 'static')) {
        hasZ = true;
      } // 特殊，zIndexChildren不变化但影响svg的diff
      else if (isLastNone !== isNowNone && !hasZ) {
        svg && clearSvgCache(parent, false);
      }
    } else {
      hasZ = false;
    } // remove自身且abs时不影响其它，除了svg的zIndex


    if (removeDom && top === node && node.computedStyle[POSITION$2] === 'absolute') {
      top.clearCache(true);
      svg && clearSvgCache(parent, false);
      return;
    } // 后续调整offsetY需要考虑mergeMargin各种情况（包含上下2个方向），之前合并前和合并后的差值都需记录
    // 先记录没更新前的，如果是空节点则m1作为整个，忽视m2


    var t1 = 0,
        t2 = 0;
    var mbList = [],
        mtList = [];
    var prev = top.isShadowRoot ? top.__hostRoot.__prev : top.__prev;
    var next = top.isShadowRoot ? top.__hostRoot.__next : top.__next;

    if (addDom || isLast0) {
      getPrevMergeMargin(prev, mtList, mbList);
      getNextMergeMargin(next, mtList, mbList);

      if (!addDom) {
        mtList.push(cps[MARGIN_TOP$1]);
        mbList.push(cps[MARGIN_BOTTOM$1]);
      }

      var t = getMergeMargin(mtList, mbList);
      t1 = t.target;
      t.diff;
    } else {
      getPrevMergeMargin(prev, mtList, mbList);
      mtList.push(cps[MARGIN_TOP$1]);

      var _t = getMergeMargin(mtList, mbList);

      t1 = _t.target;
      _t.diff;
      mtList.splice(0);
      mbList.splice(0);
      getNextMergeMargin(next, mtList, mbList);
      mbList.push(cps[MARGIN_BOTTOM$1]);
      _t = getMergeMargin(mtList, mbList);
      t2 = _t.target;
      _t.diff;
    } // __layoutData使用prev或者父节点，并重新计算y（不包含合并margin），因为display:none或add的无数据或不对


    var __layoutData = parent.__layoutData;
    var x = __layoutData.x;
    var y = __layoutData.y;
    var w = parent.__width;
    var h = parent.__currentStyle[HEIGHT$3].u === AUTO$2 ? __layoutData.h : parent.__height;
    var current = top; // cp的shadowRoot要向上到cp本身，考虑高阶组件在内到真正的顶层cp

    if (current.isShadowRoot) {
      current = current.__hostRoot;
    } // y使用prev或者parent的，首个节点无prev，prev要忽略absolute的和display:none的


    var ref = current.__prev;
    var hasFlowPrev;

    while (ref) {
      // 注意有可能是text，视为其父级
      var computedStyle = ref.computedStyle;

      if (computedStyle[POSITION$2] !== 'absolute' && computedStyle[DISPLAY$4] !== 'none') {
        y = ref.y + ref.outerHeight;
        hasFlowPrev = true;
        break;
      }

      ref = ref.__prev;
    } // 找不到prev以默认parent的为基准，找到则增加自身，排除remove


    var __computedStyle = parent.__computedStyle;

    if (!hasFlowPrev) {
      y += __computedStyle[MARGIN_TOP$1] + __computedStyle[BORDER_TOP_WIDTH$1] + __computedStyle[PADDING_TOP$1];
    }

    x += __computedStyle[MARGIN_LEFT$2] + __computedStyle[BORDER_LEFT_WIDTH$2] + __computedStyle[PADDING_LEFT$2]; // 特殊的如add/remove时为absolute和none的在调用时即检查提前跳出了，不触发reflow，这里一定是触发的
    // 找到最上层容器供absolute使用，注意top本身是否abs的区别，非abs可能为relative）

    var container = isNowAbs ? parent : top;

    while (container && container !== root) {
      if (isRelativeOrAbsolute$1(container)) {
        break;
      }

      container = container.__domParent;
    }

    if (!container) {
      container = root;
    } // 删除的节点的影响top是自己，无需重新布局只要看next节点的offsetY


    if (removeDom && top === node) ; // 一定不是add/remove，同步操作提前判断
    else if (isNowNone) {
      top.__layoutNone();

      if (hasZ) {
        parent.__zIndexChildren = null;

        parent.__updateStruct();

        svg && clearSvgCache(parent, false);
      }
    } // 现在是定位流，还要看之前是什么
    else if (isNowAbs) {
      parent.__layoutAbs(container, __layoutData, top);

      if (hasZ) {
        parent.__zIndexChildren = null;

        parent.__updateStruct();

        svg && clearSvgCache(parent, false);
      } // add/remove的zIndex已提前做好无需关心，只看普通变更


      if (!addDom && !removeDom) {
        // 之前也是abs，可以跳出不会影响其它只看zIndex即可
        if (isLastAbs) {
          top.clearCache(true);
          return;
        }
      }
    } // 现在是普通流，不管之前是啥直接布局
    else {
      var ld = Object.assign({}, addDom ? __layoutData : top.__layoutData, {
        x: x,
        y: y,
        w: w,
        h: h
      });

      top.__layout(ld, false, false, false); // 防止Geom


      if (!(top instanceof Geom)) {
        top.__layoutAbs(container, ld, null);
      }

      if (hasZ) {
        parent.__zIndexChildren = null;

        parent.__updateStruct();

        svg && clearSvgCache(parent, false);
      }
    } // add的情况在自身是abs时不影响next，除了svg的zIndex


    if (addDom && top === node && node.currentStyle[POSITION$2] === 'absolute') {
      top.clearCache(true);
      svg && clearSvgCache(parent, false);
      return;
    } // 向上查找最近的relative的parent，获取ox/oy并赋值，无需继续向上递归，因为parent已经递归包含了


    var p = parent;

    while (p) {
      if (p.__computedStyle[POSITION$2] === 'relative') {
        var _p = p,
            ox = _p.ox,
            oy = _p.oy;
        ox && top.__offsetX(ox, false, null);
        oy && top.__offsetY(oy, false, null);
        break;
      }

      p = p.__domParent;
    } // 高度不变一直0提前跳出，不影响包含margin合并，但需排除节点add/remove，因为空节点会上下穿透合并


    var isNow0 = removeDom && top === node || top.offsetHeight === 0; // 几种忽略的情况

    if (addDom && isNow0 || removeDom && isLast0) {
      top.clearCache(true);
      return;
    } // 查看现在的上下margin合并情况，和之前的对比得出diff差值进行offsetY/resizeY


    if (top.isShadowRoot) {
      top = top.__hostRoot;
    }

    var t3 = 0,
        d3 = 0,
        t4 = 0;
    mbList.splice(0);
    mtList.splice(0);

    if (removeDom || isNow0) {
      getPrevMergeMargin(prev, mtList, mbList);
      getNextMergeMargin(next, mtList, mbList);

      if (!removeDom) {
        mtList.push(cps[MARGIN_TOP$1]);
        mbList.push(cps[MARGIN_BOTTOM$1]);
      }

      var _t2 = getMergeMargin(mtList, mbList);

      t3 = _t2.target;
      d3 = _t2.diff;
    } else {
      getPrevMergeMargin(prev, mtList, mbList);
      mtList.push(cps[MARGIN_TOP$1]);

      var _t3 = getMergeMargin(mtList, mbList);

      t3 = _t3.target;
      d3 = _t3.diff;
      mtList.splice(0);
      mbList.splice(0);
      getNextMergeMargin(next, mtList, mbList);
      mbList.push(cps[MARGIN_BOTTOM$1]);
      _t3 = getMergeMargin(mtList, mbList);
      t4 = _t3.target;
      _t3.diff;
    }

    var nowH;

    if (removeDom) {
      // remove有没有向上影响，决定布局后的高度nowH
      var isRemoveSelf = top === node || node.isShadowRoot && node.__hostRoot === top;
      var temp = node;

      while (temp.isShadowRoot) {
        temp = temp.__host;

        temp.__destroy();
      }

      node.__destroy();

      if (isRemoveSelf) {
        nowH = 0;
      } else {
        nowH = top.offsetHeight;
      }
    } else if (isNowAbs) {
      nowH = 0;
    } else {
      nowH = top.offsetHeight;
    } // 查看mergeMargin对top造成的偏移


    if (!removeDom && d3) {
      top.__offsetY(d3, true, REFLOW$1);
    } // 差值计算注意考虑margin合并前的值，和合并后的差值，height使用offsetHeight不考虑margin


    var diff = t3 + t4 - t1 - t2 + nowH - oldH; // console.log('t3', t3, 'd3', d3, 't4', t4, 'd4', d4, 't1', t1, 'd1', d1, 't2', t2, 'd2', d2, nowH, oldH, diff);

    if (!diff) {
      parent.clearCache(true);
      return;
    }

    var parentFixed = isFixedWidthOrHeight(parent, HEIGHT$3);

    if (!parentFixed) {
      parent.__resizeY(diff, REFLOW$1);
    } // 调整的同时遇到百分比高度的abs需记录下来最后重新布局


    var absList = [];
    offsetNext(next, diff, parentFixed, absList);
    parent.clearCache(true); // 影响完next之后，向上递归，所有parent的next都影响，遇到固定尺寸或absolute跳出

    while (parent && !parentFixed && parent.__computedStyle[POSITION$2] !== 'absolute') {
      next = parent.__next;
      parent = parent.__domParent;
      parentFixed = parent && isFixedWidthOrHeight(parent, HEIGHT$3);

      if (!parentFixed) {
        parent.__resizeY(diff, REFLOW$1);
      }

      offsetNext(next, diff, parentFixed, absList);

      if (parentFixed) {
        parent.clearCache(true);
      }
    } // 记录的受影响的abs节点，都是百分比高度，需重新布局


    absList.forEach(function (item) {
      var ld = item.__layoutData,
          container = ld.container;

      item.__domParent.__layoutAbs(container, ld, item);
    });
  }

  var reflow = {
    getMergeMargin: getMergeMargin,
    checkTop: checkTop,
    checkNext: checkNext,
    clearSvgCache: clearSvgCache
  };

  /**
   * 打平children，多维嵌套的数组变成一维
   */

  function buildChildren(parent, children) {
    var list = [];
    flatten(parent, children, list);
    return list;
  }

  function flatten(parent, children, list) {
    if (Array.isArray(children)) {
      children.forEach(function (item) {
        flatten(parent, item, list);
      });
    } else if (children instanceof Xom) {
      if (['canvas', 'svg', 'webgl'].indexOf(children.tagName) > -1) {
        throw new Error('Can not nest canvas/svg/webgl');
      }

      children.__parent = parent;
      list.push(children);
    } else if (children instanceof Component) {
      children.__parent = parent;
      list.push(children);
    } else if (!util.isNil(children) && children !== '') {
      var t = new Text(children);
      t.__parent = parent;
      list.push(t);
    }
  }
  /**
   * 设置关系，父子和兄弟，被添加到真实dom中前调用
   */


  function relation(root, host, parent, children) {
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    if (Array.isArray(children)) {
      children.forEach(function (item) {
        relation(root, host, parent, item, options);
      });
    } else if (children instanceof Xom || children instanceof Component || children instanceof Text) {
      children.__root = root;
      children.__parent = parent;
      children.__domParent = parent;
      children.__isDestroyed = false;

      if (options.prev) {
        options.prev.__next = children;
        children.__prev = options.prev;
      }

      options.prev = children;

      if (!(children instanceof Text)) {
        var ref = children.props.ref;

        if (util.isString(ref) && ref || util.isNumber(ref)) {
          host.ref[ref] = children;
        } else if (ref && util.isFunction(ref)) {
          ref(children);
        }
      }

      if (children instanceof Xom && children.__children) {
        relation(root, host, children, children.__children, {});
      } else if (children instanceof Component) {
        var sr = children.render();
        var hoc = [];

        while (sr && sr instanceof Component) {
          hoc.push(sr);
          var res = sr.render();

          if (res) {
            sr.__shadow = res;
            res.__host = sr;
          }

          sr = res;
        }

        if (!(sr instanceof Node)) {
          sr = new Text(sr);
        }

        if (hoc.length) {
          children.__shadow = hoc[0];
          hoc[0].__host = children;
          hoc.forEach(function (item) {
            item.__shadowRoot = sr;
            item.__hostRoot = children;
            item.__root = root;
            item.__domParent = parent;
          });
        } else {
          children.__shadow = sr;
          sr.__host = children;
        }

        children.__shadowRoot = sr;
        sr.__hostRoot = children;
        sr.__root = root;
        sr.__domParent = parent;
        sr.__isDestroyed = false;

        children.__init();

        if (sr instanceof Xom && sr.__children) {
          relation(root, children, sr, sr.__children, {});
        }
      }
    }

    return children;
  } // 设置每个节点root引用，组件初始化


  function buildRoot(root, children) {
    root.__root = root;
    root.__host = root;
    relation(root, root, root, children, {});
  }

  var builder = {
    buildChildren: buildChildren,
    buildRoot: buildRoot,
    relation: relation
  };

  var _enums$STYLE_KEY$4 = enums.STYLE_KEY,
      POSITION$1 = _enums$STYLE_KEY$4.POSITION,
      DISPLAY$3 = _enums$STYLE_KEY$4.DISPLAY,
      MARGIN_LEFT$1 = _enums$STYLE_KEY$4.MARGIN_LEFT,
      MARGIN_TOP = _enums$STYLE_KEY$4.MARGIN_TOP,
      MARGIN_RIGHT$1 = _enums$STYLE_KEY$4.MARGIN_RIGHT,
      MARGIN_BOTTOM = _enums$STYLE_KEY$4.MARGIN_BOTTOM,
      PADDING_LEFT$1 = _enums$STYLE_KEY$4.PADDING_LEFT,
      PADDING_BOTTOM = _enums$STYLE_KEY$4.PADDING_BOTTOM,
      PADDING_RIGHT$1 = _enums$STYLE_KEY$4.PADDING_RIGHT,
      PADDING_TOP = _enums$STYLE_KEY$4.PADDING_TOP,
      BORDER_TOP_WIDTH = _enums$STYLE_KEY$4.BORDER_TOP_WIDTH,
      BORDER_BOTTOM_WIDTH = _enums$STYLE_KEY$4.BORDER_BOTTOM_WIDTH,
      BORDER_RIGHT_WIDTH$1 = _enums$STYLE_KEY$4.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH$1 = _enums$STYLE_KEY$4.BORDER_LEFT_WIDTH,
      TOP$1 = _enums$STYLE_KEY$4.TOP,
      RIGHT$1 = _enums$STYLE_KEY$4.RIGHT,
      BOTTOM$1 = _enums$STYLE_KEY$4.BOTTOM,
      LEFT$1 = _enums$STYLE_KEY$4.LEFT,
      WIDTH$2 = _enums$STYLE_KEY$4.WIDTH,
      HEIGHT$2 = _enums$STYLE_KEY$4.HEIGHT,
      TEXT_ALIGN = _enums$STYLE_KEY$4.TEXT_ALIGN,
      FLEX_DIRECTION = _enums$STYLE_KEY$4.FLEX_DIRECTION,
      FLEX_BASIS$1 = _enums$STYLE_KEY$4.FLEX_BASIS,
      FLEX_SHRINK = _enums$STYLE_KEY$4.FLEX_SHRINK,
      FLEX_GROW = _enums$STYLE_KEY$4.FLEX_GROW,
      ALIGN_SELF = _enums$STYLE_KEY$4.ALIGN_SELF,
      ALIGN_ITEMS = _enums$STYLE_KEY$4.ALIGN_ITEMS,
      JUSTIFY_CONTENT = _enums$STYLE_KEY$4.JUSTIFY_CONTENT,
      Z_INDEX$1 = _enums$STYLE_KEY$4.Z_INDEX,
      WHITE_SPACE = _enums$STYLE_KEY$4.WHITE_SPACE,
      LINE_HEIGHT = _enums$STYLE_KEY$4.LINE_HEIGHT,
      LINE_CLAMP = _enums$STYLE_KEY$4.LINE_CLAMP,
      ORDER = _enums$STYLE_KEY$4.ORDER,
      FLEX_WRAP = _enums$STYLE_KEY$4.FLEX_WRAP,
      ALIGN_CONTENT = _enums$STYLE_KEY$4.ALIGN_CONTENT,
      OVERFLOW$1 = _enums$STYLE_KEY$4.OVERFLOW,
      FONT_SIZE$1 = _enums$STYLE_KEY$4.FONT_SIZE,
      FONT_FAMILY = _enums$STYLE_KEY$4.FONT_FAMILY,
      FONT_WEIGHT = _enums$STYLE_KEY$4.FONT_WEIGHT,
      WRITING_MODE$1 = _enums$STYLE_KEY$4.WRITING_MODE,
      ELLIPSIS = enums.ELLIPSIS;
  var AUTO$1 = o$4.AUTO,
      PX$2 = o$4.PX,
      PERCENT$1 = o$4.PERCENT,
      REM$1 = o$4.REM,
      VW$1 = o$4.VW,
      VH$1 = o$4.VH,
      VMAX$1 = o$4.VMAX,
      VMIN$1 = o$4.VMIN;
  var isRelativeOrAbsolute = css.isRelativeOrAbsolute,
      getBaseline = css.getBaseline,
      getVerticalBaseline = css.getVerticalBaseline;
  var extend$1 = util.extend;
      util.isNil;
      var isFunction$4 = util.isFunction,
      assignMatrix$1 = util.assignMatrix;
  var CANVAS = mode.CANVAS,
      SVG = mode.SVG,
      WEBGL = mode.WEBGL;
  var isE$2 = mx.isE,
      multiply$1 = mx.multiply; // 渲染获取zIndex顺序

  function genZIndexChildren(dom) {
    var normal = [];
    var hasMc;
    var mcHash = {};
    var lastMaskIndex;
    var children = dom.children;
    children.forEach(function (item, i) {
      var child = item;

      if (item instanceof Component) {
        item = item.shadowRoot;
      } // 遮罩单独保存后特殊排序


      if (item instanceof Xom && item.__isMask) {
        // 开头的mc忽略，后续的连续mc以第一次出现为准
        if (lastMaskIndex !== undefined) {
          mcHash[lastMaskIndex].push(item);
        } else if (i) {
          lastMaskIndex = i - 1;
          children[lastMaskIndex].__iIndex = lastMaskIndex;
          mcHash[lastMaskIndex] = [item];
          hasMc = true;
        }
      } else {
        lastMaskIndex = undefined;

        if (item instanceof Xom) {
          child.__zIndex = item.currentStyle[Z_INDEX$1];

          if (isRelativeOrAbsolute(item)) {
            // 临时变量为排序使用
            child.__aIndex = true;
            normal.push(child);
          } else {
            // 之前遗留清除
            child.__aIndex = undefined;
            normal.push(child);
          }
        } else {
          child.__zIndex = 0;
          normal.push(child);
        }

        child.__iIndex = i;
      }
    });
    normal.sort(function (a, b) {
      if (a.__zIndex !== b.__zIndex) {
        return a.__zIndex - b.__zIndex;
      } // zIndex相等时abs优先flow


      if (a.__aIndex !== b.__aIndex) {
        if (a.__aIndex) {
          return 1;
        }

        return -1;
      } // 都相等看索引


      return a.__iIndex - b.__iIndex;
    }); // 将遮罩插入到对应顺序上

    if (hasMc) {
      for (var i = normal.length - 1; i >= 0; i--) {
        var idx = normal[i].__iIndex;

        if (mcHash.hasOwnProperty(idx)) {
          normal.splice.apply(normal, [i + 1, 0].concat(_toConsumableArray(mcHash[idx])));
        }
      }
    }

    return normal;
  } // flex布局阶段顺序，不是渲染也和struct结构无关，可以无视mask


  function genOrderChildren(flowChildren) {
    var normal = [];
    flowChildren.forEach(function (item, i) {
      var child = item;

      if (item instanceof Component) {
        item = item.shadowRoot;
      }

      if (item instanceof Xom) {
        child.__order = item.currentStyle[ORDER];
      } else {
        child.__order = 0;
      }

      normal.push(child);
      child.__iIndex = i;
    });
    normal.sort(function (a, b) {
      if (a.__order !== b.__order) {
        return a.__order - b.__order;
      } // order相等时看节点索引


      return a.__iIndex - b.__iIndex;
    });
    return normal;
  }
  /**
   * lineClamp超出范围时ib作为最后一行最后一个无法挤下时进行回溯
   */


  function backtrack(bp, lineBoxManager, lineBox, total, endSpace, isUpright) {
    var ew,
        computedStyle = bp.computedStyle,
        root = bp.root,
        renderMode = root.renderMode;
    var list = lineBox.list; // 根据textBox里的内容，确定当前内容，索引，x和剩余宽度

    list.forEach(function (item) {
      total -= isUpright ? item.outerHeight : item.outerWidth;
    });
    var ctx;

    if (renderMode === CANVAS || renderMode === WEBGL) {
      ctx = renderMode === WEBGL ? inject.getFontCanvas().ctx : root.ctx;
    } // 临时测量ELLIPSIS的尺寸


    if (renderMode === CANVAS || renderMode === WEBGL) {
      var font = css.setFontStyle(computedStyle);

      if (ctx.font !== font) {
        ctx.font = font;
      }

      ew = ctx.measureText(ELLIPSIS).width;
    } else {
      ew = inject.measureTextSync(ELLIPSIS, computedStyle[FONT_FAMILY], computedStyle[FONT_SIZE$1], computedStyle[FONT_WEIGHT]);
    }

    for (var i = list.length - 1; i >= 0; i--) {
      var item = list[i]; // 无论删除一个ib还是textBox，放得下的话都可以暂停循环，注意强制保留行首

      if (!i || total + item.outerWidth >= ew + 1e-10) {
        if (item instanceof TextBox) {
          var text = item.parent;

          text.__backtrack(bp, lineBoxManager, lineBox, item, total, endSpace, ew, computedStyle, ctx, renderMode, isUpright);
        } else {
          var ep = new Ellipsis(item.x + item.outerWidth + endSpace, item.y, ew, bp);
          lineBoxManager.addItem(ep, true);
        }

        break;
      } // 放不下删除
      else {
        if (item instanceof TextBox) {
          var _text = item.parent;

          var _i = _text.textBoxes.indexOf(item);

          if (_i > -1) {
            _text.textBoxes.splice(_i, 1);
          }
        } else {
          item.__layoutNone();
        }

        list.pop();
        total += isUpright ? item.outerHeight : item.outerWidth;
      }
    }
  }

  var Dom = /*#__PURE__*/function (_Xom) {
    _inherits(Dom, _Xom);

    function Dom(tagName, props, children) {
      var _this;

      _this = _Xom.call(this, tagName, props) || this;

      var _assertThisInitialize = _assertThisInitialized(_this),
          style = _assertThisInitialize.style;

      if (!style.display || !{
        flex: true,
        block: true,
        inline: true,
        'inline-block': true,
        inlineBlock: true,
        none: true
      }.hasOwnProperty(style.display)) {
        if (tag.INLINE.hasOwnProperty(_this.tagName)) {
          style.display = 'inline';
        } else {
          style.display = 'block';
        }
      }

      if (!style[FONT_WEIGHT] && tag.BOLD.hasOwnProperty(tagName)) {
        style.fontWeight = 700;
      }

      _this.__style = css.normalize(style, reset.DOM_ENTRY_SET); // currentStyle/currentProps不深度clone，继承一层即可，动画时也是extend这样只改一层引用不动原始静态style

      _this.__currentStyle = extend$1({}, _this.__style);
      _this.__children = builder.buildChildren(_assertThisInitialized(_this), children);
      _this.__flexLine = []; // flex布局多行模式时存储行

      _this.__ellipsis = null; // 虚拟节点，有的话渲染

      _this.__zIndexChildren = null;
      return _this;
    }

    _createClass(Dom, [{
      key: "__structure",
      value: function __structure(lv, j) {
        var res = _get(_getPrototypeOf(Dom.prototype), "__structure", this).call(this, lv, j);

        var arr = [res];
        var zIndexChildren = this.__zIndexChildren = this.__zIndexChildren || genZIndexChildren(this);
        zIndexChildren.forEach(function (child, i) {
          var temp = child.__structure(lv + 1, i);

          if (Array.isArray(temp)) {
            arr = arr.concat(temp);
          } else {
            arr.push(temp);
          }
        });
        var total = arr.length - 1;
        res.num = zIndexChildren.length;
        res.total = total;
        return arr;
      }
    }, {
      key: "__modifyStruct",
      value: function __modifyStruct() {
        var _root$__structs;

        var struct = this.__struct;
        var total = struct.total || 0;
        var root = this.__root,
            __structs = root.__structs; // 新生成了struct，引用也变了

        var nss = this.__structure(struct.lv, struct.childIndex);

        var i = __structs.indexOf(struct);

        (_root$__structs = root.__structs).splice.apply(_root$__structs, [i, total + 1].concat(_toConsumableArray(nss)));

        var d = 0;

        if (this !== root) {
          struct = this.__struct;
          d = (struct.total || 0) - total;

          if (d) {
            var p = this.__domParent;

            while (p) {
              p.__struct.total = p.__struct.total || 0;
              p.__struct.total += d;
              p = p.__domParent;
            }
          }
        }
      }
    }, {
      key: "__insertStruct",
      value: function __insertStruct(child, childIndex) {
        var struct = this.__struct;

        var cs = child.__structure(struct.lv + 1, childIndex);

        var root = this.__root,
            structs = root.__structs; // 根据是否有prev确定插入索引位置

        var zIndexChildren = this.__zIndexChildren;
        var i;

        if (childIndex) {
          var ps = zIndexChildren[childIndex - 1].__struct;

          var _total = ps.total || 0;

          i = structs.indexOf(ps) + _total + 1;
        } else {
          i = structs.indexOf(struct) + 1;
        }

        var total;

        if (Array.isArray(cs)) {
          structs.splice.apply(structs, [i, 0].concat(_toConsumableArray(cs)));
          total = (cs[0].total || 0) + 1;
        } else {
          structs.splice(i, 0, cs);
          total = (cs.total || 0) + 1;
        } // 调整后面children的childIndex，+1


        i++;

        for (var len = zIndexChildren.length; i < len; i++) {
          zIndexChildren[i].__struct.childIndex++;
        } // 向上添加parent的total数量


        struct.num++;
        struct.total += total;
        var p = this.__domParent;

        while (p) {
          struct = p.__struct;
          struct.total = struct.total || 0;
          struct.total += total;
          p = p.__domParent;
        }
      }
    }, {
      key: "__deleteStruct",
      value: function __deleteStruct(child, childIndex) {
        var cs = child.__struct;
        var total = (cs.total || 0) + 1;
        var root = this.__root,
            structs = root.__structs;
        var i = structs.indexOf(cs);
        structs.splice(i, total); // zIndexChildren后面的childIndex偏移

        var zIndexChildren = this.__zIndexChildren;

        for (var _i2 = childIndex + 1, len = zIndexChildren.length; _i2 < len; _i2++) {
          zIndexChildren[_i2].__struct.childIndex--;
        } // 向上减少parent的total数量


        var struct = this.__struct;
        struct.num--;
        struct.total = struct.total || 0;
        struct.total -= total;
        var p = this.__domParent;

        while (p) {
          struct = p.__struct;
          struct.total = struct.total || 0;
          struct.total -= total;
          p = p.__domParent;
        }
      }
      /**
       * 因为zIndex/abs/add的变化造成的更新，只需重排这一段顺序即可
       */

    }, {
      key: "__updateStruct",
      value: function __updateStruct() {
        var structs = this.__root.__structs;
        var struct = this.__struct;
        var total = struct.total || 0;
        var index = structs.indexOf(struct);
        var zIndexChildren = this.__zIndexChildren = genZIndexChildren(this);
        var length = zIndexChildren.length;

        if (length === 1) {
          return;
        }

        var needSort;
        zIndexChildren.forEach(function (child, i) {
          var cs = child.__struct;
          cs.childIndex = i; // 仅后面排序用
        }); // 按之前的structs划分为相同数量的若干段进行排序

        var source = [],
            count = 0;

        for (var i = index + 1; i <= index + total; i++) {
          var cs = structs[i];
          var o = {
            cs: cs,
            list: structs.slice(i, i + (cs.total || 0) + 1)
          };

          if (cs.childIndex !== count++) {
            needSort = true;
          }

          source.push(o);
          i += cs.total || 0;
        }

        if (needSort) {
          var list = [];
          source.sort(function (a, b) {
            return a.cs.childIndex - b.cs.childIndex;
          });
          source.forEach(function (item) {
            list = list.concat(item.list);
          });
          structs.splice.apply(structs, [index + 1, total].concat(_toConsumableArray(list)));
        }
      }
      /**
       * 给定父宽度情况下，尝试行内放下后的剩余宽度，为负数即放不下，这里只会出现行内级即inline(Block)
       * 调用前提是非行开头的inline尝试计算是否放得下，开头无需且禁止判断，防止出现永远放不下一个字符卡死
       * 返回非负数就是放得下，这样一些尺寸为0的也算
       * @param free 剩余宽度
       * @param total 容器尺寸
       * @param isUpright 垂直排版
       * @returns {number|*}
       * @private
       */

    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(free, total, isUpright) {
        this.__computeReflow();

        var flowChildren = this.flowChildren,
            _this$currentStyle = this.currentStyle,
            display = _this$currentStyle[DISPLAY$3],
            width = _this$currentStyle[WIDTH$2],
            height = _this$currentStyle[HEIGHT$2],
            marginLeft = _this$currentStyle[MARGIN_LEFT$1],
            marginRight = _this$currentStyle[MARGIN_RIGHT$1],
            marginTop = _this$currentStyle[MARGIN_TOP],
            marginBottom = _this$currentStyle[MARGIN_BOTTOM],
            paddingLeft = _this$currentStyle[PADDING_LEFT$1],
            paddingRight = _this$currentStyle[PADDING_RIGHT$1],
            paddingTop = _this$currentStyle[PADDING_TOP],
            paddingBottom = _this$currentStyle[PADDING_BOTTOM],
            _this$computedStyle = this.computedStyle,
            borderLeftWidth = _this$computedStyle[BORDER_LEFT_WIDTH$1],
            borderRightWidth = _this$computedStyle[BORDER_RIGHT_WIDTH$1],
            borderTopWidth = _this$computedStyle[BORDER_TOP_WIDTH],
            borderBottomWidth = _this$computedStyle[BORDER_BOTTOM_WIDTH]; // inline没w/h，并且尝试孩子第一个能放下即可，如果是文字就是第一个字符

        if (display === 'inline') {
          if (flowChildren.length) {
            var first = flowChildren[0];

            if (first instanceof Component) {
              first = first.shadowRoot;
            }

            if (first instanceof Xom) {
              free = first.__tryLayInline(free, total, isUpright);
            } else {
              free -= first.firstCharWidth;
            }
          }
        } // inlineBlock尝试所有孩子在一行上
        else {
          if (width.u !== AUTO$1) {
            free -= isUpright ? this.__calSize(height, total, true) : this.__calSize(width, total, true);
          } else {
            for (var i = 0; i < flowChildren.length; i++) {
              // 当放不下时直接返回，无需继续多余的尝试计算
              if (free < 0) {
                return free;
              }

              var item = flowChildren[i];

              if (item instanceof Component) {
                item = item.shadowRoot;
              }

              if (item instanceof Xom) {
                free = item.__tryLayInline(free, total, isUpright);
              } // text强制一行，否则非头就是放不下，需从头开始
              else {
                free -= item.textWidth;
              }
            }
          } // ib要减去末尾mpb


          if (isUpright) {
            free -= this.__calSize(marginBottom, total, true);
            free -= this.__calSize(paddingBottom, total, true);
            free -= borderBottomWidth;
          } else {
            free -= this.__calSize(marginRight, total, true);
            free -= this.__calSize(paddingRight, total, true);
            free -= borderRightWidth;
          }
        } // 还要减去开头的mpb


        if (isUpright) {
          free -= this.__calSize(marginTop, total, true);
          free -= this.__calSize(paddingTop, total, true);
          free -= borderTopWidth;
        } else {
          free -= this.__calSize(marginLeft, total, true);
          free -= this.__calSize(paddingLeft, total, true);
          free -= borderLeftWidth;
        }

        return free;
      } // 设置y偏移值，递归包括children，此举在justify-content/margin-auto等对齐用

    }, {
      key: "__offsetX",
      value: function __offsetX(diff, isLayout, lv) {
        _get(_getPrototypeOf(Dom.prototype), "__offsetX", this).call(this, diff, isLayout, lv);

        var ep = this.__ellipsis;

        if (ep) {
          ep.__offsetX(diff, isLayout);
        } // 记得偏移LineBox


        if (isLayout && !this.__isInline && this.lineBoxManager) {
          this.lineBoxManager.__offsetX(diff);
        }

        this.flowChildren.forEach(function (item) {
          if (item) {
            item.__offsetX(diff, isLayout, lv);
          }
        });
      }
    }, {
      key: "__offsetY",
      value: function __offsetY(diff, isLayout, lv) {
        if (this.computedStyle[DISPLAY$3] === 'none') {
          return;
        }

        _get(_getPrototypeOf(Dom.prototype), "__offsetY", this).call(this, diff, isLayout, lv);

        var ep = this.__ellipsis;

        if (ep) {
          ep.__offsetY(diff, isLayout);
        }

        if (isLayout && !this.__isInline && this.lineBoxManager) {
          this.lineBoxManager.__offsetY(diff);
        }

        this.flowChildren.forEach(function (item) {
          if (item) {
            item.__offsetY(diff, isLayout, lv);
          }
        });
      }
      /**
       * flex布局时，计算basis尺寸，如果有固定声明则以其为标准，content为内容最大尺寸，auto依赖w/h或降级content
       * basis要考虑相加直接item的mpb，非绝对值单位以container为基准，basis为内容时为max值
       * item的孩子为孙子节点需递归，不参与basis计算，只参与min/max，尺寸和mpb均只考虑绝对值
       * 自动计算时影响尺寸的只有换行的text，以及一组inline，均按其中最大尺寸的一个计算
       * auto自动计算递归进行，如果是普通row方向，按最大text的charWidth为准
       * 如果是column方向，则虚拟布局后看text的height
       * 在abs下时进入特殊状态，无论是row/column，都会按row方向尝试最大尺寸，直到舞台边缘或容器声明的w折行
       * 返回b，声明则按css值，否则是auto/content
       * 返回min为最小宽度，遇到字符/inline则单列排版后需要的最大宽度
       * 返回max为最大宽度，理想情况一排最大值，在abs时virtualMode状态参与计算，文本抵达边界才进行换行
       * 当为column方向时，特殊进行虚拟布局isVirtual，需要获取高度
       * @param isDirectionRow
       * @param isAbs
       * @param isColumn
       * @param data
       * @param isDirectChild
       * @private
       */

    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        var _this2 = this;

        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexDirection = currentStyle[FLEX_DIRECTION],
            flexBasis = currentStyle[FLEX_BASIS$1],
            width = currentStyle[WIDTH$2],
            height = currentStyle[HEIGHT$2];
        var lineHeight = computedStyle[LINE_HEIGHT],
            display = computedStyle[DISPLAY$3],
            lineClamp = computedStyle[LINE_CLAMP],
            writingMode = computedStyle[WRITING_MODE$1];
        var isUpright = writingMode.indexOf('vertical') === 0;
        var main = isDirectionRow ? width : height; // basis3种情况：auto、固定、content

        var isAuto = flexBasis.u === AUTO$1;
        var isFixed = [PX$2, PERCENT$1, REM$1, VW$1, VH$1, VMAX$1, VMIN$1].indexOf(flexBasis.u) > -1;
        var isContent = !isAuto && !isFixed;
        var fixedSize; // flex的item固定basis计算

        if (isFixed) {
          b = fixedSize = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } // 已声明主轴尺寸的，当basis是auto时为main值
        else if (isAuto && [PX$2, PERCENT$1, REM$1, VW$1, VH$1, VMAX$1, VMIN$1].indexOf(main.u) > -1) {
          b = fixedSize = this.__calSize(main, isDirectionRow ? w : h, true);
        } // 非固定尺寸的basis为auto时降级为content
        else if (isAuto) {
          isContent = true;
        }

        var countMin = 0,
            countMax = 0;
        lineClamp = lineClamp || 0; // row的flex时，child只需计算宽度的basis/min/max，递归下去也是如此，即便包含递归的flex

        if (isDirectionRow) {
          // flex的item还是flex时
          if (display === 'flex') {
            var isR = ['column', 'columnReverse'].indexOf(flexDirection) === -1;
            flowChildren = genOrderChildren(flowChildren);
            flowChildren.forEach(function (item) {
              if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
                var _item$__calBasis = item.__calBasis(isDirectionRow, isAbs, isColumn, {
                  x: x,
                  y: y,
                  w: w,
                  h: h
                }, false),
                    _item$__calBasis2 = _slicedToArray(_item$__calBasis, 3),
                    min2 = _item$__calBasis2[1],
                    max2 = _item$__calBasis2[2];

                if (isR) {
                  min += min2;
                  max += max2;
                } else {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                }
              } // text除了flex还需要分辨垂直排版
              else {
                if (isUpright) {
                  var lineBoxManager = _this2.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);

                  item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    isUpright: isUpright
                  });

                  min += item.width;
                  max += item.width;
                }

                if (isR) {
                  min += item.charWidth;
                  max += item.textWidth;
                } else {
                  min = Math.max(min, item.charWidth);
                  max = Math.max(max, item.textWidth);
                }
              }
            });
          } // 特殊的flex水平布局但书写垂直，遇到后直接假布局获取宽度，因为水平尺寸视为无限但垂直不是，
          // 这里一定是第一个垂直排版不会递归下去，因为flex的child匿名block，水平的垂直书写inline匿名ib
          else if (isUpright) {
            var lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);

            this.__layoutFlow({
              x: x,
              y: y,
              w: w,
              h: h,
              lineBoxManager: lineBoxManager,
              lineClamp: lineClamp,
              isUpright: isUpright
            }, isAbs, false, true);

            min = max = b = this.width;
          } // flex的item是block/inline时，inline也会变成block统一对待，递归下去会有inline出现，但row的水平size为无穷不会换行可以忽略
          else {
            var _lineBoxManager = data.lineBoxManager;

            if (display !== 'inline') {
              _lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);
            }

            flowChildren.forEach(function (item) {
              if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
                var _item$__calBasis3 = item.__calBasis(isDirectionRow, isAbs, isColumn, {
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lineBoxManager: _lineBoxManager
                }, false),
                    _item$__calBasis4 = _slicedToArray(_item$__calBasis3, 3),
                    min2 = _item$__calBasis4[1],
                    max2 = _item$__calBasis4[2];

                var _display = item.computedStyle[DISPLAY$3]; // row看块级最大尺寸和连续行级最大尺寸的宽

                if (_display === 'block' || _display === 'flex') {
                  min = Math.max(min, min2);
                  max = Math.max(max, max2);
                  countMin = countMax = 0;
                } else {
                  countMin += min2;
                  countMax += max2;
                  min = Math.max(min, countMin);
                  max = Math.max(max, countMax);
                }
              } else {
                countMin += item.charWidth;
                countMax += item.textWidth;
                min = Math.max(min, countMin);
                max = Math.max(max, countMax);
              }
            });
          }

          if (fixedSize) {
            max = Math.max(fixedSize, max);
          } // row降级为内容时basis等同于max


          if (isContent) {
            b = max;
          }
        } // column的flex时，每个child做一次虚拟布局，获取到每个child的高度和宽度
        else {
          this.__layoutFlow({
            x: x,
            y: y,
            w: w,
            h: h,
            isUpright: isUpright
          }, isAbs, true, false);

          min = max = b = this.height; // column的child，max和b总相等
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      } // flow的layout包裹方法，布局后递归计算computedStyle，abs节点在__layoutAbs中做

    }, {
      key: "__layout",
      value: function __layout(data, isAbs, isColumn, isRow) {
        _get(_getPrototypeOf(Dom.prototype), "__layout", this).call(this, data, isAbs, isColumn, isRow);

        this.__layoutStyle();
      } // 布局结束后递归向下计算computedStyle，父级必须先算因为有inherit

    }, {
      key: "__layoutStyle",
      value: function __layoutStyle() {
        _get(_getPrototypeOf(Dom.prototype), "__layoutStyle", this).call(this);

        this.flowChildren.forEach(function (child) {
          if (!(child instanceof Text)) {
            child.__layoutStyle();
          }
        });
      }
    }, {
      key: "__layoutNone",
      value: function __layoutNone() {
        _get(_getPrototypeOf(Dom.prototype), "__layoutNone", this).call(this);

        var children = this.children;
        children.forEach(function (item) {
          if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
            item.__layoutNone();
          }
        });
      }
      /**
       * block布局，本身固定尺寸优先，否则看内容从上往下从左往右flow流排布
       * 内部inline和inlineBlock组成LineBox，通过LineBoxManager来管理混排的现象
       * LineBoxManager只有block和inlineBlock内部生成，inline会复用最近父级的
       * 内部的block在垂直方向要考虑margin合并的问题，强制所有节点为bfc，精简逻辑
       * @param data
       * @param isAbs abs无尺寸时提前虚拟布局计算尺寸
       * @param isColumn flex列无尺寸时提前虚拟布局计算尺寸
       * @param isRow flex行布局时出现writingMode垂直排版计算尺寸
       */

    }, {
      key: "__layoutBlock",
      value: function __layoutBlock(data, isAbs, isColumn, isRow) {
        var _this3 = this;

        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var textAlign = computedStyle[TEXT_ALIGN],
            whiteSpace = computedStyle[WHITE_SPACE],
            lineClamp = computedStyle[LINE_CLAMP],
            lineHeight = computedStyle[LINE_HEIGHT],
            overflow = computedStyle[OVERFLOW$1];

        var _this$__preLayout = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout.fixedWidth,
            fixedHeight = _this$__preLayout.fixedHeight,
            x = _this$__preLayout.x,
            y = _this$__preLayout.y,
            w = _this$__preLayout.w,
            h = _this$__preLayout.h,
            isParentVertical = _this$__preLayout.isParentVertical,
            isUpright = _this$__preLayout.isUpright; // abs虚拟布局需预知width，固定可提前返回


        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return;
        }

        if (isColumn && fixedHeight) {
          this.__ioSize(undefined, h);

          return;
        }

        if (isRow && fixedWidth) {
          this.__ioSize(w, undefined);

          return;
        } // 只有>=1的正整数才有效


        lineClamp = lineClamp || 0;
        var lineClampCount = 0; // 虚线管理一个block内部的LineBox列表，使得inline的元素可以中途衔接处理折行
        // 内部维护inline结束的各种坐标来达到目的，遇到block时中断并处理换行坐标

        var lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright); // 因精度问题，统计宽度均从0开始累加每行，最后取最大值，仅在abs布局时isVirtual生效

        var maxSize = 0;
        var countSize = 0;
        var lx = x; // 行首，考虑了mbp

        var ly = y; // 连续block（flex相同，下面都是）的上下margin合并值记录，合并时从列表中取

        var mergeMarginEndList = [],
            mergeMarginStartList = [];
        var length = flowChildren.length;
        var ignoreNextLine; // lineClamp超过后，后面的均忽略并置none，注意block内部行数统计是跨子block的

        var ignoreNextWrap; // whiteSpace单行超过后，后面的均忽略并置none，注意这也是跨block的会被隔断重计

        flowChildren.forEach(function (item, i) {
          var isXom = item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom;

          if (isXom) {
            item.__computeReflow(); // writing-mode可能会造成inline改变为ib

          }

          var isInline = isXom && item.computedStyle[DISPLAY$3] === 'inline';
          var isInlineBlock = isXom && item.computedStyle[DISPLAY$3] === 'inlineBlock';

          var isRealInline = isInline && item.__isRealInline();

          var lastLineClampCount = lineClampCount; // 每次循环开始前，这次不是block的话，看之前遗留待合并margin，并重置

          if (!isXom || isInline || isInlineBlock) {
            if (mergeMarginEndList.length && mergeMarginStartList.length) {
              var diff = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList).diff;

              if (diff) {
                if (isUpright) {
                  x += diff;
                } else {
                  y += diff;
                }
              }
            }

            mergeMarginStartList = [];
            mergeMarginEndList = [];
          }

          if (isXom) {
            // inline和inlineBlock的细节不同之处，ib除了w/h之外，更想像block一样占据一行
            // 比如2个inline前面占一半后面比一半多但还是会从一半开始然后第2行换行继续，但ib放不下则重开一行
            // inline和ib能互相嵌套，形成的LineBox中则是TextBox和节点混合
            if (isInlineBlock || isInline) {
              if (ignoreNextLine || ignoreNextWrap) {
                item.__layoutNone();

                return;
              } // x开头或者nowrap单行的非block，不用考虑是否放得下直接放


              if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  // ib内部新生成会内部判断，这里不管统一传入
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // inlineBlock的特殊之处，一旦w为auto且内部产生折行时，整个变成block独占一块区域，坐标计算和block一样，注意nowrap排除

                if (item.__isIbFull) {
                  lineClampCount++;
                }

                if ((isUpright && item.__isUprightIbFull || !isUpright && item.__isIbFull) && whiteSpace !== 'nowrap') {
                  lineBoxManager.addItem(item, true);

                  if (isUpright) {
                    x += item.outerWidth;
                    y = ly;
                  } else {
                    x = lx;
                    y += item.outerHeight;
                  }

                  lineBoxManager.setNotEnd();
                } // inline和不折行的ib，其中ib需要手动存入当前lb中
                else {
                  (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;
                } // 单行时inline在ellipsis会导致行数变化，否则判断坐标尺寸(恰好有点空剩余inline排不下)，注意前提是非abs，其虚拟计算尺寸无视限制


                if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                  ignoreNextWrap = true;
                } else if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                } // abs统计宽度，注意nowrap时累加


                if (isAbs) {
                  if (whiteSpace === 'nowrap') {
                    countSize += isUpright ? item.outerHeight : item.outerWidth;
                  } else {
                    countSize = isUpright ? item.outerHeight : item.outerWidth;

                    if (lineClampCount > lastLineClampCount) {
                      countSize = Math.max(countSize, isUpright ? h : w);
                    }
                  }

                  maxSize = Math.max(maxSize, countSize);
                }
              } else {
                // 非开头先尝试是否放得下，内部判断了inline/ib，ib要考虑是否有width
                var free = item.__tryLayInline(isUpright ? h + ly - y : w + lx - x, isUpright ? h : w, isUpright); // 放得下继续，奇怪的精度问题，加上阈值


                if (free >= -1e-10) {
                  lineClampCount = item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lx: lx,
                    ly: ly,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    lineClampCount: lineClampCount,
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow); // ib放得下要么内部没有折行，要么声明了width限制，都需手动存入当前lb

                  (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;

                  if (lineClamp && lineClampCount >= lineClamp) {
                    ignoreNextLine = true;
                  }

                  if (isAbs) {
                    // ib和非换行inline累加
                    if (isInlineBlock || lineClampCount === lastLineClampCount) {
                      countSize += isUpright ? item.outerHeight : item.outerWidth;
                      maxSize = Math.max(maxSize, countSize);
                    } // inline换行时一定超过边界至少撑满w
                    else {
                      maxSize = Math.max(maxSize, isUpright ? h : w);
                      countSize = isUpright ? y - ly : x - lx;
                      maxSize = Math.max(maxSize, countSize);
                    }
                  }
                } // 放不下处理之前的lineBox，并考虑重新开头或截断
                else {
                  lineClampCount++;

                  if (isUpright) {
                    x = lineBoxManager.endX;
                    y = ly;
                  } else {
                    x = lx;
                    y = lineBoxManager.endY;
                  }

                  lineBoxManager.setNewLine(); // 超过行数，整个block共用计数器

                  if (lineClamp && lineClampCount >= lineClamp) {
                    item.__layoutNone();

                    ignoreNextLine = true;
                    var list = lineBoxManager.list;
                    var lineBox = list[list.length - 1];
                    backtrack(_this3, lineBoxManager, lineBox, isUpright ? h : w, 0, isUpright);
                    return;
                  }

                  lineClampCount = item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    lx: lx,
                    ly: ly,
                    lineBoxManager: lineBoxManager,
                    lineClamp: lineClamp,
                    lineClampCount: lineClampCount,
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow); // 重新开头的ib和上面开头处一样逻辑

                  if (item.__isIbFull || item.__isUprightIbFull) {
                    lineBoxManager.addItem(item, false);

                    if (isUpright) {
                      x += item.outerWidth;
                      y = ly;
                    } else {
                      x = lx;
                      y += item.outerHeight;
                    }

                    lineBoxManager.setNotEnd();
                    lineClampCount++;
                  } // inline和不折行的ib，其中ib需要手动存入当前lb中
                  else {
                    (isInlineBlock || !isRealInline) && lineBoxManager.addItem(item, false);
                    x = lineBoxManager.lastX;
                    y = lineBoxManager.lastY;
                  }

                  if (lineClamp && lineClampCount >= lineClamp) {
                    ignoreNextLine = true;
                  }

                  if (isAbs) {
                    maxSize = Math.max(maxSize, countSize); // 此处发生换行撑满

                    maxSize = Math.max(maxSize, isUpright ? h : w); // 新行重计

                    countSize = isUpright ? item.outerHeight : item.outerWidth;
                    maxSize = Math.max(maxSize, countSize);
                  }
                }
              }
            } // block/flex先处理之前可能遗留的最后一行LineBox，然后递归时不传lineBoxManager，其内部生成新的
            else {
              ignoreNextWrap = false; // block出现的话只隔断单行，不影响多行计数器
              // 非开头，说明之前的text/ib未换行，需要增加行数

              if (isUpright && y > ly || !isUpright && x > lx) {
                lineClampCount++;
              }

              if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }

              if (isUpright) {
                y = ly;
              } else {
                x = lx;
              }

              if (lineBoxManager.isEnd) {
                if (isUpright) {
                  x = lineBoxManager.endX;
                } else {
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNotEnd();
                lineBoxManager.setNewLine();
              }

              item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                isUpright: isUpright
              }, isAbs, isColumn, isRow); // 自身无内容


              var isNone = item.currentStyle[DISPLAY$3] === 'none';
              var isEmptyBlock;

              if (!isNone && item.flowChildren && item.flowChildren.length === 0) {
                var _item$computedStyle = item.computedStyle,
                    marginTop = _item$computedStyle[MARGIN_TOP],
                    marginRight = _item$computedStyle[MARGIN_RIGHT$1],
                    marginBottom = _item$computedStyle[MARGIN_BOTTOM],
                    marginLeft = _item$computedStyle[MARGIN_LEFT$1],
                    paddingTop = _item$computedStyle[PADDING_TOP],
                    paddingRight = _item$computedStyle[PADDING_RIGHT$1],
                    paddingBottom = _item$computedStyle[PADDING_BOTTOM],
                    paddingLeft = _item$computedStyle[PADDING_LEFT$1],
                    width = _item$computedStyle[WIDTH$2],
                    height = _item$computedStyle[HEIGHT$2],
                    borderTopWidth = _item$computedStyle[BORDER_TOP_WIDTH],
                    borderRightWidth = _item$computedStyle[BORDER_RIGHT_WIDTH$1],
                    borderBottomWidth = _item$computedStyle[BORDER_BOTTOM_WIDTH],
                    borderLeftWidth = _item$computedStyle[BORDER_LEFT_WIDTH$1]; // 无内容高度为0的空block特殊情况，记录2个margin下来等后续循环判断处理

                if (isUpright && paddingLeft <= 0 && paddingRight <= 0 && width <= 0 && borderLeftWidth <= 0 && borderRightWidth <= 0) {
                  mergeMarginEndList.push(marginRight);
                  mergeMarginStartList.push(marginLeft);
                  isEmptyBlock = true;
                } else if (!isUpright && paddingTop <= 0 && paddingBottom <= 0 && height <= 0 && borderTopWidth <= 0 && borderBottomWidth <= 0) {
                  mergeMarginEndList.push(marginBottom);
                  mergeMarginStartList.push(marginTop);
                  isEmptyBlock = true;
                }
              }

              if (isUpright) {
                x += item.outerWidth;
                lineBoxManager.__lastX = x;
              } else {
                y += item.outerHeight;
                lineBoxManager.__lastY = y;
              } // absolute/flex前置虚拟计算


              if (isAbs) {
                maxSize = Math.max(maxSize, isUpright ? item.outerHeight : item.outerWidth);
                countSize = 0;
              } // 空block要留下轮循环看，除非是最后一个，此处非空本轮处理掉看是否要合并


              if (!isNone && !isEmptyBlock) {
                var _item$computedStyle2 = item.computedStyle,
                    _marginTop = _item$computedStyle2[MARGIN_TOP],
                    _marginRight = _item$computedStyle2[MARGIN_RIGHT$1],
                    _marginBottom = _item$computedStyle2[MARGIN_BOTTOM],
                    _marginLeft = _item$computedStyle2[MARGIN_LEFT$1]; // 有bottom值说明之前有紧邻的block，任意个甚至空block，自己有个top所以无需判断top
                // 如果是只有紧邻的2个非空block，也被包含在情况内，取上下各1合并

                if (mergeMarginEndList.length) {
                  if (isUpright) {
                    mergeMarginStartList.push(_marginLeft);
                    var _diff = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList).diff;

                    if (_diff) {
                      item.__offsetX(_diff, true, null);

                      x += _diff;
                    }
                  } else {
                    mergeMarginStartList.push(_marginTop);
                    var _diff2 = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList).diff;

                    if (_diff2) {
                      item.__offsetY(_diff2, true, null);

                      y += _diff2;
                    }
                  }
                } // 同时自己保存bottom，为后续block准备


                mergeMarginStartList = [];
                mergeMarginEndList = [isUpright ? _marginRight : _marginBottom];
              } // 最后一个空block当是正正和负负时要处理，正负在outHeight处理了结果是0
              else if (i === length - 1) {
                var _diff3 = reflow.getMergeMargin(mergeMarginStartList, mergeMarginEndList).diff;

                if (_diff3) {
                  if (isUpright) {
                    x += _diff3;
                  } else {
                    y += _diff3;
                  }
                }
              }
            }
          } // 文字和inline类似
          else {
            if (ignoreNextLine || ignoreNextWrap) {
              item.__layoutNone();

              return;
            } // x开头，不用考虑是否放得下直接放


            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              });
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY; // 和inline很像，只是没有ib

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              } // abs统计宽度，注意nowrap时累加


              if (isAbs) {
                if (whiteSpace === 'nowrap') {
                  countSize += isUpright ? item.height : item.width;
                } else {
                  countSize = isUpright ? item.height : item.width;

                  if (lineClampCount > lastLineClampCount) {
                    countSize = Math.max(countSize, isUpright ? h : w);
                  }
                }

                maxSize = Math.max(maxSize, countSize);
              }
            } else {
              // 非开头先尝试是否放得下
              var _free = item.__tryLayInline(isUpright ? h + ly - y : w + lx - x); // 放得下继续


              if (_free >= -1e-10) {
                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                });
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }

                if (isAbs) {
                  if (lineClampCount === lastLineClampCount) {
                    countSize += isUpright ? item.height : item.width;
                    maxSize = Math.max(maxSize, countSize);
                  } // inline换行一定超过边界
                  else {
                    maxSize = Math.max(maxSize, isUpright ? h : w);
                    countSize = isUpright ? y - ly : x - lx;
                    maxSize = Math.max(maxSize, countSize);
                  }
                }
              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 和inline/ib一样

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var _list = lineBoxManager.list;
                  var _lineBox = _list[_list.length - 1];
                  backtrack(_this3, lineBoxManager, _lineBox, isUpright ? h : w, 0, isUpright);
                  return;
                }

                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                });
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }

                if (isAbs) {
                  maxSize = Math.max(maxSize, countSize); // 此处发生换行撑满

                  maxSize = Math.max(maxSize, isUpright ? h : w); // 新行重计

                  countSize = isUpright ? item.height : item.width;
                  maxSize = Math.max(maxSize, countSize);
                }
              }
            }
          }
        }); // 结束后如果是以LineBox结尾，则需要设置y到这里，否则流布局中block会设置
        // 当以block换行时，新行是true，否则是false即结尾

        if (lineBoxManager.isEnd) {
          if (isUpright) {
            x = lineBoxManager.endX;
          } else {
            y = lineBoxManager.endY;
          }
        }

        var tw = 0,
            th = 0; // 根据书写模式、嵌套等条件计算宽高，只有父子同向才会主轴撑满

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        } else if (isAbs) {
          tw = isUpright ? x - data.x : maxSize;
        } else {
          tw = x - data.x;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        } else if (isAbs) {
          th = isUpright ? maxSize : y - data.y;
        } else {
          th = y - data.y;
        }

        this.__ioSize(tw, th); // 除了水平abs的虚拟外，都需要垂直对齐，因为img这种占位元素会影响lineBox高度，水平abs虚拟只需宽度


        if (!isAbs) {
          var spread = lineBoxManager.verticalAlign(isUpright);

          if (spread) {
            if (isUpright && !fixedWidth) {
              this.__resizeX(spread, null);
            } else if (!isUpright && !fixedHeight) {
              this.__resizeY(spread, null);
            }
            /**
             * parent以及parent的next无需处理，因为深度遍历后面还会进行，
             * 但自己的block需处理，因为对齐只处理了inline元素，忽略了block，
             * 同时由于block和inline区域可能不连续，每个增加的y不一样，
             * 需要按照每个不同区域来判断，区域是按索引次序依次增大的，
             * 只有在inline出现过后才开始生效，inline之前的block忽略
             */


            var count = 0,
                spreadList = lineBoxManager.spreadList;
            var isLastBlock = false,
                hasStart = false;
            flowChildren.forEach(function (item) {
              var isXom = item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom;
              var isBlock = isXom && ['block', 'flex'].indexOf(item.computedStyle[DISPLAY$3]) > -1;

              if (isBlock) {
                if (!hasStart) {
                  return;
                }

                isLastBlock = true;

                if (isUpright) {
                  item.__offsetX(spreadList[count], true, null);
                } else {
                  item.__offsetY(spreadList[count], true, null);
                }
              } else {
                hasStart = true;

                if (isLastBlock) {
                  count++;
                }

                isLastBlock = false;
              }
            });
          } // 非abs提前的虚拟布局，真实布局情况下最后为所有行内元素进行2个方向上的对齐


          if (!isColumn && !isRow) {
            if (['center', 'right'].indexOf(textAlign) > -1) {
              lineBoxManager.horizonAlign(isUpright ? th : tw, textAlign, isUpright); // 直接text需计算size

              flowChildren.forEach(function (item) {
                if (item instanceof Component) {
                  item = item.shadowRoot;
                }

                if (item instanceof Text) {
                  item.__inlineSize(isUpright);
                }
              });
            } // 所有inline计算size


            lineBoxManager.domList.forEach(function (item) {
              item.__inlineSize(isUpright ? th : tw, textAlign, isUpright);
            });

            this.__marginAuto(currentStyle, data, isUpright);
          }
        }
      } // 弹性布局时的计算位置

    }, {
      key: "__layoutFlex",
      value: function __layoutFlex(data, isAbs, isColumn, isRow) {
        var _this4 = this;

        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            __flexLine = this.__flexLine;
        var flexDirection = computedStyle[FLEX_DIRECTION],
            justifyContent = computedStyle[JUSTIFY_CONTENT],
            alignItems = computedStyle[ALIGN_ITEMS],
            lineClamp = computedStyle[LINE_CLAMP],
            flexWrap = computedStyle[FLEX_WRAP],
            alignContent = computedStyle[ALIGN_CONTENT],
            lineHeight = computedStyle[LINE_HEIGHT],
            textAlign = computedStyle[TEXT_ALIGN];

        var _this$__preLayout2 = this.__preLayout(data, false),
            fixedWidth = _this$__preLayout2.fixedWidth,
            fixedHeight = _this$__preLayout2.fixedHeight,
            x = _this$__preLayout2.x,
            y = _this$__preLayout2.y,
            w = _this$__preLayout2.w,
            h = _this$__preLayout2.h,
            isParentVertical = _this$__preLayout2.isParentVertical,
            isUpright = _this$__preLayout2.isUpright;

        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return;
        }

        if (isColumn && fixedHeight) {
          this.__ioSize(undefined, h);

          return;
        }

        if (isRow && fixedWidth) {
          this.__ioSize(w, undefined);

          return;
        } // 每次布局情况多行内容


        __flexLine.splice(0); // 只有>=1的正整数才有效


        lineClamp = lineClamp || 0;
        var lineClampCount = 0;
        var isDirectionRow = ['column', 'columnReverse'].indexOf(flexDirection) === -1; // 计算伸缩基数

        var growList = [];
        var shrinkList = [];
        var basisList = [];
        var maxList = [];
        var minList = [];
        var orderChildren = genOrderChildren(flowChildren);
        orderChildren.forEach(function (item) {
          if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
            var _currentStyle = item.currentStyle,
                _computedStyle = item.computedStyle;

            var _item$__calBasis5 = item.__calBasis(isDirectionRow, isAbs, isColumn, {
              x: x,
              y: y,
              w: w,
              h: h
            }, true),
                _item$__calBasis6 = _slicedToArray(_item$__calBasis5, 3),
                b = _item$__calBasis6[0],
                min = _item$__calBasis6[1],
                max = _item$__calBasis6[2];

            var flexGrow = _currentStyle[FLEX_GROW],
                flexShrink = _currentStyle[FLEX_SHRINK];
            _computedStyle[FLEX_BASIS$1] = b;
            growList.push(flexGrow);
            shrinkList.push(flexShrink); // 根据basis不同，计算方式不同

            basisList.push(b);
            maxList.push(max);
            minList.push(min);
          } // 文本
          else {
            growList.push(0);
            shrinkList.push(1); // 水平flex垂直文字和垂直flex水平文字都先假布局一次取结果，其它取文本最大最小宽度即可

            if (isDirectionRow && isUpright || !isDirectionRow && !isUpright) {
              var lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);

              item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                lineBoxManager: lineBoxManager,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow);

              var n = isUpright ? item.width : item.height;
              basisList.push(n);
              maxList.push(n);
              minList.push(n);
            } // 水平flex水平文本和垂直flex垂直文本
            else {
              var cw = item.charWidth;
              var _tw = item.textWidth;
              basisList.push(_tw);
              maxList.push(_tw);
              minList.push(cw);
            }
          }
        });
        var containerSize = isDirectionRow ? w : h;
        var isMultiLine = ['wrap', 'wrapReverse'].indexOf(flexWrap) > -1;
        /**
         * 判断是否需要分行，根据假设主尺寸来统计尺寸和计算，假设主尺寸是clamp(min_main_size, flex_base_size, max_main_size)
         * 当多行时，由于每行一定有最小限制，所以每行一般情况都不是shrink状态，
         * 但也有极端情况，比如一行只能放下1个元素时，且此元素比容器小，会是shrink
         */

        var line = [],
            sum = 0,
            hypotheticalList = [];
        basisList.forEach(function (item, i) {
          var min = minList[i],
              max = maxList[i];
          var hypothetical;

          if (item < min) {
            hypothetical = min;
          } else if (item > max) {
            hypothetical = max;
          } else {
            hypothetical = item;
          }

          hypotheticalList.push(hypothetical);

          if (isMultiLine) {
            // 超过尺寸时，要防止sum为0即1个也会超过尺寸
            if (sum + hypothetical > containerSize) {
              if (sum) {
                __flexLine.push(line);

                line = [orderChildren[i]];
                sum = hypothetical;
              } else {
                line.push(orderChildren[i]);

                __flexLine.push(line);

                line = [];
                sum = 0;
              }
            } else {
              line.push(orderChildren[i]);
              sum += hypothetical;
            }
          } else {
            line.push(orderChildren[i]);
          }
        });

        if (line.length) {
          __flexLine.push(line);
        }

        var offset = 0,
            clone = {
          x: x,
          y: y,
          w: w,
          h: h
        };
        var maxCrossList = [],
            marginAutoCountList = [],
            freeList = [];

        __flexLine.forEach(function (item) {
          var length = item.length;
          var end = offset + length;

          var _this4$__layoutFlexLi = _this4.__layoutFlexLine(clone, isDirectionRow, isAbs, isColumn, isRow, isUpright, containerSize, fixedWidth, fixedHeight, lineClamp, lineClampCount, lineHeight, computedStyle, justifyContent, alignItems, orderChildren.slice(offset, end), item, textAlign, growList.slice(offset, end), shrinkList.slice(offset, end), basisList.slice(offset, end), hypotheticalList.slice(offset, end), minList.slice(offset, end), maxList.slice(offset, end)),
              _this4$__layoutFlexLi2 = _slicedToArray(_this4$__layoutFlexLi, 5),
              x1 = _this4$__layoutFlexLi2[0],
              y1 = _this4$__layoutFlexLi2[1],
              maxCross = _this4$__layoutFlexLi2[2],
              marginAutoCount = _this4$__layoutFlexLi2[3],
              free = _this4$__layoutFlexLi2[4]; // 下一行/列更新坐标


          if (isDirectionRow) {
            clone.y = y1;
          } else {
            clone.x = x1;
          }

          x = Math.max(x, x1);
          y = Math.max(y, y1);
          maxCrossList.push(maxCross);
          marginAutoCountList.push(marginAutoCount);
          freeList.push(free);
          offset += length;
        }); // abs预布局只计算宽度无需对齐


        if (isAbs) {
          var max = 0;

          __flexLine.forEach(function (line) {
            var count = 0;
            line.forEach(function (item) {
              if (isDirectionRow) {
                count += isUpright ? item.outerHeight : item.outerWidth;
              } else {
                count = Math.max(count, isUpright ? item.outerHeight : item.outerWidth);
              } // 文字发生换行无论row/column一定放不下需占满容器尺寸


              if (item instanceof Text) {
                if (isUpright) {
                  if (item.textWidth > h) {
                    max = Math.max(max, h);
                  }
                } else {
                  if (item.textWidth > w) {
                    max = Math.max(max, w);
                  }
                }
              }
            });
            max = Math.max(max, count);
          });

          if (isUpright) {
            this.__ioSize(undefined, max);
          } else {
            this.__ioSize(max, undefined);
          }

          return;
        } // 同block计算


        var tw = 0,
            th = 0;

        if (fixedWidth || !isAbs && !isParentVertical && !isUpright) {
          tw = w;
        } else {
          tw = x - data.x;
        }

        if (fixedHeight || !isAbs && isParentVertical && isUpright) {
          th = h;
        } else {
          th = y - data.y;
        }

        this.__ioSize(tw, th);

        if (isColumn || isRow) {
          return;
        } // flexDirection当有reverse时交换每line的主轴序


        if (flexDirection === 'rowReverse') {
          __flexLine.forEach(function (line) {
            line.forEach(function (item) {
              // 一个矩形内的子矩形进行镜像移动，用外w减去内w再减去开头空白的2倍即可
              var diff = tw - item.outerWidth - (item.x - data.x) * 2;

              if (diff) {
                item.__offsetX(diff, true, null);
              }
            });
          });
        } else if (flexDirection === 'columnReverse') {
          __flexLine.forEach(function (line) {
            line.forEach(function (item) {
              // 一个矩形内的子矩形进行镜像移动，用外w减去内w再减去开头空白的2倍即可
              var diff = th - item.outerHeight - (item.y - data.y) * 2;

              if (diff) {
                item.__offsetY(diff, true, null);
              }
            });
          });
        } // wrap-reverse且多轴线时交换轴线序，需要2行及以上才行


        var length = __flexLine.length;

        if (flexWrap === 'wrapReverse' && length > 1) {
          var crossSum = 0,
              crossSumList = [];
          maxCrossList.forEach(function (item) {
            crossSumList.push(crossSum);
            crossSum += item;
          });
          var count = 0;

          var _loop = function _loop(i) {
            var line = __flexLine[i];
            var source = crossSumList[i];
            var diff = count - source;

            if (diff) {
              line.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(diff, true, null);
                } else {
                  item.__offsetX(diff, true, null);
                }
              });
            }

            count += maxCrossList[i];
          };

          for (var i = length - 1; i >= 0; i--) {
            _loop(i);
          }

          __flexLine.reverse();
        } // 侧轴对齐分flexLine做，要考虑整体的alignContent的stretch和每行的alignItems的stretch
        // 先做整体的，得出交叉轴空白再均分给每一行做单行的，整体的只有1行忽略


        var per;

        if (length > 1 && (fixedHeight && isDirectionRow || !isDirectionRow)) {
          var diff = isDirectionRow ? th - (y - data.y) : tw - (x - data.x); // 有空余时才进行对齐

          if (diff > 0) {
            if (alignContent === 'center') {
              var _per = diff * 0.5;

              orderChildren.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(_per, true, null);
                } else {
                  item.__offsetX(_per, true, null);
                }
              });
            } else if (alignContent === 'flexStart') ; else if (alignContent === 'flexEnd') {
              orderChildren.forEach(function (item) {
                if (isDirectionRow) {
                  item.__offsetY(diff, true, null);
                } else {
                  item.__offsetX(diff, true, null);
                }
              });
            } else if (alignContent === 'spaceBetween') {
              var between = diff / (length - 1); // 除了第1行其它进行偏移

              __flexLine.forEach(function (item, i) {
                if (i) {
                  item.forEach(function (item) {
                    if (isDirectionRow) {
                      item.__offsetY(between, true, null);
                    } else {
                      item.__offsetX(between, true, null);
                    }
                  });
                }
              });
            } else if (alignContent === 'spaceAround') {
              var around = diff / (length + 1);

              __flexLine.forEach(function (item, i) {
                item.forEach(function (item) {
                  if (isDirectionRow) {
                    item.__offsetY(around * (i + 1), true, null);
                  } else {
                    item.__offsetX(around * (i + 1), true, null);
                  }
                });
              });
            } // 默认stretch，每个flexLine进行扩充
            else {
              per = diff / length; // 因为每行都cross扩充了per，所有除了第1行其它进行偏移

              __flexLine.forEach(function (item, i) {
                if (i) {
                  item.forEach(function (item) {
                    if (isDirectionRow) {
                      item.__offsetY(per * i, true, null);
                    } else {
                      item.__offsetX(per * i, true, null);
                    }
                  });
                }
              });
            }
          }
        } // 每行再进行main/cross对齐，在alignContent为stretch时计算每行的高度


        if (!isColumn && !isRow) {
          if (length > 1) {
            __flexLine.forEach(function (item, i) {
              var maxCross = maxCrossList[i];

              if (per) {
                maxCross += per;
              }

              _this4.__flexAlign(item, alignItems, justifyContent, isDirectionRow, maxCross, marginAutoCountList[i], freeList[i]);
            });
          } else if (length) {
            var maxCross = isDirectionRow ? th : tw;

            this.__flexAlign(__flexLine[0], alignItems, justifyContent, isDirectionRow, maxCross, marginAutoCountList[0], freeList[0]);
          }

          this.__marginAuto(currentStyle, data, isUpright);
        }
      }
      /**
       * 计算获取子元素的b/min/max完毕后，尝试进行flex每行布局
       * https://www.w3.org/TR/css-flexbox-1/#layout-algorithm
       * 假想主尺寸，其为clamp(min_main_size, flex_base_size, max_main_size)
       * 随后按算法一步步来 https://zhuanlan.zhihu.com/p/354567655
       * 规范没提到mpb，item的要计算，孙子的只考虑绝对值
       * 先收集basis和假设主尺寸
       */

    }, {
      key: "__layoutFlexLine",
      value: function __layoutFlexLine(data, isDirectionRow, isAbs, isColumn, isRow, isUpright, containerSize, fixedWidth, fixedHeight, lineClamp, lineClampCount, lineHeight, computedStyle, justifyContent, alignItems, orderChildren, flexLine, textAlign, growList, shrinkList, basisList, hypotheticalList, minList, maxList) {
        var _this5 = this;

        var x = data.x,
            y = data.y,
            w = data.w,
            h = data.h;
        var hypotheticalSum = 0;
        hypotheticalList.forEach(function (item) {
          hypotheticalSum += item;
        }); // 根据假设尺寸确定使用grow还是shrink，冻结非弹性项并设置target尺寸，确定剩余未冻结数量

        var isOverflow = hypotheticalSum >= containerSize;
        var targetMainList = [];
        basisList.forEach(function (item, i) {
          if (isOverflow) {
            if (!shrinkList[i] || basisList[i] < hypotheticalList[i]) {
              targetMainList[i] = hypotheticalList[i];
            }
          } else {
            if (!growList[i] || basisList[i] > hypotheticalList[i]) {
              targetMainList[i] = hypotheticalList[i];
            }
          }
        }); // 初始可用空间，冻结使用确定的target尺寸，未冻结使用假想

        var free = 0;
        basisList.forEach(function (item, i) {
          if (targetMainList[i] !== undefined) {
            free += targetMainList[i];
          } else {
            free += item;
          }
        });
        var total = Infinity;

        if (isDirectionRow) {
          total = w;
        } else if (fixedHeight) {
          total = h;
        } else {
          total = free;
        }

        free = Math.abs(total - free); // 压缩也使用正值

        var lessOne = 0; // 循环，文档算法不够简练，其合并了grow和shrink，实际拆开写更简单

        var factorSum = 0;

        if (isOverflow) {
          (function () {
            // 计算真正的因子占比，同时得出缩小尺寸数值
            // 还需判断每个item收缩不能<min值，小于的话将无法缩小的这部分按比例分配到其它几项上
            // 于是写成一个循环，每轮先处理一遍，如果产生收缩超限的情况，将超限的设为最小值并剔除
            // 剩下的重新分配因子占比继续从头循环重来一遍
            var factorList = shrinkList.map(function (item, i) {
              if (targetMainList[i] === undefined) {
                // 冻结项的目标主尺寸有值，因子无值或为0
                factorSum += item;
                return item;
              }
            });

            while (true) {
              // 都冻结了
              if (factorSum === 0) {
                break;
              }

              if (factorSum < 1) {
                lessOne += free * (1 - factorSum);
                free *= factorSum;
              }

              var needReset = void 0,
                  factorSum2 = 0,
                  count1 = 0,
                  count2 = 0;
              factorList.forEach(function (item, i) {
                if (item) {
                  var r = item / factorSum;
                  var s = r * free; // 需要收缩的尺寸

                  var n = basisList[i] - s; // 实际尺寸
                  // 比min还小设置为min，同时设0冻结剔除

                  if (n < minList[i]) {
                    targetMainList[i] = minList[i];
                    factorList[i] = 0;
                    needReset = true;
                    count1 += basisList[i] - minList[i]; // 超出的尺寸也要减去实际收缩的尺寸，最终从free里减去
                  } // else if(n > maxList[i]) {
                  //   targetMainList[i] = maxList[i];
                  //   factorList[i] = 0;
                  //   needReset = true;
                  //   count1 += maxList[i];
                  // }
                  // 先按照没有超限的设置，正常情况直接跳出，如果有超限，记录sum2给下轮赋值重新计算
                  else {
                    targetMainList[i] = n;
                    factorSum2 += item;
                    count2 += n;
                  }
                }
              });

              if (!needReset) {
                free -= count2;
                break;
              }

              free -= count1;
              factorSum = factorSum2;
            }
          })();
        } else {
          (function () {
            var factorList = growList.map(function (item, i) {
              if (targetMainList[i] === undefined) {
                factorSum += item;
                return item;
              }
            });

            while (true) {
              if (factorSum === 0) {
                break;
              }

              if (factorSum < 1) {
                lessOne += free * (1 - factorSum);
                free *= factorSum;
              }

              var needReset = void 0,
                  factorSum2 = 0,
                  count1 = 0,
                  count2 = 0;
              factorList.forEach(function (item, i) {
                if (item) {
                  var r = item / factorSum;
                  var s = r * free; // 需要扩展的尺寸

                  var n = basisList[i] + s; // 实际尺寸
                  // 比min还小设置为min，同时设0剔除

                  if (n < minList[i]) {
                    targetMainList[i] = minList[i];
                    factorList[i] = 0;
                    needReset = true;
                    count1 += basisList[i] - minList[i];
                  } // else if(n > maxList[i]) {
                  //   targetMainList[i] = maxList[i];
                  //   factorList[i] = 0;
                  //   needReset = true;
                  //   count1 += maxList[i];
                  // }
                  // 先按照没有超限的设置，正常情况直接跳出，如果有超限，记录sum2给下轮赋值重新计算
                  else {
                    targetMainList[i] = n;
                    factorSum2 += item;
                    count2 += n;
                  }
                }
              });

              if (!needReset) {
                free -= count2;
                break;
              }

              free -= count1;
              factorSum = factorSum2;
            }
          })();
        }

        var maxCross = 0;
        var lbmList = [];
        var marginAutoCount = 0;
        orderChildren.forEach(function (item, i) {
          var main = targetMainList[i];

          if (item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom) {
            if (isDirectionRow) {
              item.__layoutFlow({
                x: x,
                y: y,
                w: main,
                h: h,
                w3: main,
                // w3假设固定宽度，忽略原始style中的设置
                isUpright: isUpright
              }, isAbs, isColumn, isRow);
            } else {
              var _item$currentStyle = item.currentStyle,
                  alignSelf = _item$currentStyle[ALIGN_SELF],
                  width = _item$currentStyle[WIDTH$2]; // column的child真布局时，如果是stretch宽度，则可以直接生成animateRecord，否则自适应调整后才进行

              if (!isAbs && !isColumn && !isRow) {
                var needGenAr;

                if (width.u !== AUTO$1 || alignSelf === 'stretch') {
                  needGenAr = true;
                } else if (alignSelf === 'auto' && alignItems === 'stretch') {
                  needGenAr = true;
                }

                if (needGenAr) {
                  item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow);
                } else {
                  item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, true, isColumn, isRow);

                  item.__layoutFlow({
                    x: x,
                    y: y,
                    w: w,
                    w3: item.outerWidth,
                    h: main,
                    h3: main,
                    // 同w2
                    isUpright: isUpright
                  }, isAbs, isColumn, isRow);
                }
              } else {
                item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: main,
                  h3: main,
                  // 同w2
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
              }
            } // 记录主轴是否有margin为auto的情况


            if (!isAbs && !isColumn && !isRow) {
              var currentStyle = item.currentStyle;

              if (isDirectionRow) {
                if (currentStyle[MARGIN_LEFT$1].u === AUTO$1) {
                  marginAutoCount++;
                }

                if (currentStyle[MARGIN_RIGHT$1].u === AUTO$1) {
                  marginAutoCount++;
                }
              } else {
                if (currentStyle[MARGIN_TOP].u === AUTO$1) {
                  marginAutoCount++;
                }

                if (currentStyle[MARGIN_BOTTOM].u === AUTO$1) {
                  marginAutoCount++;
                }
              }
            }
          } // 文字
          else {
            var lineBoxManager = _this5.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);
            lbmList.push(lineBoxManager);

            item.__layoutFlow({
              x: x,
              y: y,
              w: isDirectionRow ? main : w,
              h: isDirectionRow ? h : main,
              lineBoxManager: lineBoxManager,
              lineClamp: lineClamp,
              lineClampCount: lineClampCount,
              isUpright: isUpright
            });
          }

          if (isDirectionRow) {
            x += item.outerWidth;
            maxCross = Math.max(maxCross, item.outerHeight);
          } else {
            y += item.outerHeight;
            maxCross = Math.max(maxCross, item.outerWidth);
          }
        });

        if (isDirectionRow) {
          y += maxCross;
        } else {
          x += maxCross;
        } // flex的直接text对齐比较特殊


        if (!isAbs && !isColumn && !isRow && ['center', 'right'].indexOf(textAlign) > -1) {
          lbmList.forEach(function (item) {
            item.horizonAlign(isUpright ? item.height : item.width, textAlign, isUpright);
          });
        }

        return [x, y, maxCross, marginAutoCount, isOverflow ? 0 : Math.max(0, free + lessOne)];
      } // 每个flexLine的主轴侧轴对齐

    }, {
      key: "__flexAlign",
      value: function __flexAlign(line, alignItems, justifyContent, isDirectionRow, maxCross, marginAutoCount, free) {
        var baseline = 0;
        line.forEach(function (item) {
          baseline = Math.max(baseline, item.firstBaseline);
        }); // 先主轴对齐方式，需要考虑margin，如果有auto则优先于justifyContent

        var len = line.length;

        if (marginAutoCount) {
          // 类似于space-between，空白均分于auto，两边都有就是2份，只有1边是1份
          var count = 0,
              per = free / marginAutoCount;

          for (var i = 0; i < len; i++) {
            var child = line[i];
            var currentStyle = child.currentStyle;

            if (isDirectionRow) {
              if (currentStyle[MARGIN_LEFT$1].u === AUTO$1) {
                count += per;

                child.__offsetX(count, true, null);
              } else if (count) {
                child.__offsetX(count, true, null);
              }

              if (currentStyle[MARGIN_RIGHT$1].u === AUTO$1) {
                count += per;
              }
            } else {
              if (currentStyle[MARGIN_TOP].u === AUTO$1) {
                count += per;

                child.__offsetY(count, true, null);
              } else if (count) {
                child.__offsetY(count, true, null);
              }

              if (currentStyle[MARGIN_BOTTOM].u === AUTO$1) {
                count += per;
              }
            }
          }
        } else {
          if (justifyContent === 'flexEnd') {
            for (var _i3 = 0; _i3 < len; _i3++) {
              var _child = line[_i3];
              isDirectionRow ? _child.__offsetX(free, true, null) : _child.__offsetY(free, true, null);
            }
          } else if (justifyContent === 'center') {
            var center = free * 0.5;

            for (var _i4 = 0; _i4 < len; _i4++) {
              var _child2 = line[_i4];
              isDirectionRow ? _child2.__offsetX(center, true, null) : _child2.__offsetY(center, true, null);
            }
          } else if (justifyContent === 'spaceBetween') {
            var between = free / (len - 1);

            for (var _i5 = 1; _i5 < len; _i5++) {
              var _child3 = line[_i5];
              isDirectionRow ? _child3.__offsetX(between * _i5, true, null) : _child3.__offsetY(between * _i5, true, null);
            }
          } else if (justifyContent === 'spaceAround') {
            var around = free * 0.5 / len;

            for (var _i6 = 0; _i6 < len; _i6++) {
              var _child4 = line[_i6];
              isDirectionRow ? _child4.__offsetX(around * (_i6 * 2 + 1), true, null) : _child4.__offsetY(around * (_i6 * 2 + 1), true, null);
            }
          } else if (justifyContent === 'spaceEvenly') {
            var _around = free / (len + 1);

            for (var _i7 = 0; _i7 < len; _i7++) {
              var _child5 = line[_i7];
              isDirectionRow ? _child5.__offsetX(_around * (_i7 + 1), true, null) : _child5.__offsetY(_around * (_i7 + 1), true, null);
            }
          }
        } // 再侧轴


        line.forEach(function (item) {
          var alignSelf = item.currentStyle[ALIGN_SELF];

          if (isDirectionRow) {
            if (alignSelf === 'flexStart') ; else if (alignSelf === 'flexEnd') {
              var diff = maxCross - item.outerHeight;

              if (diff !== 0) {
                item.__offsetY(diff, true, null);
              }
            } else if (alignSelf === 'center') {
              var _diff4 = maxCross - item.outerHeight;

              if (_diff4 !== 0) {
                item.__offsetY(_diff4 * 0.5, true, null);
              }
            } else if (alignSelf === 'stretch') {
              var computedStyle = item.computedStyle,
                  height = item.currentStyle[HEIGHT$2];
              var borderTopWidth = computedStyle[BORDER_TOP_WIDTH],
                  borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH],
                  marginTop = computedStyle[MARGIN_TOP],
                  marginBottom = computedStyle[MARGIN_BOTTOM],
                  paddingTop = computedStyle[PADDING_TOP],
                  paddingBottom = computedStyle[PADDING_BOTTOM];

              if (height.u === AUTO$1) {
                var old = item.height;
                var v = item.__height = computedStyle[HEIGHT$2] = maxCross - marginTop - marginBottom - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth;
                var d = v - old;
                item.__sy4 += d;
                item.__sy5 += d;
                item.__sy6 += d;
                item.__height += d;
                item.__clientHeight += d;
                item.__offsetHeight += d;
                item.__outerHeight += d;
              }
            } else if (alignSelf === 'baseline') {
              var _diff5 = baseline - item.firstBaseline;

              if (_diff5 !== 0) {
                item.__offsetY(_diff5, true, null);
              }
            } // 默认auto，取alignItems
            else {
              if (alignItems === 'flexStart') ; else if (alignItems === 'center') {
                var _diff6 = maxCross - item.outerHeight;

                if (_diff6 !== 0) {
                  item.__offsetY(_diff6 * 0.5, true, null);
                }
              } else if (alignItems === 'flexEnd') {
                var _diff7 = maxCross - item.outerHeight;

                if (_diff7 !== 0) {
                  item.__offsetY(_diff7, true, null);
                }
              } else if (alignItems === 'baseline') {
                var _diff8 = baseline - item.firstBaseline;

                if (_diff8 !== 0) {
                  item.__offsetY(_diff8, true, null);
                }
              } // 默认stretch
              else {
                var _computedStyle2 = item.computedStyle,
                    _item$currentStyle2 = item.currentStyle,
                    display = _item$currentStyle2[DISPLAY$3],
                    flexDirection = _item$currentStyle2[FLEX_DIRECTION],
                    _height = _item$currentStyle2[HEIGHT$2]; // row的孩子还是flex且column且不定高时，如果高度<侧轴拉伸高度则重新布局

                if (isDirectionRow && display === 'flex' && flexDirection === 'column' && _height.u === AUTO$1 && item.outerHeight < maxCross) {
                  item.__layoutFlow(Object.assign(item.__layoutData, {
                    h3: maxCross
                  }));
                }

                var _borderTopWidth = _computedStyle2[BORDER_TOP_WIDTH],
                    _borderBottomWidth = _computedStyle2[BORDER_BOTTOM_WIDTH],
                    _marginTop2 = _computedStyle2[MARGIN_TOP],
                    _marginBottom2 = _computedStyle2[MARGIN_BOTTOM],
                    _paddingTop = _computedStyle2[PADDING_TOP],
                    _paddingBottom = _computedStyle2[PADDING_BOTTOM];

                if (_height.u === AUTO$1) {
                  var _old = item.height;

                  var _v = maxCross - _marginTop2 - _marginBottom2 - _paddingTop - _paddingBottom - _borderTopWidth - _borderBottomWidth;

                  var _d = _v - _old;

                  item.__sy4 += _d;
                  item.__sy5 += _d;
                  item.__sy6 += _d;
                  item.__height += _d;
                  item.__clientHeight += _d;
                  item.__offsetHeight += _d;
                  item.__outerHeight += _d;
                }
              }
            }
          } // column
          else {
            if (alignSelf === 'flexStart') ; else if (alignSelf === 'flexEnd') {
              var _diff9 = maxCross - item.outerWidth;

              if (_diff9 !== 0) {
                item.__offsetX(_diff9, true, null);
              }
            } else if (alignSelf === 'center') {
              var _diff10 = maxCross - item.outerWidth;

              if (_diff10 !== 0) {
                item.__offsetX(_diff10 * 0.5, true, null);
              }
            } else if (alignSelf === 'stretch') {
              var _computedStyle3 = item.computedStyle,
                  width = item.currentStyle[WIDTH$2];
              var borderRightWidth = _computedStyle3[BORDER_RIGHT_WIDTH$1],
                  borderLeftWidth = _computedStyle3[BORDER_LEFT_WIDTH$1],
                  marginRight = _computedStyle3[MARGIN_RIGHT$1],
                  marginLeft = _computedStyle3[MARGIN_LEFT$1],
                  paddingRight = _computedStyle3[PADDING_RIGHT$1],
                  paddingLeft = _computedStyle3[PADDING_LEFT$1];

              if (width.u === AUTO$1) {
                var _old2 = item.width;

                var _v2 = item.__width = _computedStyle3[WIDTH$2] = maxCross - marginLeft - marginRight - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth;

                var _d2 = _v2 - _old2;

                item.__sx4 += _d2;
                item.__sx5 += _d2;
                item.__sx6 += _d2;
                item.__width += _d2;
                item.__clientWidth += _d2;
                item.__offsetWidth += _d2;
                item.__outerWidth += _d2;
              }
            } else if (alignItems === 'baseline') {
              var _diff11 = baseline - item.firstBaseline;

              if (_diff11 !== 0) {
                item.__offsetX(_diff11, true, null);
              }
            } // 默认auto，取alignItems
            else {
              if (alignItems === 'flexStart') ; else if (alignItems === 'center') {
                var _diff12 = maxCross - item.outerWidth;

                if (_diff12 !== 0) {
                  item.__offsetX(_diff12 * 0.5, true, null);
                }
              } else if (alignItems === 'flexEnd') {
                var _diff13 = maxCross - item.outerWidth;

                if (_diff13 !== 0) {
                  item.__offsetX(_diff13, true, null);
                }
              } else if (alignItems === 'baseline') {
                var _diff14 = baseline - item.firstBaseline;

                if (_diff14 !== 0) {
                  item.__offsetX(_diff14, true, null);
                }
              } // 默认stretch
              else {
                var _computedStyle4 = item.computedStyle,
                    _width = item.currentStyle[WIDTH$2];
                var _borderRightWidth = _computedStyle4[BORDER_RIGHT_WIDTH$1],
                    _borderLeftWidth = _computedStyle4[BORDER_LEFT_WIDTH$1],
                    _marginRight2 = _computedStyle4[MARGIN_RIGHT$1],
                    _marginLeft2 = _computedStyle4[MARGIN_LEFT$1],
                    _paddingRight = _computedStyle4[PADDING_RIGHT$1],
                    _paddingLeft = _computedStyle4[PADDING_LEFT$1];

                if (_width.u === AUTO$1) {
                  var _old3 = item.width;

                  var _v3 = item.__width = _computedStyle4[WIDTH$2] = maxCross - _marginLeft2 - _marginRight2 - _paddingLeft - _paddingRight - _borderRightWidth - _borderLeftWidth;

                  var _d3 = _v3 - _old3;

                  item.__sx4 += _d3;
                  item.__sx5 += _d3;
                  item.__sx6 += _d3;
                  item.__width += _d3;
                  item.__clientWidth += _d3;
                  item.__offsetWidth += _d3;
                  item.__outerWidth += _d3;
                }
              }
            }
          }
        });
      }
      /**
       * inline比较特殊，先简单顶部对齐，后续还需根据vertical和lineHeight计算y偏移
       * inlineBlock复用逻辑，可以设置w/h，在混排时表现不同，inlineBlock换行限制在规定的矩形内，
       * 且ib会在没设置width且换行的时候撑满上一行，即便内部尺寸没抵达边界
       * 而inline换行则会从父容器start处开始，且首尾可能占用矩形不同
       * 嵌套inline情况十分复杂，尾部mpb空白可能产生叠加情况，因此endSpace表示自身，
       * 然后根据是否在最后一个元素进行叠加父元素的，多层嵌套则多层尾部叠加，均以最后一个元素为依据判断
       * Text获取这个叠加的endSpace值即可，无需感知是否最后一个，外层（此处）进行逻辑封装
       * @param data
       * @param isAbs
       * @param isColumn
       * @param isRow
       * @param isInline
       * @private
       */

    }, {
      key: "__layoutInline",
      value: function __layoutInline(data, isAbs, isColumn, isRow, isInline) {
        var flowChildren = this.flowChildren,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle;
        var textAlign = computedStyle[TEXT_ALIGN],
            whiteSpace = computedStyle[WHITE_SPACE],
            lineClamp = computedStyle[LINE_CLAMP],
            lineHeight = computedStyle[LINE_HEIGHT],
            marginTop = computedStyle[MARGIN_TOP],
            marginBottom = computedStyle[MARGIN_BOTTOM],
            marginLeft = computedStyle[MARGIN_LEFT$1],
            marginRight = computedStyle[MARGIN_RIGHT$1],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$1],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$1],
            paddingTop = computedStyle[PADDING_TOP],
            paddingBottom = computedStyle[PADDING_BOTTOM],
            paddingLeft = computedStyle[PADDING_LEFT$1],
            paddingRight = computedStyle[PADDING_RIGHT$1];
        var lineClampCount = data.lineClampCount || 0;

        var _this$__preLayout3 = this.__preLayout(data, isInline),
            fixedWidth = _this$__preLayout3.fixedWidth,
            fixedHeight = _this$__preLayout3.fixedHeight,
            x = _this$__preLayout3.x,
            y = _this$__preLayout3.y,
            w = _this$__preLayout3.w,
            h = _this$__preLayout3.h,
            lx = _this$__preLayout3.lx,
            ly = _this$__preLayout3.ly,
            lineBoxManager = _this$__preLayout3.lineBoxManager,
            endSpace = _this$__preLayout3.endSpace,
            selfEndSpace = _this$__preLayout3.selfEndSpace,
            isUpright = _this$__preLayout3.isUpright; // abs虚拟布局需预知width，固定可提前返回


        if (isAbs && (fixedWidth && !isUpright || fixedHeight && isUpright)) {
          if (isUpright) {
            this.__ioSize(undefined, h);
          } else {
            this.__ioSize(w, undefined);
          }

          return lineClampCount;
        }

        var width = currentStyle[WIDTH$2],
            height = currentStyle[HEIGHT$2];

        if (isInline && !this.__isRealInline()) {
          isInline = false;
        } // inline-block假布局提前结束


        if (!isInline) {
          if (isColumn && fixedHeight) {
            this.__ioSize(undefined, h);

            return lineClampCount;
          }

          if (isRow && fixedWidth) {
            this.__ioSize(w, undefined);

            return lineClampCount;
          }
        } // 只有inline的孩子需要考虑换行后从行首开始，而ib不需要，因此重置行首标识lx为x，末尾空白为0
        // 而inline的LineBoxManager复用最近非inline父dom的，ib需要重新生成，末尾空白叠加


        if (isInline) {
          this.__isInline = true;
          this.__lineBoxManager = lineBoxManager;
          var baseline = isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle); // 特殊inline调用，有内容的话（如左右mbp），默认生成一个lineBox，即便是空，也要形成占位，只有开头时需要

          if (isUpright && (marginTop || marginBottom || paddingTop || paddingBottom || borderTopWidth || borderBottomWidth) || !isUpright && (marginLeft || marginRight || paddingLeft || paddingRight || borderLeftWidth || borderRightWidth)) {
            if (lineBoxManager.isNewLine) {
              lineBoxManager.genLineBoxByInlineIfNewLine(x, y, lineHeight, baseline);
            } else {
              lineBoxManager.setLbByInlineIfNotNewLine(lineHeight, baseline);
            }
          } else {
            lineBoxManager.setLbByInlineIfNotNewLine(lineHeight, baseline);
          }

          lineClamp = data.lineClamp || 0;
        } else {
          lineBoxManager = this.__lineBoxManager = new LineBoxManager(x, y, lineHeight, isUpright ? getVerticalBaseline(computedStyle) : getBaseline(computedStyle), isUpright);
          lx = x;
          ly = y;
          endSpace = selfEndSpace = lineClampCount = 0;
        } // 存LineBox里的内容列表专用，布局过程中由lineBoxManager存入，递归情况每个inline节点都保存contentBox


        if (isInline) {
          this.contentBoxList.splice(0);
          lineBoxManager.pushContentBoxList(this);
        } // ib的bp是自己，inline是最近的非inline


        var bp = this;

        while (bp.computedStyle[DISPLAY$3] === 'inline') {
          bp = bp.domParent;
        }

        var overflow = bp.computedStyle[OVERFLOW$1];
        var isIbFull = false,
            isUprightIbFull = false; // ib时不限定w情况下发生折行则撑满行，即便内容没有撑满边界

        var length = flowChildren.length;
        var ignoreNextLine = false; // lineClamp超过后，后面的均忽略并置none，注意ib内部自己统计类似block

        var ignoreNextWrap = false; // whiteSpace单行超过后，后面的均忽略并置none，注意和block不一样不隔断

        var hasAddEndSpace; // 最后一行生效，只加1次防重复

        flowChildren.forEach(function (item, i) {
          // 和block不太一样可以提前判断，因为不可能包含block隔断区域了
          if (ignoreNextLine || ignoreNextWrap) {
            item.__layoutNone();

            return;
          }

          var isXom = item instanceof Xom || item instanceof Component && item.shadowRoot instanceof Xom;

          if (isXom) {
            item.__computeReflow(); // writing-mode可能会造成inline改变为ib

          }

          var isInline2 = isXom && item.computedStyle[DISPLAY$3] === 'inline';
          var isInlineBlock2 = isXom && item.computedStyle[DISPLAY$3] === 'inlineBlock';

          var isRealInline = isInline2 && item.__isRealInline(); // 最后一个元素会产生最后一行，叠加父元素的尾部mpb，注意只执行一次防止重复叠加


          var isEnd = isInline && !hasAddEndSpace && (whiteSpace === 'nowrap' || !isXom && i === length - 1 || lineClamp && i === length - 1 || lineClampCount === lineClamp - 1);

          if (isEnd) {
            hasAddEndSpace = true;
            endSpace += selfEndSpace;
          }

          var lastLineClampCount = lineClampCount;

          if (isXom) {
            if (!isInline2 && !isInlineBlock2) {
              item.currentStyle[DISPLAY$3] = item.computedStyle[DISPLAY$3] = 'inlineBlock';
              isInlineBlock2 = true;
              inject.warn('Inline can not contain block/flex');
            } // x开头或者nowrap单行，不用考虑是否放得下直接放，因为有beginSpace所以要多判断i为0


            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow); // 同block布局

              if (item.__isIbFull || item.__isUprightIbFull) {
                lineClampCount++;
              }

              if (item.__isIbFull && whiteSpace !== 'nowrap') {
                if (isUpright && h.u === AUTO$1) {
                  isUprightIbFull = true;
                } else if (!isUpright && w.u === AUTO$1) {
                  isIbFull = true;
                }

                lineBoxManager.addItem(item, true);

                if (isUpright) {
                  x += item.outerWidth;
                  y = ly;
                } else {
                  x = lx;
                  y += item.outerHeight;
                }

                lineBoxManager.setNotEnd();
              } // inline和不折行的ib，其中ib需要手动存入当前lb中，以计算宽度
              else {
                (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;
              }

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }
            } else {
              // 不换行继续排，换行非开头先尝试是否放得下，结尾要考虑mpb因此减去endSpace
              var free = item.__tryLayInline(isUpright ? h + ly - y - endSpace : w + lx - x - endSpace, isUpright ? h : w, isUpright); // 放得下继续


              if (free >= -1e-10) {
                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // ib放得下要么内部没有折行，要么声明了width限制，都需手动存入当前lb

                (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 可能超行了，无需继续，并且进行回溯

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var list = lineBoxManager.list;
                  var lineBox = list[list.length - 1];
                  backtrack(bp, lineBoxManager, lineBox, w, endSpace, isUpright);
                  return;
                }

                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow); // 重新开头的ib和上面开头处一样逻辑

                if (item.__isIbFull || item.__isUprightIbFull) {
                  lineBoxManager.addItem(item, true);

                  if (isUpright) {
                    x += item.outerWidth;
                    y = ly;
                  } else {
                    x = lx;
                    y += item.outerHeight;
                  }

                  lineBoxManager.setNotEnd();
                  lineClampCount++;
                } // inline和不折行的ib，其中ib需要手动存入当前lb中
                else {
                  (isInlineBlock2 || !isRealInline) && lineBoxManager.addItem(item, false);
                  x = lineBoxManager.lastX;
                  y = lineBoxManager.lastY;
                }

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              }
            }
          } // inline里的其它只有文本，可能开始紧跟着之前的x，也可能换行后从lx行头开始
          // 紧跟着x可能出现在前面有节点换行后第2行，此时不一定放得下，因此不能作为判断依据，开头仅有lx
          else {
            var n = lineBoxManager.size; // i为0时强制不换行

            if (isUpright && y === ly || !isUpright && x === lx || !i || whiteSpace === 'nowrap') {
              lineClampCount = item.__layoutFlow({
                x: x,
                y: y,
                w: w,
                h: h,
                lx: lx,
                ly: ly,
                lineBoxManager: lineBoxManager,
                endSpace: endSpace,
                lineClamp: lineClamp,
                lineClampCount: lineClampCount,
                isUpright: isUpright
              }, isAbs, isColumn, isRow);
              x = lineBoxManager.lastX;
              y = lineBoxManager.lastY; // ib情况发生折行，且非定宽

              if (!isInline && lineBoxManager.size - n > 1) {
                if (height.u === AUTO$1 && isUpright) {
                  isUprightIbFull = true;
                }

                if (width.u === AUTO$1 && !isUpright) {
                  isIbFull = true;
                }
              }

              if (!isAbs && overflow === 'hidden' && whiteSpace === 'nowrap' && (isUpright && y - ly > h + 1e-10 || !isUpright && x - lx > w + 1e-10 || lineClampCount > lastLineClampCount)) {
                ignoreNextWrap = true;
              } else if (lineClamp && lineClampCount >= lineClamp) {
                ignoreNextLine = true;
              }
            } else {
              // 非开头先尝试是否放得下，如果放得下再看是否end，加end且只有1个字时放不下要换行，否则可以放，换行由text内部做
              var _free2 = item.__tryLayInline(isUpright ? h + ly - y - endSpace : w + lx - x - endSpace); // 放得下继续


              if (_free2 >= -1e-10) {
                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY;

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                } // 这里ib放得下一定是要么没换行要么固定宽度，所以无需判断isIbFull

              } // 放不下处理之前的lineBox，并重新开头
              else {
                lineClampCount++;

                if (isUpright) {
                  x = lineBoxManager.endX;
                  y = ly;
                } else {
                  x = lx;
                  y = lineBoxManager.endY;
                }

                lineBoxManager.setNewLine(); // 可能超行了，无需继续，并且进行回溯

                if (lineClamp && lineClampCount >= lineClamp) {
                  item.__layoutNone();

                  ignoreNextLine = true;
                  var _list2 = lineBoxManager.list;
                  var _lineBox2 = _list2[_list2.length - 1];
                  backtrack(bp, lineBoxManager, _lineBox2, w, endSpace, isUpright);
                  return;
                }

                lineClampCount = item.__layoutFlow({
                  x: x,
                  y: y,
                  w: w,
                  h: h,
                  lx: lx,
                  ly: ly,
                  lineBoxManager: lineBoxManager,
                  endSpace: endSpace,
                  lineClamp: lineClamp,
                  lineClampCount: lineClampCount,
                  isUpright: isUpright
                }, isAbs, isColumn, isRow);
                x = lineBoxManager.lastX;
                y = lineBoxManager.lastY; // ib情况发生折行

                if (!isInline && lineBoxManager.size - n > 1) {
                  if (height.u === AUTO$1 && isUpright) {
                    isUprightIbFull = true;
                  }

                  if (width.u === AUTO$1 && !isUpright) {
                    isIbFull = true;
                  }
                }

                if (lineClamp && lineClampCount >= lineClamp) {
                  ignoreNextLine = true;
                }
              }
            }
          }
        }); // 同block结尾，不过这里一定是lineBox结束，无需判断

        if (isUpright) {
          x = lineBoxManager.endX;
        } else {
          y = lineBoxManager.endY;
        } // 标识ib情况同block一样占满行


        this.__isIbFull = isIbFull;
        this.__isUprightIbFull = isUprightIbFull; // 元素的width在固定情况或者ibFull情况已被计算出来，否则为最大延展尺寸，inline没有固定尺寸概念

        var tw, th;

        if (isInline) {
          // inline最后的x要算上右侧mpb，为next行元素提供x坐标基准，同时其尺寸计算比较特殊
          if (selfEndSpace) {
            if (isUpright) {
              lineBoxManager.addY(selfEndSpace);
            } else {
              lineBoxManager.addX(selfEndSpace);
            }
          } // 如果没有内容，空白还要加上开头即左侧mpb


          if (!flowChildren.length) {
            var _marginTop3 = computedStyle[MARGIN_TOP],
                _marginLeft3 = computedStyle[MARGIN_LEFT$1],
                _paddingTop2 = computedStyle[PADDING_TOP],
                _paddingLeft2 = computedStyle[PADDING_LEFT$1],
                _borderTopWidth2 = computedStyle[BORDER_TOP_WIDTH],
                _borderLeftWidth2 = computedStyle[BORDER_LEFT_WIDTH$1];

            if (isUpright) {
              lineBoxManager.addY(_marginTop3 + _paddingTop2 + _borderTopWidth2);
            } else {
              lineBoxManager.addX(_marginLeft3 + _paddingLeft2 + _borderLeftWidth2);
            }
          } // 结束出栈contentBox，递归情况结束子inline获取contentBox，父inline继续


          lineBoxManager.popContentBoxList(); // abs非固定w时预计算，本来是最近非inline父层统一计算，但在abs时不算，这里无视textAlign默认left

          if (isAbs) {
            this.__inlineSize(0, 'left', isUpright);
          }
        } else {
          // ib在满时很特殊，取最大值，可能w本身很小不足排下1个字符，此时要用max
          var max = lineBoxManager.max - (isUpright ? data.y : data.x);

          if (isUpright) {
            tw = fixedWidth ? w : x - data.x;
            th = fixedHeight ? h : isIbFull ? Math.max(h, max) : max;
          } else {
            tw = fixedWidth ? w : isIbFull ? Math.max(w, max) : max;
            th = fixedHeight ? h : y - data.y;
          }

          this.__ioSize(tw, th);
        } // 非abs提前虚拟布局，真实布局情况下最后为所有行内元素进行2个方向上的对齐，inline会被父级调用这里只看ib


        if (!isAbs && !isInline) {
          var spread = lineBoxManager.verticalAlign(isUpright);

          if (spread) {
            if (isUpright && !fixedWidth) {
              this.__resizeX(spread, null);
            } else if (!isUpright && !fixedHeight) {
              this.__resizeY(spread, null);
            }
          }

          if (!isColumn && !isRow) {
            if (['center', 'right'].indexOf(textAlign) > -1) {
              lineBoxManager.horizonAlign(isUpright ? th : tw, textAlign, isUpright); // 直接text需计算size

              flowChildren.forEach(function (item) {
                if (item instanceof Component) {
                  item = item.shadowRoot;
                }

                if (item instanceof Text) {
                  item.__inlineSize(isUpright);
                }
              });
            } // block的所有inline计算size


            lineBoxManager.domList.forEach(function (item) {
              item.__inlineSize(isUpright ? th : tw, textAlign, isUpright);
            });
          }
        } // inlineBlock新开上下文，但父级block遇到要处理换行


        return lineClampCount;
      }
      /**
       * inline的尺寸计算非常特殊，并非一个矩形区域，而是由字体行高结合节点下多个LineBox中的内容决定，
       * 且这个尺寸又并非真实LineBox中的内容直接合并计算而来，比如包含了个更大尺寸的ib却不会计入
       * 具体方法为遍历持有的LineBox下的内容，x取两侧极值，同时首尾要考虑mpb，y值取上下极值，同样首尾考虑mpb
       * 首尾行LineBox可能不是不是占满一行，比如前后都有同行inline的情况，非首尾行则肯定占满
       * 绘制内容（如背景色）的区域也很特殊，每行LineBox根据lineHeight对齐baseline得来，并非LineBox全部
       * 当LineBox只有直属Text时如果font没有lineGap则等价于全部，如有则需减去
       * 另外其client/offset/outer的w/h尺寸计算也很特殊，皆因首尾x方向的mpb导致
       * @private
       */

    }, {
      key: "__inlineSize",
      value: function __inlineSize(size, textAlign, isUpright) {
        var contentBoxList = this.contentBoxList,
            computedStyle = this.computedStyle,
            __ox = this.__ox,
            __oy = this.__oy;
        var display = computedStyle[DISPLAY$3],
            marginTop = computedStyle[MARGIN_TOP],
            marginRight = computedStyle[MARGIN_RIGHT$1],
            marginBottom = computedStyle[MARGIN_BOTTOM],
            marginLeft = computedStyle[MARGIN_LEFT$1],
            paddingTop = computedStyle[PADDING_TOP],
            paddingRight = computedStyle[PADDING_RIGHT$1],
            paddingBottom = computedStyle[PADDING_BOTTOM],
            paddingLeft = computedStyle[PADDING_LEFT$1],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH],
            borderRightWidth = computedStyle[BORDER_RIGHT_WIDTH$1],
            borderBottomWidth = computedStyle[BORDER_BOTTOM_WIDTH],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$1],
            lineHeight = computedStyle[LINE_HEIGHT]; // 可能因为Ellipsis回溯变成none

        if (display === 'none') {
          return;
        } // x/clientX/offsetX/outerX


        var maxX, maxY, minX, minY, maxCX, maxCY, minCX, minCY, maxFX, maxFY, minFX, minFY, maxOX, maxOY, minOX, minOY;
        var length = contentBoxList.length;

        if (length) {
          // 遍历contentBox，里面存的是LineBox内容，根据父LineBox引用判断是否换行
          contentBoxList.forEach(function (item, i) {
            // 非第一个除了minY不用看其它都要，minX是换行导致，而maxX在最后一个要考虑右侧mpb，中间的无需考虑嵌套inline的mpb
            if (i) {
              minX = Math.min(minX, item.x);
              minCX = Math.min(minCX, item.x);
              minFX = Math.min(minFX, item.x);
              minOX = Math.min(minOX, item.x);

              if (i === length - 1) {
                maxX = maxCX = maxFX = maxOX = Math.max(maxX, item.x + item.outerWidth);
                maxY = maxCY = maxFY = maxOY = Math.max(maxY, item.y + item.outerHeight);
                maxCX += paddingRight;
                maxCY += paddingBottom;
                maxFX += paddingRight + borderRightWidth;
                maxFY += paddingBottom + borderBottomWidth;
                maxOX += borderRightWidth + paddingRight + marginRight;
                maxOY += borderBottomWidth + paddingBottom + marginBottom;
              } else {
                maxX = maxCX = maxFX = maxOX = Math.max(maxX, item.x + item.outerWidth);
              }
            } // 第一个初始化
            else {
              minX = item.x;
              minY = item.y;
              minCX = minX - paddingLeft;
              minCY = minY - paddingTop;
              minFX = minCX - borderLeftWidth;
              minFY = minCY - borderTopWidth;
              minOX = minFX - marginLeft;
              minOY = minFY - marginTop;
              maxX = maxCX = maxFX = maxOX = item.x + item.outerWidth;
              maxY = maxCY = maxFY = maxOY = item.y + item.outerHeight;

              if (i === length - 1) {
                maxCX += paddingRight;
                maxCY += paddingBottom;
                maxFX += paddingRight + borderRightWidth;
                maxFY += paddingBottom + borderBottomWidth;
                maxOX += borderRightWidth + paddingRight + marginRight;
                maxOY += borderBottomWidth + paddingBottom + marginBottom;
              }
            }
          });
          this.__x = minOX;
          this.__y = minOY;
          this.__width = computedStyle[WIDTH$2] = maxX - minX; // 防止比自己最小高度lineHeight还小，比如内容是个小字体

          this.__height = computedStyle[HEIGHT$2] = Math.max(lineHeight, maxY - minY);
          this.__clientWidth = maxCX - minCX;
          this.__clientHeight = maxCY - minCY;
          this.__offsetWidth = maxFX - minFX;
          this.__offsetHeight = maxFY - minFY;
          this.__outerWidth = maxOX - minOX;
          this.__outerHeight = maxOY - minOY;
          this.__sx = minOX + __ox;
          this.__sy = minOY + __oy;
          this.__sx1 = minFX + __ox;
          this.__sy1 = minFY + __oy;
          this.__sx2 = minCX + __ox;
          this.__sy2 = minCY + __oy;
          this.__sx3 = minX + __ox;
          this.__sy3 = minY + __oy;
          this.__sx4 = maxX + __ox;
          this.__sy4 = maxY + __oy;
          this.__sx5 = maxCX + __ox;
          this.__sy5 = maxCY + __oy;
          this.__sx6 = maxFX + __ox;
          this.__sy6 = maxFY + __oy; // inline的text整体设置相同

          if (['center', 'right'].indexOf(textAlign) > -1) {
            this.children.forEach(function (item) {
              if (item instanceof Text) {
                item.__inlineSize(isUpright);
              }
            });
          }
        } // 如果没有内容，宽度为0高度为lineHeight，对齐也特殊处理，lineBoxManager不会处理
        else {
          var tw = 0,
              th = 0;

          if (['center', 'right'].indexOf(textAlign) > -1) {
            var diff = size;

            if (textAlign === 'center') {
              diff *= 0.5;
            }

            if (diff > 0) {
              if (isUpright) {
                this.__offsetY(diff, true, null);
              } else {
                this.__offsetX(diff, true, null);
              }
            }
          }

          if (isUpright) {
            tw = lineHeight;

            this.__ioSize(tw, 0);

            this.__sx -= marginLeft + paddingLeft + borderLeftWidth;
          } else {
            th = lineHeight;

            this.__ioSize(0, th);

            this.__sy -= marginTop + paddingTop + borderTopWidth;
          }

          this.__sx1 = this.__sx + marginLeft;
          this.__sy1 = this.__sy + marginTop;
          this.__sx2 = this.__sx1 + borderLeftWidth;
          this.__sy2 = this.__sy1 + borderTopWidth;
          this.__sx4 = this.__sx3 = this.__sx2 + paddingLeft;
          this.__sy4 = this.__sy3 = this.__sy2 + paddingTop;
          this.__sx5 = this.__sx4 + tw + paddingRight;
          this.__sy5 = this.__sy4 + th + paddingBottom;
          this.__sx6 = this.__sx5 + borderRightWidth;
          this.__sy6 = this.__sy5 + borderBottomWidth;
          this.__clientWidth = this.__sx5 - this.__sx2;
          this.__clientHeight = this.__sy5 - this.__sy2;
          this.__offsetWidth = this.__sx6 - this.__sx1;
          this.__offsetHeight = this.__sy6 - this.__sy1;
          this.__outerWidth = this.__offsetWidth + marginLeft + marginRight;
          this.__outerHeight = this.__offsetHeight + marginTop + marginBottom;
        }
      }
      /**
       * 只针对绝对定位children布局
       * @param container
       * @param data
       * @param target 可选，只针对某个abs的child特定布局，在局部更新时用
       * @private
       */

    }, {
      key: "__layoutAbs",
      value: function __layoutAbs(container, data, target) {
        var _this6 = this;

        var x = container.__sx,
            y = container.__sy,
            clientWidth = container.__clientWidth,
            clientHeight = container.__clientHeight,
            computedStyle = container.__computedStyle;
        var isDestroyed = this.__isDestroyed,
            children = this.children,
            absChildren = this.absChildren;
        var display = computedStyle[DISPLAY$3],
            borderTopWidth = computedStyle[BORDER_TOP_WIDTH],
            borderLeftWidth = computedStyle[BORDER_LEFT_WIDTH$1],
            marginTop = computedStyle[MARGIN_TOP],
            marginLeft = computedStyle[MARGIN_LEFT$1],
            paddingLeft = computedStyle[PADDING_LEFT$1],
            paddingTop = computedStyle[PADDING_TOP];

        if (isDestroyed || display === 'none') {
          this.__layoutNone();

          return;
        }

        x += marginLeft + borderLeftWidth;
        y += marginTop + borderTopWidth; // 对absolute的元素进行相对容器布局

        absChildren.forEach(function (item) {
          if (target) {
            // 传入target局部布局更新，这时候如果是Component引发的，当setState时是Cp自身，当layout时是sr
            var node = item;

            if (node instanceof Component) {
              node = item.shadowRoot;
            } // 所以得2个都对比


            if (target !== node && target !== item) {
              return;
            }
          }

          var currentStyle = item.currentStyle,
              computedStyle = item.computedStyle;

          if (item.isDestroyed || currentStyle[DISPLAY$3] === 'none') {
            item.__layoutNone();

            return;
          } // 先根据容器宽度计算margin/padding，匿名块对象特殊处理，此时没有computedStyle


          item.__computeReflow();

          item.__mp(currentStyle, computedStyle, clientWidth);

          var left = currentStyle[LEFT$1],
              top = currentStyle[TOP$1],
              right = currentStyle[RIGHT$1],
              bottom = currentStyle[BOTTOM$1],
              width = currentStyle[WIDTH$2],
              height = currentStyle[HEIGHT$2];
          var x2, y2, w2, h2;
          var onlyRight;
          var onlyBottom;
          var fixedTop;
          var fixedRight;
          var fixedBottom;
          var fixedLeft; // 判断何种方式的定位，比如左+宽度，左+右之类

          if (left.u !== AUTO$1) {
            fixedLeft = true;
            computedStyle[LEFT$1] = _this6.__calSize(left, clientWidth, true);
          } else {
            computedStyle[LEFT$1] = 'auto';
          }

          if (right.u !== AUTO$1) {
            fixedRight = true;
            computedStyle[RIGHT$1] = _this6.__calSize(right, clientWidth, true);
          } else {
            computedStyle[RIGHT$1] = 'auto';
          }

          if (top.u !== AUTO$1) {
            fixedTop = true;
            computedStyle[TOP$1] = _this6.__calSize(top, clientHeight, true);
          } else {
            computedStyle[TOP$1] = 'auto';
          }

          if (bottom.u !== AUTO$1) {
            fixedBottom = true;
            computedStyle[BOTTOM$1] = _this6.__calSize(bottom, clientHeight, true);
          } else {
            computedStyle[BOTTOM$1] = 'auto';
          } // 优先级最高left+right，其次left+width，再次right+width，再次仅申明单个，最次全部auto


          if (fixedLeft && fixedRight) {
            x2 = x + computedStyle[LEFT$1];
            w2 = clientWidth - computedStyle[RIGHT$1] - computedStyle[LEFT$1];
          } else if (fixedLeft) {
            x2 = x + computedStyle[LEFT$1];

            if (width.u !== AUTO$1) {
              w2 = _this6.__calSize(width, clientWidth, true);
            }
          } else if (fixedRight) {
            if (width.u !== AUTO$1) {
              w2 = _this6.__calSize(width, clientWidth, true);
            } else {
              onlyRight = true;
            }

            x2 = x + clientWidth - computedStyle[RIGHT$1] - (w2 || 0); // 右对齐有尺寸时还需减去margin/border/padding的

            x2 -= computedStyle[MARGIN_LEFT$1];
            x2 -= computedStyle[MARGIN_RIGHT$1];
            x2 -= computedStyle[PADDING_LEFT$1];
            x2 -= computedStyle[PADDING_RIGHT$1];
            x2 -= computedStyle[BORDER_LEFT_WIDTH$1];
            x2 -= computedStyle[BORDER_RIGHT_WIDTH$1];
          } else {
            x2 = x + paddingLeft;

            if (width.u !== AUTO$1) {
              w2 = _this6.__calSize(width, clientWidth, true);
            }
          } // top/bottom/height优先级同上


          if (fixedTop && fixedBottom) {
            y2 = y + computedStyle[TOP$1];
            h2 = clientHeight - computedStyle[TOP$1] - computedStyle[BOTTOM$1];
          } else if (fixedTop) {
            y2 = y + computedStyle[TOP$1];

            if (height.u !== AUTO$1) {
              h2 = _this6.__calSize(height, clientHeight, true);
            }
          } else if (fixedBottom) {
            if (height.u !== AUTO$1) {
              h2 = _this6.__calSize(height, clientHeight, true);
            } else {
              onlyBottom = true;
            }

            y2 = y + clientHeight - computedStyle[BOTTOM$1] - (h2 || 0); // 底对齐有尺寸时y值还需减去margin/border/padding的

            y2 -= computedStyle[MARGIN_TOP];
            y2 -= computedStyle[MARGIN_BOTTOM];
            y2 -= computedStyle[PADDING_TOP];
            y2 -= computedStyle[PADDING_BOTTOM];
            y2 -= computedStyle[BORDER_TOP_WIDTH];
            y2 -= computedStyle[BORDER_BOTTOM_WIDTH];
          } // 未声明y的找到之前的流布局child，紧随其下
          else {
            y2 = y + paddingTop;
            var prev = item.__prev,
                mtList = [],
                mbList = [];

            while (prev) {
              // 以前面的flow的最近的prev末尾为准
              if (prev instanceof Text || prev instanceof Component && prev.shadowRoot instanceof Text || prev.computedStyle[POSITION$1] !== 'absolute') {
                // 当prev是空白节点时，还要考虑margin合并的影响
                var cps = prev.computedStyle;

                if (prev.clientHeight <= 0) {
                  mtList.push(cps[MARGIN_TOP]);
                  mbList.push(cps[MARGIN_BOTTOM]);
                } else {
                  mbList.push(cps[MARGIN_BOTTOM]);
                  var t = reflow.getMergeMargin(mtList, mbList);
                  y2 = prev.__sy1 + prev.offsetHeight + t.target;
                  break;
                }
              }

              prev = prev.__prev;
            }

            if (height.u !== AUTO$1) {
              h2 = _this6.__calSize(height, clientHeight, true);
            }
          } // onlyRight时做的布局其实是以那个点位为left/top布局然后offset，limit要特殊计算，从本点向左侧为边界


          var widthLimit = onlyRight ? x2 - x : clientWidth + x - x2; // onlyBottom相同，正常情况是左上到右下的尺寸限制

          var heightLimit = onlyBottom ? y2 - y : clientHeight + y - y2; // 未直接或间接定义尺寸，取特殊孩子宽度的最大值，同时不能超限

          if (w2 === undefined) {
            item.__layoutFlow({
              x: x2,
              y: y2,
              w: widthLimit,
              h: heightLimit,
              isUpright: data.isUpright,
              // 父亲的
              container: container
            }, true, false);

            widthLimit = item.outerWidth;
          } // 这里用包裹方法标明要递归计算computedStyle


          item.__layoutFlow({
            x: x2,
            y: y2,
            w: widthLimit,
            h: heightLimit,
            w2: w2,
            // left+right这种等于有宽度，但不能修改style，继续传入到__preLayout中特殊对待
            h2: h2,
            isUpright: data.isUpright,
            container: container
          }, false, false);

          if (onlyRight) {
            item.__offsetX(-item.outerWidth, true, null);
          }

          if (onlyBottom) {
            item.__offsetY(-item.outerHeight, true, null);
          }

          item.__layoutStyle();
        }); // 递归进行，遇到absolute/relative/component的设置新容器

        children.forEach(function (item) {
          if (target) {
            // 传入target局部布局更新，这时候如果是Component引发的，当setState时是Cp自身，当layout时是sr
            var node = item;

            if (node instanceof Component) {
              node = item.shadowRoot;
            } // 所以得2个都对比


            if (target !== node && target !== item) {
              return;
            }
          }

          if (item instanceof Dom) {
            item.__layoutAbs(isRelativeOrAbsolute(item) ? item : container, data, null);
          } else if (item instanceof Component) {
            var sr = item.shadowRoot;

            if (sr instanceof Dom) {
              sr.__layoutAbs(sr, data, null);
            }
          }
        }); // 根节点自己特殊执行，不在layout统一

        this.__execAr();
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Dom.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        var ep = this.__ellipsis;

        if (ep) {
          ep.render(renderMode, res.ctx, dx, dy);
        }

        if (renderMode === SVG) {
          this.virtualDom.type = 'dom';
        }

        return res;
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        if (this.isDestroyed) {
          return;
        }

        this.children.forEach(function (child) {
          // 有可能为空，因为diff过程中相同的cp被移到新的vd中，老的防止destroy设null
          if (child) {
            child.__destroy();
          }
        });

        if (this.__ellipsis) {
          this.__ellipsis.__destroy();
        }

        _get(_getPrototypeOf(Dom.prototype), "__destroy", this).call(this);
      }
    }, {
      key: "__emitEvent",
      value: function __emitEvent(e, pm, force) {
        if (force) {
          return _get(_getPrototypeOf(Dom.prototype), "__emitEvent", this).call(this, e, force);
        }

        var __isDestroyed = this.__isDestroyed,
            computedStyle = this.__computedStyle,
            __isMask = this.__isMask,
            __cacheTotal = this.__cacheTotal;

        if (__isDestroyed || computedStyle[DISPLAY$3] === 'none' || e.__stopPropagation || __isMask) {
          return;
        } // 检查perspective嵌套状态，自身有perspective则设置10位，自身有transform的p矩阵则设置01位
        // if(computedStyle[PERSPECTIVE]) {
        //   perspectiveNest++;
        // }
        // if(tf.isPerspectiveMatrix(computedStyle[TRANSFORM])) {
        //   perspectiveTfNest++;
        // }
        // overflow:hidden时还需要判断是否超出范围外，如果是则无效


        if (computedStyle[OVERFLOW$1] === 'hidden' && !this.willResponseEvent(e, true)) {
          return;
        } // __cacheTotal可提前判断是否在bbox范围内，防止svg进入判断bbox


        if (__cacheTotal && __cacheTotal.available && __cacheTotal.bbox) {
          // 不是E的话，因为缓存缘故影响cache的子元素，先左乘可能的父matrix（嵌套cache），再赋值给pm递归传下去
          if (!isE$2(this.__matrix)) {
            pm = multiply$1(pm, this.__matrix);
            assignMatrix$1(this.__matrixEvent, pm);
          }

          var bbox = __cacheTotal.bbox;

          if (!geom$1.pointInQuadrilateral(e.x, e.y, bbox[0], bbox[1], bbox[2], bbox[1], bbox[2], bbox[3], bbox[0], bbox[3], this.__matrixEvent)) {
            return;
          }
        } // 递归传下来的pm如果有说明是cache的子元素且需要重新计算matrix
        else if (!mx.isE(pm)) {
          util.assignMatrix(this.__matrixEvent, mx.multiply(pm, this.__matrix));
        } // 找到对应的callback


        var type = e.event.type;
        var listener = this.listener,
            zIndexChildren = this.zIndexChildren;
        var cb;

        if (listener.hasOwnProperty(type)) {
          cb = listener[type];
        } // child触发则parent一定触发


        for (var i = zIndexChildren.length - 1; i >= 0; i--) {
          var child = zIndexChildren[i];

          if (child instanceof Xom || child instanceof Component && child.shadowRoot instanceof Xom) {
            if (child.__emitEvent(e, pm, false)) {
              // 孩子阻止冒泡
              if (e.__stopPropagation) {
                return;
              }

              if (isFunction$4(cb) && !e.__stopImmediatePropagation) {
                cb.call(this, e);
              }

              return true;
            }
          }
        } // child不触发再看自己


        return _get(_getPrototypeOf(Dom.prototype), "__emitEvent", this).call(this, e, false);
      } // 深度遍历执行所有子节点，包含自己，如果cb返回true，提前跳出不继续深度遍历

    }, {
      key: "__deepScan",
      value: function __deepScan(cb, options) {
        if (_get(_getPrototypeOf(Dom.prototype), "__deepScan", this).call(this, cb, options)) {
          return;
        }

        this.children.forEach(function (node) {
          node.__deepScan(cb, options);
        });
      }
    }, {
      key: "appendChild",
      value: function appendChild(child, cb) {
        var root = this.__root,
            host = this.__host,
            children = this.__children;

        if (!(child instanceof Node || child instanceof Component)) {
          child = new Text(child);
        }

        child.remove(); // 只设兄弟/parent，children在relation做，离屏则等真实添加时机

        var len = children.length;

        if (len) {
          var last = children[len - 1];
          last.__next = child;
          child.__prev = last;
        }

        child.__parent = this;
        children.push(child);
        var zIndexChildren = this.__zIndexChildren = genZIndexChildren(this); // 离屏情况，不刷新

        if (this.__isDestroyed) {
          if (isFunction$4(cb)) {
            cb();
          }

          return;
        } // 在dom中则整体设置关系和struct，不可见提前跳出


        builder.relation(root, host, this, child, {});

        this.__insertStruct(child, zIndexChildren.indexOf(child)); // 可能为component，不能用__currentStyle


        if (child.currentStyle[DISPLAY$3] === 'none' || this.__computedStyle[DISPLAY$3] === 'none') {
          child.__layoutNone();

          if (isFunction$4(cb)) {
            cb();
          }

          return;
        } // 在reflow过程中设置struct，text视为父变更


        if (child instanceof Text) {
          child = this;
        }

        root.__addUpdate(child, {
          focus: o$1.REFLOW,
          addDom: true,
          cb: cb
        });
      }
    }, {
      key: "prependChild",
      value: function prependChild(child, cb) {
        var root = this.__root,
            host = this.__host,
            children = this.__children;

        if (!(child instanceof Node || child instanceof Component)) {
          child = new Text(child);
        }

        child.remove(); // 只设兄弟/parent，children在relation做，离屏则等真实添加时机

        var len = children.length;

        if (len) {
          var first = children[0];
          first.__prev = child;
          child.__next = first;
        }

        child.__parent = this;
        children.unshift(child);
        var zIndexChildren = this.__zIndexChildren = genZIndexChildren(this); // 离屏情况，不刷新

        if (this.__isDestroyed) {
          if (isFunction$4(cb)) {
            cb();
          }

          return;
        } // 在dom中则整体设置关系和struct，不可见提前跳出


        builder.relation(root, host, this, child, {});

        this.__insertStruct(child, zIndexChildren.indexOf(child)); // 可能为component，不能用__currentStyle


        if (child.currentStyle[DISPLAY$3] === 'none' || this.__computedStyle[DISPLAY$3] === 'none') {
          child.__layoutNone();

          if (isFunction$4(cb)) {
            cb();
          }

          return;
        } // 可见在reflow过程中设置struct


        if (child instanceof Text) {
          child = this;
        }

        root.__addUpdate(child, {
          focus: o$1.REFLOW,
          addDom: true,
          cb: cb
        });
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(child, cb) {
        var root = this.__root;

        if (!(child instanceof Node || child instanceof Component)) {
          child = new Text(child);
        }

        child.remove();
        var parent = this.isShadowRoot ? this.__hostRoot.__parent : this.__parent;
        var i; // 即便没被添加到dom中，也有可能有父节点，除非是离屏根节点，注意组件

        if (parent) {
          var children = parent.__children;
          var target = this.isShadowRoot ? this.__hostRoot : this;
          i = children.indexOf(target);

          if (i === -1) {
            throw new Error('Index exception of insertBefore()');
          }

          var prev = target.__prev;

          if (prev) {
            prev.__next = child;
            child.__prev = prev;
          }

          child.__next = target;
          target.__prev = child;
          children.splice(i, 0, child);
          parent.__zIndexChildren = genZIndexChildren(parent);
        } else {
          throw new Error('InsertBefore() illegal');
        } // 离屏情况，不刷新


        if (this.__isDestroyed) {
          if (isFunction$4(cb)) {
            cb();
          }

          return;
        } // 在dom中则整体设置关系和struct，不可见提前跳出


        builder.relation(root, parent.__host, parent, child, {});

        parent.__insertStruct(child, parent.__zIndexChildren.indexOf(child));

        if (child.currentStyle[DISPLAY$3] === 'none' || parent.__computedStyle[DISPLAY$3] === 'none') {
          child.__layoutNone();

          if (isFunction$4(cb)) {
            cb();
          }

          return;
        }

        if (child instanceof Text) {
          child = parent;
        }

        root.__addUpdate(child, {
          focus: o$1.REFLOW,
          addDom: true,
          cb: cb
        });
      }
    }, {
      key: "insertAfter",
      value: function insertAfter(child, cb) {
        var root = this.__root;

        if (!(child instanceof Node || child instanceof Component)) {
          child = new Text(child);
        }

        child.remove();
        var parent = this.isShadowRoot ? this.__hostRoot.__parent : this.__parent;
        var i; // 即便没被添加到dom中，也有可能有父节点，除非是离屏根节点，注意组件

        if (parent) {
          var children = parent.__children;
          var target = this.isShadowRoot ? this.__hostRoot : this;
          i = children.indexOf(target);

          if (i === -1) {
            throw new Error('Index exception of insertBefore()');
          }

          target.__next = child;
          child.__prev = target;
          children.splice(i + 1, 0, child);
          parent.__zIndexChildren = genZIndexChildren(parent);
        } else {
          throw new Error('InsertAfter() illegal');
        } // 离屏情况，不刷新


        if (this.__isDestroyed) {
          if (isFunction$4(cb)) {
            cb();
          }

          return;
        } // 在dom中则整体设置关系和struct，不可见提前跳出


        builder.relation(root, parent.__host, parent, child, {});

        parent.__insertStruct(child, parent.__zIndexChildren.indexOf(child));

        if (child.currentStyle[DISPLAY$3] === 'none' || parent.__computedStyle[DISPLAY$3] === 'none') {
          child.__layoutNone();

          if (isFunction$4(cb)) {
            cb();
          }

          return;
        }

        if (child instanceof Text) {
          child = parent;
        }

        root.__addUpdate(child, {
          focus: o$1.REFLOW,
          addDom: true,
          cb: cb
        });
      }
    }, {
      key: "removeChild",
      value: function removeChild(target, cb) {
        if ((target.__parent === this || target.__domParent === this) && (target instanceof Node || target instanceof Component)) {
          target.remove(cb);
        } else {
          inject.error('Invalid parameter of removeChild()');
        }
      }
    }, {
      key: "children",
      get: function get() {
        return this.__children;
      }
    }, {
      key: "flowChildren",
      get: function get() {
        return this.__children.filter(function (item) {
          if (item instanceof Component) {
            item = item.shadowRoot;
          }

          return item instanceof Text || item.__currentStyle[POSITION$1] !== 'absolute';
        });
      }
    }, {
      key: "absChildren",
      get: function get() {
        return this.__children.filter(function (item) {
          if (item instanceof Component) {
            item = item.__shadowRoot;
          }

          return item instanceof Xom && item.__currentStyle[POSITION$1] === 'absolute';
        });
      }
    }, {
      key: "zIndexChildren",
      get: function get() {
        return this.__zIndexChildren;
      }
    }, {
      key: "lineBoxManager",
      get: function get() {
        return this.__lineBoxManager;
      }
    }, {
      key: "baseline",
      get: function get() {
        var _this$computedStyle2 = this.computedStyle,
            marginTop = _this$computedStyle2[MARGIN_TOP],
            borderTopWidth = _this$computedStyle2[BORDER_TOP_WIDTH],
            paddingTop = _this$computedStyle2[PADDING_TOP],
            writingMode = _this$computedStyle2[WRITING_MODE$1];

        if (!this.lineBoxManager || !this.lineBoxManager.size || writingMode.indexOf('vertical') === 0) {
          return this.offsetHeight;
        }

        return marginTop + borderTopWidth + paddingTop + this.lineBoxManager.baseline;
      }
    }, {
      key: "firstBaseline",
      get: function get() {
        if (!this.lineBoxManager || !this.lineBoxManager.size) {
          return this.offsetHeight;
        }

        var _this$computedStyle3 = this.computedStyle,
            marginTop = _this$computedStyle3[MARGIN_TOP],
            borderTopWidth = _this$computedStyle3[BORDER_TOP_WIDTH],
            paddingTop = _this$computedStyle3[PADDING_TOP];
        return marginTop + borderTopWidth + paddingTop + this.lineBoxManager.firstBaseline;
      }
    }, {
      key: "verticalBaseline",
      get: function get() {
        if (!this.lineBoxManager || !this.lineBoxManager.size) {
          return 0;
        }

        var _this$computedStyle4 = this.computedStyle,
            marginLeft = _this$computedStyle4[MARGIN_LEFT$1],
            borderLeftWidth = _this$computedStyle4[BORDER_LEFT_WIDTH$1],
            paddingLeft = _this$computedStyle4[PADDING_LEFT$1],
            writingMode = _this$computedStyle4[WRITING_MODE$1];

        if (!this.lineBoxManager || !this.lineBoxManager.size || writingMode.indexOf('vertical') === -1) {
          return 0;
        }

        return marginLeft + borderLeftWidth + paddingLeft + this.lineBoxManager.verticalBaseline;
      }
    }]);

    return Dom;
  }(Xom);

  var _enums$STYLE_KEY$3 = enums.STYLE_KEY,
      WIDTH$1 = _enums$STYLE_KEY$3.WIDTH,
      HEIGHT$1 = _enums$STYLE_KEY$3.HEIGHT,
      DISPLAY$2 = _enums$STYLE_KEY$3.DISPLAY,
      BORDER_RIGHT_WIDTH = _enums$STYLE_KEY$3.BORDER_RIGHT_WIDTH,
      BORDER_LEFT_WIDTH = _enums$STYLE_KEY$3.BORDER_LEFT_WIDTH,
      BORDER_TOP_LEFT_RADIUS = _enums$STYLE_KEY$3.BORDER_TOP_LEFT_RADIUS,
      BORDER_TOP_RIGHT_RADIUS = _enums$STYLE_KEY$3.BORDER_TOP_RIGHT_RADIUS,
      BORDER_BOTTOM_RIGHT_RADIUS = _enums$STYLE_KEY$3.BORDER_BOTTOM_RIGHT_RADIUS,
      BORDER_BOTTOM_LEFT_RADIUS = _enums$STYLE_KEY$3.BORDER_BOTTOM_LEFT_RADIUS,
      VISIBILITY$2 = _enums$STYLE_KEY$3.VISIBILITY,
      MARGIN_RIGHT = _enums$STYLE_KEY$3.MARGIN_RIGHT,
      MARGIN_LEFT = _enums$STYLE_KEY$3.MARGIN_LEFT,
      PADDING_RIGHT = _enums$STYLE_KEY$3.PADDING_RIGHT,
      PADDING_LEFT = _enums$STYLE_KEY$3.PADDING_LEFT,
      FONT_SIZE = _enums$STYLE_KEY$3.FONT_SIZE,
      FLEX_BASIS = _enums$STYLE_KEY$3.FLEX_BASIS;
  var AUTO = o$4.AUTO,
      PX$1 = o$4.PX,
      PERCENT = o$4.PERCENT,
      REM = o$4.REM,
      VW = o$4.VW,
      VH = o$4.VH,
      VMAX = o$4.VMAX,
      VMIN = o$4.VMIN;
  var canvasPolygon$1 = painter.canvasPolygon,
      svgPolygon = painter.svgPolygon;
  var isFunction$3 = util.isFunction;

  var Img = /*#__PURE__*/function (_Dom) {
    _inherits(Img, _Dom);

    function Img(tagName, props) {
      var _this;

      _this = _Dom.call(this, tagName, props) || this;
      var src = _this.props.src;
      var loadImg = _this.__loadImg = {
        src: src
      }; // 空url用错误图代替

      if (!src) {
        loadImg.error = true;
      } else {
        var ca = inject.IMG[src];

        if (!ca) {
          inject.measureImg(src, null);
        } else if (ca && ca.state === inject.LOADED) {
          loadImg.source = ca.source;
          loadImg.width = ca.width;
          loadImg.height = ca.height;
        }
      }

      return _this;
    }
    /**
     * 覆盖xom的方法，在__layout()3个分支中会首先被调用
     * 当样式中固定宽高时，图片按样式尺寸，加载后重新绘制即可
     * 只固定宽高一个时，加载完要计算缩放比，重新布局绘制
     * 都没有固定，按照图片尺寸，重新布局绘制
     * 这里计算非固定的情况，将其改为固定供布局渲染使用，未加载完成为0
     */


    _createClass(Img, [{
      key: "__preLayout",
      value: function __preLayout(data, isInline) {
        var res = _get(_getPrototypeOf(Img.prototype), "__preLayout", this).call(this, data, false);

        var loadImg = this.__loadImg; // 可能已提前加载好了，或有缓存，为减少刷新直接使用

        var src = loadImg.src;

        if (src) {
          var cache = inject.IMG[src];

          if (!cache || cache.state === inject.LOADING) {
            if (!loadImg.loading) {
              this.__loadAndRefresh(loadImg, null);
            }
          } else if (cache && cache.state === inject.LOADED && cache.success) {
            loadImg.source = cache.source;
            loadImg.width = cache.width;
            loadImg.height = cache.height;
          }

          loadImg.cache = false;
        }

        if (res.fixedWidth && res.fixedHeight) {
          return res;
        }

        if (loadImg.error && !this.props.placeholder) {
          if (res.fixedWidth) {
            res.h = res.w;
          } else if (res.fixedHeight) {
            res.w = res.h;
          } else {
            res.w = res.h = 32;
          }
        } else if (loadImg.source) {
          if (res.fixedWidth) {
            res.h = res.w * loadImg.height / loadImg.width;
          } else if (res.fixedHeight) {
            res.w = res.h * loadImg.width / loadImg.height;
          } else {
            res.w = loadImg.width;
            res.h = loadImg.height;
          }
        } else {
          res.w = res.h = 0;
        }

        res.fixedWidth = true;
        res.fixedHeight = true;
        return res;
      }
    }, {
      key: "__addGeom",
      value: function __addGeom(tagName, props) {
        props = util.hash2arr(props);
        this.virtualDom.children.push({
          type: 'item',
          tagName: tagName,
          props: props
        });
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        this.root.delRefreshTask(this.__task);

        _get(_getPrototypeOf(Img.prototype), "__destroy", this).call(this);

        this.__task = null;
      } // img根据加载情况更新__hasContent

    }, {
      key: "calContent",
      value: function calContent(__currentStyle, __computedStyle) {
        var res = _get(_getPrototypeOf(Img.prototype), "calContent", this).call(this, __currentStyle, __computedStyle);

        if (!res) {
          var loadImg = this.__loadImg; // if(loadImg.loading) {
          //   this.__loadAndRefresh(loadImg, null);
          // }

          if (__computedStyle[VISIBILITY$2] !== 'hidden' && (__computedStyle[WIDTH$1] || __computedStyle[HEIGHT$1]) && loadImg.source) {
            res = true;
          }
        }

        return res;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx) {
        var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        var res = _get(_getPrototypeOf(Img.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        var width = this.width,
            height = this.height,
            __isDestroyed = this.__isDestroyed,
            placeholder = this.props.placeholder,
            _this$__computedStyle = this.__computedStyle,
            display = _this$__computedStyle[DISPLAY$2],
            borderTopLeftRadius = _this$__computedStyle[BORDER_TOP_LEFT_RADIUS],
            borderTopRightRadius = _this$__computedStyle[BORDER_TOP_RIGHT_RADIUS],
            borderBottomRightRadius = _this$__computedStyle[BORDER_BOTTOM_RIGHT_RADIUS],
            borderBottomLeftRadius = _this$__computedStyle[BORDER_BOTTOM_LEFT_RADIUS],
            visibility = _this$__computedStyle[VISIBILITY$2],
            virtualDom = this.virtualDom,
            loadImg = this.__loadImg;

        if (__isDestroyed || display === 'none' || visibility === 'hidden' || renderMode === mode.WEBGL) {
          return res;
        }

        var originX, originY;
        originX = res.sx3 + dx;
        originY = res.sy3 + dy; // 根据配置以及占位图显示error

        var source = loadImg.source;

        if (loadImg.error && !placeholder && Img.showError) {
          var strokeWidth = Math.min(width, height) * 0.02;
          var stroke = '#CCC';
          var fill = '#DDD';
          var cx = originX + width * 0.7;
          var cy = originY + height * 0.3;
          var r = strokeWidth * 5;
          var pts = [[originX + width * 0.15, originY + height * 0.7], [originX + width * 0.3, originY + height * 0.4], [originX + width * 0.5, originY + height * 0.6], [originX + width * 0.6, originY + height * 0.5], [originX + width * 0.9, originY + height * 0.8], [originX + width * 0.15, originY + height * 0.8]];

          if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
            ctx.strokeStyle = stroke;
            ctx.lineWidth = strokeWidth;
            ctx.fillStyle = fill;
            ctx.beginPath();
            ctx.moveTo(originX, originY);
            ctx.lineTo(originX + width, originY);
            ctx.lineTo(originX + width, originY + height);
            ctx.lineTo(originX, originY + height);
            ctx.lineTo(originX, originY);
            ctx.stroke();
            ctx.closePath();
            ctx.beginPath();
            var points = geom$1.ellipsePoints(cx, cy, r, r);
            painter.canvasPolygon(ctx, points, 0, 0);
            ctx.fill();
            ctx.closePath();
            ctx.beginPath();
            ctx.moveTo(pts[0][0], pts[0][1]);

            for (var i = 1, len = pts.length; i < len; i++) {
              var point = pts[i];
              ctx.lineTo(point[0], point[1]);
            }

            ctx.lineTo(pts[0][0], pts[0][1]);
            ctx.fill();
            ctx.closePath();
          } else if (renderMode === mode.SVG) {
            this.__addGeom('rect', [['x', originX], ['y', originY], ['width', width], ['height', height], ['stroke', stroke], ['stroke-width', strokeWidth], ['fill', 'rgba(0,0,0,0)']]);

            this.__addGeom('circle', [['cx', cx], ['cy', cy], ['r', r], ['fill', fill]]);

            var s = '';

            for (var _i = 0, _len = pts.length; _i < _len; _i++) {
              var _point = pts[_i];

              if (_i) {
                s += ' ';
              }

              s += _point[0] + ',' + _point[1];
            }

            this.__addGeom('polygon', [['points', s], ['fill', fill]]);
          }
        } else if (source) {
          // 圆角需要生成一个mask
          var list = border.calRadius(originX, originY, width, height, borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius);

          if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
            // 有border-radius需模拟遮罩裁剪
            if (list) {
              ctx.save();
              ctx.beginPath();
              canvasPolygon$1(ctx, list, dx, dy);
              ctx.clip();
              ctx.closePath();
              ctx.drawImage(source, originX, originY, width, height);
              ctx.restore();
            } else {
              ctx.drawImage(source, originX, originY, width, height);
            }
          } else if (renderMode === mode.SVG) {
            // img没有变化无需diff，直接用上次的vd
            if (loadImg.cache) {
              loadImg.cache.cache = true;
              virtualDom.children = [loadImg.cache]; // 但是还是要校验是否有borderRadius变化，引发img的圆角遮罩

              if (!virtualDom.cache && list) {
                var d = svgPolygon(list);
                var v = {
                  tagName: 'clipPath',
                  props: [],
                  children: [{
                    type: 'item',
                    tagName: 'path',
                    props: [['d', d], ['fill', '#FFF']]
                  }]
                };
                var id = ctx.add(v);

                this.__cacheDefs.push(v);

                virtualDom.conClip = 'url(#' + id + ')';
              }

              return;
            } // 缩放图片，无需考虑原先矩阵，xom里对父层<g>已经变换过了


            var matrix;

            if (width !== loadImg.width || height !== loadImg.height) {
              matrix = image.matrixResize(loadImg.width, loadImg.height, width, height, originX, originY, width, height);
            }

            var props = [['xlink:href', loadImg.error ? placeholder : loadImg.src], ['x', originX], ['y', originY], ['width', loadImg.width], ['height', loadImg.height]];

            if (list) {
              var _d = svgPolygon(list);

              var _v = {
                tagName: 'clipPath',
                props: [],
                children: [{
                  type: 'item',
                  tagName: 'path',
                  props: [['d', _d], ['fill', '#FFF']]
                }]
              };

              var _id = ctx.add(_v);

              this.__cacheDefs.push(_v);

              virtualDom.conClip = 'url(#' + _id + ')';
              delete virtualDom.cache;
            }

            if (matrix && !mx.isE(matrix)) {
              props.push(['transform', 'matrix(' + util.joinArr(mx.m2m6(matrix), ',') + ')']);
            }

            var vd = {
              type: 'img',
              tagName: 'image',
              props: props
            };
            virtualDom.children = [vd];
            loadImg.cache = vd;
          }
        }

        return res;
      }
    }, {
      key: "__isRealInline",
      value: function __isRealInline() {
        return false;
      } // overwrite

    }, {
      key: "__tryLayInline",
      value: function __tryLayInline(w, total) {
        var _this$currentStyle = this.currentStyle,
            width = _this$currentStyle[WIDTH$1],
            height = _this$currentStyle[HEIGHT$1],
            marginLeft = _this$currentStyle[MARGIN_LEFT],
            marginRight = _this$currentStyle[MARGIN_RIGHT],
            paddingLeft = _this$currentStyle[PADDING_LEFT],
            paddingRight = _this$currentStyle[PADDING_RIGHT],
            _this$computedStyle = this.computedStyle,
            borderLeftWidth = _this$computedStyle[BORDER_LEFT_WIDTH],
            borderRightWidth = _this$computedStyle[BORDER_RIGHT_WIDTH];

        if (width.u !== AUTO) {
          w -= this.__calSize(width, total, true);
        } else {
          var loadImg = this.__loadImg; // 加载成功计算缩放后的宽度

          if (loadImg.source) {
            if (height.u === PX$1) {
              w -= loadImg.width * height.v / loadImg.height;
            } else if (height.u === PERCENT) {
              w -= loadImg.width * height.v * total * 0.01 / loadImg.height;
            } else if (height.u === REM) {
              w -= loadImg.width * height.v * this.root.computedStyle[FONT_SIZE] / loadImg.height;
            } else if (height.u === VW) {
              w -= loadImg.width * height.v * this.root.width * 0.01 / loadImg.height;
            } else if (height.u === VH) {
              w -= loadImg.width * height.v * this.root.height * 0.01 / loadImg.height;
            } else if (height.u === VMAX) {
              w -= height.v * Math.max(this.root.width, this.root.height) * 0.01 / loadImg.height;
            } else if (height.u === VMIN) {
              w -= height.v * Math.min(this.root.width, this.root.height) * 0.01 / loadImg.height;
            } else {
              w -= loadImg.width;
            }
          }
        } // 减去水平mbp


        w -= this.__calSize(marginRight, total, true);
        w -= this.__calSize(paddingRight, total, true);
        w -= borderRightWidth;
        w -= this.__calSize(marginLeft, total, true);
        w -= this.__calSize(paddingLeft, total, true);
        w -= borderLeftWidth;
        return w;
      }
    }, {
      key: "__calBasis",
      value: function __calBasis(isDirectionRow, isAbs, isColumn, data, isDirectChild) {
        this.__computeReflow();

        var b = 0;
        var min = 0;
        var max = 0;
        var currentStyle = this.currentStyle,
            computedStyle = this.computedStyle,
            __loadImg = this.__loadImg;
        var w = data.w,
            h = data.h; // 计算需考虑style的属性

        var flexBasis = currentStyle[FLEX_BASIS],
            width = currentStyle[WIDTH$1],
            height = currentStyle[HEIGHT$1];
        var main = isDirectionRow ? width : height;
        var cross = isDirectionRow ? height : width; // basis3种情况：auto、固定、content，只区分固定和其它

        var isFixed = [PX$1, PERCENT, REM, VW, VH, VMAX, VMIN].indexOf(flexBasis.u) > -1;

        if (isFixed) {
          b = max = min = this.__calSize(flexBasis, isDirectionRow ? w : h, true);
        } else if ([PX$1, PERCENT, REM, VW, VH, VMAX, VMIN].indexOf(main.u) > -1) {
          b = max = min = this.__calSize(main, isDirectionRow ? w : h, true);
        } // auto和content固定尺寸比例计算
        else if (__loadImg.source || __loadImg.error) {
          var res = this.__preLayout(data);

          if (cross.u !== AUTO) {
            cross = this.__calSize(cross, isDirectionRow ? h : w, true);
            var ratio = res.w / res.h;
            b = max = min = isDirectionRow ? cross * ratio : cross / ratio;
          } else {
            b = max = min = isDirectionRow ? res.w : res.h;
          }
        } // 直接item的mpb影响basis


        return this.__addMBP(isDirectionRow, w, currentStyle, computedStyle, [b, min, max], isDirectChild);
      }
    }, {
      key: "__loadAndRefresh",
      value: function __loadAndRefresh(loadImg, cb) {
        var self = this; // 先清空之前可能的

        if (loadImg.source || loadImg.error) {
          loadImg.source = null;
        }

        loadImg.loading = true;
        var root = this.__root,
            ctx = root.ctx;
        var placeholder = this.props.placeholder,
            computedStyle = this.__computedStyle;
        var width = computedStyle[WIDTH$1],
            height = computedStyle[HEIGHT$1]; // 再测量，可能瞬间完成替换掉上面的

        inject.measureImg(loadImg.src, function (data) {
          // 还需判断url，防止重复加载时老的替换新的，失败走error绘制
          if (data.url === loadImg.src) {
            var reload = function reload() {
              var _self$__currentStyle = self.__currentStyle,
                  width = _self$__currentStyle[WIDTH$1],
                  height = _self$__currentStyle[HEIGHT$1];

              if (width.u !== AUTO && height.u !== AUTO) {
                root.__addUpdate(self, {
                  focus: o$1.REPAINT,
                  // 已知宽高无需重新布局
                  cb: cb
                });
              } else {
                root.__addUpdate(self, {
                  focus: o$1.REFLOW,
                  cb: cb
                });
              }
            };

            loadImg.cache && (loadImg.cache.cache = false);
            loadImg.loading = false;

            if (data.success) {
              loadImg.source = data.source;
              loadImg.width = data.width;
              loadImg.height = data.height;
            } else if (placeholder) {
              loadImg.error = true;
              inject.measureImg(placeholder, function (data) {
                if (data.success) {
                  loadImg.source = data.source;
                  loadImg.width = data.width;
                  loadImg.height = data.height;

                  if (computedStyle[DISPLAY$2] !== 'none' && !self.__isDestroyed) {
                    reload();
                  }
                }
              }, {
                ctx: ctx,
                root: root,
                width: width,
                height: height
              });
              return;
            } else {
              loadImg.error = true;
            } // 可见状态进行刷新操作，visibility某些情况需要刷新，可能宽高未定义要重新布局


            if (computedStyle[DISPLAY$2] !== 'none' && !self.__isDestroyed) {
              reload();
            }
          }
        }, {
          ctx: ctx,
          root: root,
          width: width,
          height: height
        });
      }
    }, {
      key: "updateSrc",
      value: function updateSrc(v, cb) {
        var loadImg = this.__loadImg; // 相等或空且当前error直接返回

        if (v === loadImg.src || this.__isDestroyed || !v && loadImg.error) {
          loadImg.src = v;
          inject.measureImg(v, null);

          if (isFunction$3(cb)) {
            cb();
          }

          return;
        }

        loadImg.src = v;

        this.__loadAndRefresh(loadImg, cb);
      }
    }, {
      key: "appendChild",
      value: function appendChild() {
        inject.error('Img can not appendChild.');
      }
    }, {
      key: "src",
      get: function get() {
        return this.__loadImg.src;
      }
    }, {
      key: "isReplaced",
      get: function get() {
        return true;
      }
    }]);

    return Img;
  }(Dom);

  _defineProperty(Img, "showError", true);

  var Defs = /*#__PURE__*/function () {
    function Defs(uuid) {
      this.id = uuid;
      this.count = 0;
      this.list = [];
      this.cacheHash = {}; // 每次svg渲染前重置，存储前次渲染不变的缓存id
    }

    _createClass(Defs, [{
      key: "add",
      value: function add(data) {
        var uuid = this.count;
        var hash = this.cacheHash;

        while (hash.hasOwnProperty(uuid)) {
          uuid++;
        }

        this.count = uuid + 1;
        data.id = uuid;
        data.uuid = 'karas-defs-' + this.id + '-' + uuid;
        data.index = this.list.length;
        this.list.push(data);
        return data.uuid;
      }
    }, {
      key: "addCache",
      value: function addCache(data) {
        data.index = this.list.length;
        this.list.push(data);
        this.cacheHash[data.id] = true;
        return data.uuid;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.list = [];
        this.count = 0;
        this.cacheHash = {};
      }
    }, {
      key: "removeCache",
      value: function removeCache(data) {
        var list = this.list;
        var i = data.index; // 一般情况index即位置，但每次渲染过程中，可能会删掉一些，此时位置会往前，但index不变，因此遍历

        for (; i >= 0; i--) {
          if (list[i] === data) {
            list.splice(i, 1);
            return;
          }
        }
      }
    }, {
      key: "value",
      get: function get() {
        return this.list;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(uuid) {
        return new Defs(uuid);
      }
    }]);

    return Defs;
  }();

  var joinVd = util.joinVd,
      joinDef = util.joinDef;
  var contain$2 = o$1.contain,
      NONE$2 = o$1.NONE,
      TRANSFORM_ALL$2 = o$1.TRANSFORM_ALL,
      OPACITY$2 = o$1.OPACITY,
      FILTER$1 = o$1.FILTER,
      MIX_BLEND_MODE$2 = o$1.MIX_BLEND_MODE;

  function diff(elem, ovd, nvd) {
    var cns = elem.childNodes;
    diffDefs(cns[0], ovd.defs, nvd.defs); // <REPAINT不会有lv属性，无需对比

    if (!nvd.hasOwnProperty('lv')) {
      diffBb(cns[1], ovd.bb, nvd.bb);
    }

    diffD2D(elem, ovd, nvd, true);
  }

  function diffDefs(elem, od, nd) {
    var ol = od.length;
    var nl = nd.length;
    var i = 0;
    var cns = elem.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      diffDef(cns[i], od[i], nd[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinDef(nd[i]));
      }
    }
  }

  function diffDef(elem, od, nd) {
    if (od.tagName !== nd.tagName) {
      insertAdjacentHTML(elem, 'beforebegin', joinDef(nd)); // elem.insertAdjacentHTML('beforebegin', joinDef(nd));

      elem.parentNode.removeChild(elem);
    } else {
      if (od.uuid !== nd.uuid) {
        elem.setAttribute('id', nd.uuid);
      }

      var op = {};

      for (var _i = 0, len = (od.props || []).length; _i < len; _i++) {
        var prop = od.props[_i];

        var _prop = _slicedToArray(prop, 2),
            k = _prop[0],
            v = _prop[1];

        op[k] = v;
      }

      for (var _i2 = 0, _len = (nd.props || []).length; _i2 < _len; _i2++) {
        var _prop2 = nd.props[_i2];

        var _prop3 = _slicedToArray(_prop2, 2),
            _k = _prop3[0],
            _v = _prop3[1]; // 已有不等更新，没有添加


        if (op.hasOwnProperty(_k)) {
          if (op[_k] !== _v) {
            elem.setAttribute(_k, _v);
          }

          delete op[_k];
        } else {
          elem.setAttribute(_k, _v);
        }
      } // 多余的删除


      Object.keys(op).forEach(function (i) {
        elem.removeAttribute(i);
      });
      var cns = elem.childNodes;
      var ol = od.children.length;
      var nl = nd.children.length;
      var i = 0;

      for (; i < Math.min(ol, nl); i++) {
        diffItem(elem, i, od.children[i], nd.children[i]);
      }

      if (i < ol) {
        for (var j = ol - 1; j >= i; j--) {
          removeAt(elem, cns, j);
        }
      } else if (i < nl) {
        for (; i < nl; i++) {
          insertAt(elem, cns, i, joinVd(nd.children[i]));
        }
      }
    }
  }

  function diffChild$1(elem, ovd, nvd) {
    if (ovd.type === 'dom') {
      if (nvd.type === 'dom') {
        diffD2D(elem, ovd, nvd);
      } else if (nvd.type === 'geom') {
        diffD2G(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'text') {
      if (nvd.type === 'text') {
        diffT2T(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'geom') {
      if (nvd.type === 'dom') {
        diffG2D(elem, ovd, nvd);
      } else if (nvd.type === 'geom') {
        diffG2G(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } else if (ovd.type === 'img') {
      if (nvd.type === 'img') {
        diffItemSelf(elem, ovd, nvd);
      } else {
        replaceWith(elem, nvd);
      }
    } // 特殊情况，当有连续2个img，后面1个发生error时，其children内容不是type为img的图片，而是矢量图item，会进入此分支
    else if (ovd.type === 'item' && nvd.type === 'item') {
      diffItemSelf(elem, ovd, nvd);
    }
  }

  function diffX2X(elem, ovd, nvd) {
    var transform = nvd.transform,
        opacity = nvd.opacity,
        visibility = nvd.visibility,
        mask = nvd.mask,
        overflow = nvd.overflow,
        filter = nvd.filter,
        mixBlendMode = nvd.mixBlendMode,
        conClip = nvd.conClip;

    if (ovd.transform !== transform) {
      if (transform) {
        elem.setAttribute('transform', transform);
      } else {
        elem.removeAttribute('transform');
      }
    }

    if (ovd.opacity !== opacity) {
      if (opacity !== 1 && opacity !== undefined) {
        elem.setAttribute('opacity', opacity);
      } else {
        elem.removeAttribute('opacity');
      }
    }

    if (ovd.visibility !== visibility) {
      elem.setAttribute('visibility', visibility);
    }

    if (ovd.mask !== mask) {
      if (mask) {
        elem.setAttribute('mask', mask);
      } else {
        elem.removeAttribute('mask');
      }
    }

    if (ovd.filter !== filter || ovd.mixBlendMode !== mixBlendMode) {
      var s = (filter ? "filter:".concat(filter, ";") : '') + (mixBlendMode ? "mix-blend-mode:".concat(mixBlendMode, ";") : '');

      if (s) {
        elem.setAttribute('style', s);
      } else {
        elem.removeAttribute('filter');
      }
    } // if(ovd.filter !== filter) {
    //   if(filter) {
    //     elem.setAttribute('filter', filter);
    //   }
    //   else {
    //     elem.removeAttribute('filter');
    //   }
    // }


    if (ovd.overflow !== overflow) {
      if (overflow) {
        elem.setAttribute('clipPath', overflow);
      } else {
        elem.removeAttribute('overflow');
      }
    }

    if (ovd.conClip !== conClip) {
      if (conClip) {
        elem.childNodes[1].setAttribute('clip-path', conClip);
      } else {
        elem.childNodes[1].removeAttribute('clip-path');
      }
    }
  }

  function diffByLessLv(elem, ovd, nvd, lv) {
    var transform = nvd.transform,
        opacity = nvd.opacity,
        mask = nvd.mask,
        filter = nvd.filter,
        mixBlendMode = nvd.mixBlendMode;

    if (mask) {
      elem.setAttribute('mask', mask);
    } else {
      elem.removeAttribute('mask');
    }

    if (lv === NONE$2) {
      return;
    }

    if (contain$2(lv, TRANSFORM_ALL$2)) {
      if (transform) {
        elem.setAttribute('transform', transform);
      } else {
        elem.removeAttribute('transform');
      }
    }

    if (contain$2(lv, OPACITY$2)) {
      if (opacity !== 1 && opacity !== undefined) {
        elem.setAttribute('opacity', opacity);
      } else {
        elem.removeAttribute('opacity');
      }
    }

    if (contain$2(lv, FILTER$1) || contain$2(lv, MIX_BLEND_MODE$2)) {
      var s = (filter ? "filter:".concat(filter, ";") : '') + (mixBlendMode ? "mix-blend-mode:".concat(mixBlendMode, ";") : '');

      if (s) {
        elem.setAttribute('style', s);
      } else {
        elem.removeAttribute('style');
      }
    }
  }

  function diffD2D(elem, ovd, nvd, root) {
    // cache表明children无变化缓存，一定是REPAINT以下的，只需看自身的lv以及mask
    if (nvd.cache) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
      return;
    } // 无cache且<REPAINT的情况快速对比且继续对比children


    if (nvd.hasOwnProperty('lv')) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
    } else {
      diffX2X(elem, ovd, nvd);

      if (!root) {
        diffBb(elem.firstChild, ovd.bb, nvd.bb);
      }
    }

    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;
    var lastChild = elem.lastChild;
    var cns = lastChild.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      diffChild$1(cns[i], ovd.children[i], nvd.children[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(lastChild, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
      }
    }
  }

  function diffD2G(elem, ovd, nvd) {
    diffX2X(elem, ovd, nvd);
    diffBb(elem.firstChild, ovd.bb, nvd.bb);
    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;
    var lastChild = elem.lastChild;
    var cns = lastChild.childNodes;

    for (; i < Math.min(ol, nl); i++) {
      replaceWith(cns[i], nvd.children[i]);
    }

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(lastChild, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
      }
    }
  }

  function diffT2T(elem, ovd, nvd) {
    if (nvd.cache) {
      return;
    }

    var ol = ovd.children.length;
    var nl = nvd.children.length;
    var i = 0;

    for (; i < Math.min(ol, nl); i++) {
      diffItem(elem, i, ovd.children[i], nvd.children[i], true);
    }

    var cns = elem.childNodes;

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinVd(nvd.children[i]));
      }
    }
  }

  function diffG2D(elem, ovd, nvd) {
    diffD2G(elem, ovd, nvd);
  }

  function diffG2G(elem, ovd, nvd) {
    if (nvd.cache) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
      return;
    } // 无cache且<REPAINT的情况快速对比且继续对比children


    if (nvd.hasOwnProperty('lv')) {
      diffByLessLv(elem, ovd, nvd, nvd.lv);
    } else {
      diffX2X(elem, ovd, nvd);
      diffBb(elem.firstChild, ovd.bb, nvd.bb);
      var ol = ovd.children.length;
      var nl = nvd.children.length;
      var i = 0;
      var lastChild = elem.lastChild;
      var cns = lastChild.childNodes;

      for (; i < Math.min(ol, nl); i++) {
        diffItem(lastChild, i, ovd.children[i], nvd.children[i]);
      }

      if (i < ol) {
        for (var j = ol - 1; j >= i; j--) {
          removeAt(lastChild, cns, j);
        }
      } else if (i < nl) {
        for (; i < nl; i++) {
          insertAt(lastChild, cns, i, joinVd(nvd.children[i]));
        }
      }
    }
  }

  function diffBb(elem, obb, nbb) {
    var ol = obb.length;
    var nl = nbb.length;
    var i = 0;

    for (; i < Math.min(ol, nl); i++) {
      diffItem(elem, i, obb[i], nbb[i]);
    }

    var cns = elem.childNodes;

    if (i < ol) {
      for (var j = ol - 1; j >= i; j--) {
        removeAt(elem, cns, j);
      }
    } else if (i < nl) {
      for (; i < nl; i++) {
        insertAt(elem, cns, i, joinVd(nbb[i]));
      }
    }
  }

  function diffItem(elem, i, ovd, nvd, isText) {
    var cns = elem.childNodes;

    if (ovd.tagName !== nvd.tagName) {
      replaceWith(cns[i], nvd);
    } else {
      diffItemSelf(cns[i], ovd, nvd);

      if (isText && ovd.content !== nvd.content) {
        cns[i].innerHTML = nvd.content;
      }
    }
  }

  function diffItemSelf(elem, ovd, nvd) {
    if (nvd.cache) {
      return;
    }

    var op = {};

    for (var i = 0, len = (ovd.props || []).length; i < len; i++) {
      var prop = ovd.props[i];

      var _prop4 = _slicedToArray(prop, 2),
          k = _prop4[0],
          v = _prop4[1];

      op[k] = v;
    }

    for (var _i3 = 0, _len2 = (nvd.props || []).length; _i3 < _len2; _i3++) {
      var _prop5 = nvd.props[_i3];

      var _prop6 = _slicedToArray(_prop5, 2),
          _k2 = _prop6[0],
          _v2 = _prop6[1]; // 已有不等更新，没有添加


      if (op.hasOwnProperty(_k2)) {
        if (op[_k2] !== _v2) {
          elem.setAttribute(_k2, _v2);
        }

        delete op[_k2];
      } else {
        elem.setAttribute(_k2, _v2);
      }
    } // 多余的删除


    Object.keys(op).forEach(function (i) {
      elem.removeAttribute(i);
    });
  }

  function replaceWith(elem, vd) {
    var res;

    if (Array.isArray(vd)) {
      res = '';
      vd.forEach(function (item) {
        res += joinVd(item);
      });
    } else {
      res = joinVd(vd);
    }

    insertAdjacentHTML(elem, 'beforebegin', res); // elem.insertAdjacentHTML('beforebegin', res);

    elem.parentNode.removeChild(elem);
  }

  function insertAt(elem, cns, index, html) {
    if (index >= cns.length) {
      insertAdjacentHTML(elem, 'beforeend', html); // elem.insertAdjacentHTML('beforeend', html);
    } else {
      insertAdjacentHTML(cns[index], 'beforebegin', html); // cns[index].insertAdjacentHTML('beforebegin', html);
    }
  }

  function removeAt(elem, cns, index) {
    if (cns[index]) {
      elem.removeChild(cns[index]);
    }
  }

  var svg;

  function insertAdjacentHTML(elem, where, content) {
    if (elem.insertAdjacentHTML) {
      elem.insertAdjacentHTML(where, content);
    } else {
      switch (where) {
        case 'beforeend':
          elem.innerHTML += content;
          break;

        case 'beforebegin':
          svg = svg || document.createElement('svg');
          svg.innerHTML = content;
          elem.parentNode.insertBefore(svg.childNodes[0], elem);
          break;
      }
    }
  }

  var isFunction$2 = util.isFunction;

  var Controller = /*#__PURE__*/function () {
    function Controller() {
      this.__records = []; // 默认记录和自动记录

      this.__records2 = []; // 非自动播放的动画记录

      this.__list = []; // 默认初始化播放列表，自动播放也存这里

      this.__list2 = []; // json中autoPlay为false的初始化存入这里

      this.__onList = []; // list中已存在的侦听事件，list2初始化时也需要增加上

      this.__lastTime = {}; // 每个类型的上次触发时间，防止重复emit
    }

    _createClass(Controller, [{
      key: "add",
      value: function add(v) {
        var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.list;

        if (list.indexOf(v) === -1) {
          list.push(v);
        }
      }
    }, {
      key: "remove",
      value: function remove(v) {
        var i = this.list.indexOf(v);

        if (i > -1) {
          this.list.splice(i, 1);
        }
      }
    }, {
      key: "__destroy",
      value: function __destroy() {
        this.__records = [];
        this.__records2 = [];
        this.__list = [];
        this.__list2 = [];
      }
    }, {
      key: "__action",
      value: function __action(k, args) {
        this.list.forEach(function (item) {
          item[k].apply(item, args);
        });
      }
    }, {
      key: "init",
      value: function init() {
        var _this = this;

        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.__records;
        var list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.list;

        // 检查尚未初始化的record，并初始化，后面才能调用各种控制方法
        if (records.length) {
          // 清除防止重复调用，并且新的json还会进入整体逻辑
          records.splice(0).forEach(function (item) {
            var target = item.target,
                animate = item.animate,
                offsetTime = item.offsetTime;

            if (target.isDestroyed || !animate) {
              return;
            }

            if (!Array.isArray(animate)) {
              animate = [animate];
            }

            animate.forEach(function (animate) {
              var value = animate.value,
                  options = animate.options;
              options.autoPlay = false;

              if (offsetTime) {
                options = Object.assign({}, options); // clone防止多个使用相同的干扰

                options.delay = options.delay || 0;
                options.delay += offsetTime;
              }

              var o = target.animate(value, options);

              _this.add(o, list);
            });
          });
        } // 非自动播放后初始化需检测事件，给非自动播放添加上，并清空本次


        if (records === this.__records2) {
          var onList = this.__onList;
          var list2 = this.list2;

          if (list2.length && onList.length) {
            list2.forEach(function (item) {
              onList.forEach(function (arr) {
                var cb = function cb() {
                  var time = item.timestamp;

                  if (time !== _this.__lastTime[arr[0]]) {
                    _this.__lastTime[arr[0]] = time;
                    arr[1] && arr[1]();
                  }
                };

                cb.__karasEventCb = arr[1];
                item.off(arr[0], arr[1]);
                item.on(arr[0], cb);
              });
            });
          }
        }
      }
    }, {
      key: "__playAuto",
      value: function __playAuto() {
        this.init();

        this.__action('play');
      }
    }, {
      key: "play",
      value: function play(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('play', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$2(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "pause",
      value: function pause() {
        this.__action('pause');
      }
    }, {
      key: "resume",
      value: function resume(cb) {
        var once = true;

        this.__action('resume', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$2(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "__mergeAuto",
      value: function __mergeAuto() {
        this.init();
        this.init(this.__records2);

        if (this.__list2.length) {
          this.__list = this.__list.concat(this.__list2);
          this.__list2 = [];
        }
      }
    }, {
      key: "cancel",
      value: function cancel(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('cancel', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$2(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "finish",
      value: function finish(cb) {
        this.__mergeAuto();

        this.__onList = [];
        var once = true;

        this.__action('finish', [cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$2(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "gotoAndStop",
      value: function gotoAndStop(v, options, cb) {
        this.__mergeAuto();

        this.__onList = [];

        if (isFunction$2(options)) {
          cb = options;
          options = {};
        }

        var once = true;

        this.__action('gotoAndStop', [v, options, cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$2(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "gotoAndPlay",
      value: function gotoAndPlay(v, options, cb) {
        this.__mergeAuto();

        this.__onList = [];

        if (isFunction$2(options)) {
          cb = options;
          options = {};
        }

        var once = true;

        this.__action('gotoAndPlay', [v, options, cb && function (diff) {
          if (once) {
            once = false;

            if (isFunction$2(cb)) {
              cb(diff);
            }
          }
        }]);
      }
    }, {
      key: "on",
      value: function on(id, handle) {
        if (!isFunction$2(handle)) {
          return;
        }

        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            this.__on(id[i], handle);
          }

          this.__onList.push([id, handle]);
        } else {
          this.__on(id, handle);

          this.__onList.push([id, handle]);
        }
      }
    }, {
      key: "__on",
      value: function __on(id, handle) {
        var _this2 = this;

        this.list.forEach(function (item) {
          var cb = function cb() {
            var time = item.timestamp;

            if (time !== _this2.__lastTime[id]) {
              _this2.__lastTime[id] = time;
              handle && handle();
            }
          };

          cb.__karasEventCb = handle;
          item.on(id, cb);
        });
      }
    }, {
      key: "off",
      value: function off(id, handle) {
        if (Array.isArray(id)) {
          for (var i = 0, len = id.length; i < len; i++) {
            this.off(id[i], handle);
          }
        } else {
          this.list.forEach(function (item) {
            item.off(id, handle);
          });
        }
      }
    }, {
      key: "list",
      get: function get() {
        return this.__list;
      }
    }, {
      key: "list2",
      get: function get() {
        return this.__list2;
      }
    }, {
      key: "__set",
      value: function __set(key, value) {
        this.list.forEach(function (item) {
          item[key] = value;
        });
      }
    }, {
      key: "playbackRate",
      set: function set(v) {
        this.__set('playbackRate', v);
      }
    }, {
      key: "iterations",
      set: function set(v) {
        this.__set('iterations', v);
      }
    }, {
      key: "playCount",
      set: function set(v) {
        this.__set('playCount', v);
      }
    }, {
      key: "fps",
      set: function set(v) {
        this.__set('fps', v);
      }
    }, {
      key: "currentTime",
      set: function set(v) {
        this.__set('currentTime', v);
      }
    }, {
      key: "spfLimit",
      set: function set(v) {
        this.__set('spfLimit', v);
      }
    }, {
      key: "delay",
      set: function set(v) {
        this.__set('delay', v);
      }
    }, {
      key: "endDelay",
      set: function set(v) {
        this.__set('endDelay', v);
      }
    }, {
      key: "fill",
      set: function set(v) {
        this.__set('fill', v);
      }
    }, {
      key: "direction",
      set: function set(v) {
        this.__set('direction', v);
      }
    }]);

    return Controller;
  }();

  var SIZE = [8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192];
  var NUMBER = [128, 64, 32, 16, 8, 4, 2, 1, 1, 1, 1];
  var MAX = SIZE[SIZE.length - 1];
  var HASH_CANVAS = {};
  var uuid$1 = 0;

  var Page = /*#__PURE__*/function () {
    function Page(size, number) {
      this.__size = size;
      this.__number = number;
      this.__free = this.__total = number * number;
      size *= number;
      this.__width = size;
      this.__height = size;
      var offscreen = this.__canvas = inject.getCacheCanvas(size, size, null, number);

      if (offscreen) {
        this.__offscreen = offscreen;
      } // 1/0标识n*n个单元格是否空闲可用，一维数组表示


      this.__grid = [];

      for (var i = 0; i < this.__total; i++) {
        this.__grid.push(1);
      }

      this.__uuid = uuid$1++; // webgl贴图缓存使用，一旦更新则标识记录，绑定某号纹理单元查看变化才更新贴图

      this.__update = false;
      this.time = 0;
    }

    _createClass(Page, [{
      key: "add",
      value: function add() {
        var number = this.number,
            grid = this.grid;

        for (var i = 0; i < number; i++) {
          for (var j = 0; j < number; j++) {
            var index = i * number + j;

            if (grid[index]) {
              grid[index] = 0;
              this.__free--;
              return index;
            }
          }
        } // 理论不可能进入，除非bug


        throw new Error('Can not find free page');
      }
    }, {
      key: "del",
      value: function del(pos) {
        if (!this.grid[pos]) {
          this.grid[pos] = 1;
          this.__free++;
        }
      }
    }, {
      key: "getCoords",
      value: function getCoords(pos) {
        var size = this.size,
            number = this.number;
        var x = pos % number;
        var y = Math.floor(pos / number);
        return [x * size, y * size];
      }
    }, {
      key: "uuid",
      get: function get() {
        return this.__uuid;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__size;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "number",
      get: function get() {
        return this.__number;
      }
    }, {
      key: "total",
      get: function get() {
        return this.__total;
      }
    }, {
      key: "free",
      get: function get() {
        return this.__free;
      }
    }, {
      key: "grid",
      get: function get() {
        return this.__grid;
      }
    }, {
      key: "offscreen",
      get: function get() {
        return this.__offscreen;
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.__offscreen.canvas;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.__offscreen.ctx;
      }
    }, {
      key: "update",
      get: function get() {
        return this.__update;
      },
      set: function set(v) {
        this.__update = v;
      }
    }], [{
      key: "getInstance",
      value: function getInstance(size) {
        if (size > MAX) {
          return;
        }

        var s = SIZE[0];
        var n = NUMBER[0]; // 使用刚好满足的尺寸

        for (var i = 0, len = SIZE.length; i < len; i++) {
          s = SIZE[i];
          n = NUMBER[i];

          if (SIZE[i] >= size) {
            break;
          }
        }

        var list = HASH_CANVAS[s] = HASH_CANVAS[s] || []; // 从hash列表中尝试取可用的一页，找不到就生成新的页

        var page;

        for (var _i = 0, _len = list.length; _i < _len; _i++) {
          var item = list[_i];

          if (item.free) {
            page = item;
            break;
          }
        }

        if (!page) {
          page = new Page(s, n);

          if (!page.offscreen) {
            inject.error('Can not create off-screen for page');
            return;
          }

          list.push(page);
        }

        var pos = page.add();
        return {
          page: page,
          pos: pos
        };
      }
    }, {
      key: "CONFIG",
      get: function get() {
        return {
          SIZE: SIZE,
          NUMBER: NUMBER
        };
      },
      set: function set(v) {
        if (!v || !Array.isArray(v.SIZE) || !Array.isArray(v.NUMBER)) {
          return;
        }

        SIZE = v.SIZE;
        NUMBER = v.NUMBER;
        MAX = SIZE[SIZE.length - 1];
      }
    }, {
      key: "MAX",
      get: function get() {
        return MAX;
      }
    }, {
      key: "genUuid",
      value: function genUuid() {
        return uuid$1++;
      }
    }]);

    return Page;
  }();

  var _enums$STYLE_KEY$2 = enums.STYLE_KEY,
      TRANSFORM_ORIGIN$1 = _enums$STYLE_KEY$2.TRANSFORM_ORIGIN,
      TRANSFORM$2 = _enums$STYLE_KEY$2.TRANSFORM;
  var spreadFilter = css.spreadFilter;
  var isE$1 = mx.isE; // 根据一个共享cache的信息，生成一个独立的离屏canvas，一般是filter,mask用，可能尺寸会发生变化

  function genSingle(cache, message, bboxNew) {
    var size = cache.size,
        sx1 = cache.sx1,
        sy1 = cache.sy1,
        bbox = cache.bbox;
    bboxNew = bboxNew || bbox;
    var width = bboxNew[2] - bboxNew[0];
    var height = bboxNew[3] - bboxNew[1];
    var dx = bboxNew[0] - bbox[0];
    var dy = bboxNew[1] - bbox[1];
    var offscreen = inject.getCacheCanvas(width, height, null, message);
    offscreen.x = 0;
    offscreen.y = 0;
    offscreen.bbox = bboxNew;
    offscreen.size = size;
    offscreen.sx1 = sx1;
    offscreen.sy1 = sy1;
    offscreen.dx = -bboxNew[0];
    offscreen.dy = -bboxNew[1];
    offscreen.dbx = cache.dbx - dx;
    offscreen.dby = cache.dby - dy;
    offscreen.width = width;
    offscreen.height = height;
    return offscreen;
  }

  var Cache = /*#__PURE__*/function () {
    function Cache(w, h, bbox, page, pos, x1, y1) {
      this.__init(w, h, bbox, page, pos, x1, y1);
    }

    _createClass(Cache, [{
      key: "__init",
      value: function __init(w, h, bbox, page, pos, x1, y1) {
        this.__width = w;
        this.__height = h;
        this.__bbox = bbox;
        this.__page = page;
        this.__pos = pos;

        var _page$getCoords = page.getCoords(pos),
            _page$getCoords2 = _slicedToArray(_page$getCoords, 2),
            x = _page$getCoords2[0],
            y = _page$getCoords2[1];

        this.__x = x;
        this.__y = y;

        this.__appendData(x1, y1);

        if (page.canvas) {
          this.__enabled = true;
          var ctx = page.ctx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.globalAlpha = 1;

          if (debug.flag) {
            page.canvas.setAttribute && page.canvas.setAttribute('size', page.size);
          }
        }
      }
    }, {
      key: "__appendData",
      value: function __appendData(sx1, sy1) {
        this.sx1 = sx1; // 去除margin的左上角原点坐标

        this.sy1 = sy1;
        var bbox = this.bbox;
        this.dx = this.x - bbox[0]; // cache坐标和box原点的差值

        this.dy = this.y - bbox[1];
        this.dbx = sx1 - bbox[0]; // 原始sx1/sy1和box原点的差值

        this.dby = sy1 - bbox[1];
        this.update();
      }
    }, {
      key: "update",
      value: function update() {
        this.page.__update = true;
      }
    }, {
      key: "clear",
      value: function clear() {
        if (this.__available) {
          var ctx = this.ctx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          var size = this.page.size;
          ctx.clearRect(this.x, this.y, size, size);
          this.__available = false;
        }
      }
    }, {
      key: "release",
      value: function release() {
        if (this.__enabled) {
          this.clear();

          this.__page.del(this.pos);

          this.__page = null;
          this.__enabled = false;
        }
      }
    }, {
      key: "reset",
      value: function reset(bbox, x1, y1) {
        // 尺寸没变复用之前的并清空
        if (util.equalArr(this.bbox, bbox) && this.__enabled) {
          this.clear();
          return;
        }

        this.release();
        var w = Math.ceil(bbox[2] - bbox[0]);
        var h = Math.ceil(bbox[3] - bbox[1]);
        var res = Page.getInstance(Math.max(w, h));

        if (!res) {
          this.__enabled = false;
          return;
        }

        var page = res.page,
            pos = res.pos;

        this.__init(w, h, bbox, page, pos, x1, y1);
      } // 是否功能可用，生成离屏canvas及尺寸超限

    }, {
      key: "enabled",
      get: function get() {
        return this.__enabled;
      } // 是否有可用缓存内容

    }, {
      key: "available",
      get: function get() {
        return this.__enabled && this.__available;
      }
    }, {
      key: "bbox",
      get: function get() {
        return this.__bbox;
      }
    }, {
      key: "page",
      get: function get() {
        return this.__page;
      }
    }, {
      key: "canvas",
      get: function get() {
        return this.__page.canvas;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.__page.ctx;
      }
    }, {
      key: "size",
      get: function get() {
        return this.__page.size;
      }
    }, {
      key: "x",
      get: function get() {
        return this.__x;
      }
    }, {
      key: "y",
      get: function get() {
        return this.__y;
      }
    }, {
      key: "width",
      get: function get() {
        return this.__width;
      }
    }, {
      key: "height",
      get: function get() {
        return this.__height;
      }
    }, {
      key: "pos",
      get: function get() {
        return this.__pos;
      }
    }], [{
      key: "MAX",
      get: function get() {
        return Page.MAX;
      }
    }, {
      key: "getInstance",
      value: function getInstance(bbox, x1, y1) {
        var w = Math.ceil(bbox[2] - bbox[0]);
        var h = Math.ceil(bbox[3] - bbox[1]);
        var res = Page.getInstance(Math.max(w, h));

        if (!res) {
          return;
        }

        var page = res.page,
            pos = res.pos;
        return new Cache(w, h, bbox, page, pos, x1, y1);
      }
      /**
       * 复制cache的一块出来单独作为cacheFilter，尺寸边距保持一致，用浏览器原生ctx.filter滤镜
       * @param cache
       * @param filter
       * @returns {{canvas: *, ctx: *, release(): void, available: boolean}}
       */

    }, {
      key: "genFilter",
      value: function genFilter(cache, filter) {
        var x = cache.x,
            y = cache.y,
            size = cache.size,
            canvas = cache.canvas,
            sx1 = cache.sx1,
            sy1 = cache.sy1,
            width = cache.width,
            height = cache.height,
            bbox = cache.bbox;
        var oldX1 = bbox[0];
        bbox = spreadFilter(bbox, filter);
        var d = oldX1 - bbox[0];
        var widthNew = bbox[2] - bbox[0];
        var heightNew = bbox[3] - bbox[1];
        var offscreen = inject.getCacheCanvas(widthNew, heightNew, null, 'filter');
        offscreen.ctx.filter = painter.canvasFilter(filter);
        offscreen.ctx.drawImage(canvas, x, y, width, height, d, d, width, height);
        offscreen.ctx.filter = 'none';
        offscreen.bbox = bbox; // 单独的离屏，其dx/dy要重算

        offscreen.x = 0;
        offscreen.y = 0;
        offscreen.size = size;
        offscreen.sx1 = sx1;
        offscreen.sy1 = sy1;
        offscreen.dx = -bbox[0];
        offscreen.dy = -bbox[1];
        offscreen.dbx = cache.dbx + d;
        offscreen.dby = cache.dby + d;
        offscreen.width = widthNew;
        offscreen.height = heightNew;
        return offscreen;
      }
    }, {
      key: "genMask",
      value: function genMask(target, node, callback) {
        var cacheMask = genSingle(target, 'mask1');
        var list = [];
        var _node$__computedStyle = node.__computedStyle,
            transform$1 = _node$__computedStyle[TRANSFORM$2],
            tfo = _node$__computedStyle[TRANSFORM_ORIGIN$1];
        var next = node.next;
        var isClip = next.__isClip;

        while (next && next.__isMask) {
          list.push(next);
          next = next.next;
        }

        var x = cacheMask.x,
            y = cacheMask.y,
            ctx = cacheMask.ctx,
            dbx = cacheMask.dbx,
            dby = cacheMask.dby;
        tfo = tfo.slice(0);
        tfo[0] += x + dbx;
        tfo[1] += y + dby;
        var inverse = transform.calMatrixByOrigin(transform$1, tfo);

        if (isE$1(inverse)) {
          inverse = null;
        } // 先将mask本身绘制到cache上，再设置模式绘制dom本身


        list.forEach(function (item) {
          callback(item, cacheMask, inverse);
        });
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = isClip ? 'source-out' : 'source-in';
        Cache.drawCache(target, cacheMask);
        ctx.globalCompositeOperation = 'source-over';
        return cacheMask;
      }
      /**
       * 如果不超过bbox，直接用已有的total/filter/mask，否则生成一个新的
       */

    }, {
      key: "genOverflow",
      value: function genOverflow(target, node) {
        var bbox = target.bbox;
        var __sx1 = node.__sx1,
            __sy1 = node.__sy1,
            __clientWidth = node.__clientWidth,
            __clientHeight = node.__clientHeight;
        var xe = __sx1 + __clientWidth;
        var ye = __sy1 + __clientHeight;

        if (bbox[0] < __sx1 || bbox[1] < __sy1 || bbox[2] > xe || bbox[3] > ye) {
          var bboxNew = [__sx1, __sy1, xe, ye];
          var cacheOverflow = genSingle(target, 'overflow', bboxNew);
          var ctx = cacheOverflow.ctx;
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.globalAlpha = 1;
          Cache.drawCache(target, cacheOverflow);
          ctx.globalCompositeOperation = 'destination-in';
          ctx.fillStyle = '#FFF';
          ctx.beginPath();
          ctx.rect(0, 0, __clientWidth, __clientHeight);
          ctx.fill();
          ctx.closePath();
          ctx.globalCompositeOperation = 'source-over';
          return cacheOverflow;
        }
      }
    }, {
      key: "drawCache",
      value: function drawCache(source, target) {
        var tx = target.x,
            ty = target.y,
            sx1 = target.sx1,
            sy1 = target.sy1,
            ctx = target.ctx,
            dbx = target.dbx,
            dby = target.dby;
        var x = source.x,
            y = source.y,
            canvas = source.canvas,
            sx2 = source.sx1,
            sy2 = source.sy1,
            dbx2 = source.dbx,
            dby2 = source.dby,
            width = source.width,
            height = source.height;
        var ox = tx + sx2 - sx1 + dbx - dbx2;
        var oy = ty + sy2 - sy1 + dby - dby2;
        ctx.drawImage(canvas, x, y, width, height, ox, oy, width, height);
      }
    }, {
      key: "getCache",
      value: function getCache(list) {
        for (var i = 0, len = list.length; i < len; i++) {
          var item = list[i];

          if (item && item.available) {
            return item;
          }
        }
      }
    }]);

    return Cache;
  }();

  var canvasPolygon = painter.canvasPolygon; // 无cache时应用离屏时的优先级，从小到大，OFFSCREEN_MASK2是个特殊的

  var OFFSCREEN_OVERFLOW$1 = 0;
  var OFFSCREEN_FILTER$1 = 1;
  var OFFSCREEN_MASK$1 = 2;
  var OFFSCREEN_BLEND$1 = 3;
  var OFFSCREEN_MASK2$1 = 4;

  function applyOffscreen$1(ctx, list, width, height) {
    list.sort(function (a, b) {
      if (a.lv === b.lv) {
        if (a.idx === b.idx) {
          return a.type - b.type;
        }

        return b.idx - a.idx;
      }

      return b.lv - a.lv;
    });
    list.forEach(function (item) {
      var type = item.type,
          offscreen = item.offscreen;

      if (type === OFFSCREEN_OVERFLOW$1) {
        var matrix = offscreen.matrix,
            target = offscreen.target,
            origin = offscreen.ctx,
            x = offscreen.x,
            y = offscreen.y,
            offsetWidth = offscreen.offsetWidth,
            offsetHeight = offscreen.offsetHeight,
            _list = offscreen.list;
        ctx.globalCompositeOperation = 'destination-in';
        ctx.globalAlpha = 1;
        ctx.setTransform(matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]);
        ctx.fillStyle = '#FFF';
        ctx.beginPath();

        if (_list) {
          canvasPolygon(ctx, _list);
        } else {
          ctx.rect(x, y, offsetWidth, offsetHeight);
        }

        ctx.fill();
        ctx.closePath();
        ctx.globalCompositeOperation = 'source-over';
        ctx = origin;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(target.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        target.ctx.setTransform(1, 0, 0, 1, 0, 0);
        target.ctx.clearRect(0, 0, width, height);
        inject.releaseCacheCanvas(target.canvas);
      } else if (type === OFFSCREEN_FILTER$1) {
        var _target = offscreen.target,
            _origin = offscreen.ctx,
            filter = offscreen.filter; // 申请一个新的离屏，应用blur并绘制，如没有则降级，默认ctx.filter为'none'

        if (ctx.filter) {
          var apply = inject.getCacheCanvas(width, height, null, 'filter2');
          apply.ctx.filter = painter.canvasFilter(filter);

          if (width && height) {
            apply.ctx.drawImage(_target.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          apply.ctx.filter = 'none';
          _target.ctx.globalAlpha = 1;

          _target.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _target.ctx.clearRect(0, 0, width, height);

          if (width && height) {
            _target.ctx.drawImage(apply.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          apply.ctx.setTransform(1, 0, 0, 1, 0, 0);
          apply.ctx.clearRect(0, 0, width, height);
          inject.releaseCacheCanvas(apply.canvas);
        } // 绘制回主画布，如果不支持则等同无filter原样绘制


        ctx = _origin;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(_target.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        _target.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _target.ctx.globalAlpha = 1;

        _target.ctx.clearRect(0, 0, width, height);

        inject.releaseCacheCanvas(_target.canvas);
      } else if (type === OFFSCREEN_MASK$1) {
        var mask = offscreen.mask,
            isClip = offscreen.isClip;

        if (isClip) {
          ctx = mask.ctx;
          ctx.globalCompositeOperation = 'source-out';
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(offscreen.target.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          ctx.globalCompositeOperation = 'source-over';
          offscreen.target.ctx.setTransform(1, 0, 0, 1, 0, 0);
          offscreen.target.ctx.clearRect(0, 0, width, height);
          inject.releaseCacheCanvas(offscreen.target.canvas);
          ctx = offscreen.ctx;
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(mask.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          mask.ctx.setTransform(1, 0, 0, 1, 0, 0);
          mask.ctx.clearRect(0, 0, width, height);
          inject.releaseCacheCanvas(mask.canvas);
        } else {
          var _target2 = offscreen.target;
          ctx = _target2.ctx;
          ctx.globalCompositeOperation = 'destination-in';
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(mask.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          ctx.globalCompositeOperation = 'source-over';
          mask.ctx.setTransform(1, 0, 0, 1, 0, 0);
          mask.ctx.clearRect(0, 0, width, height);
          inject.releaseCacheCanvas(mask.canvas);
          ctx = offscreen.ctx;
          ctx.globalAlpha = 1;
          ctx.setTransform(1, 0, 0, 1, 0, 0);

          if (width && height) {
            ctx.drawImage(_target2.canvas, 0, 0, width, height, 0, 0, width, height);
          }

          _target2.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _target2.ctx.clearRect(0, 0, width, height);

          inject.releaseCacheCanvas(_target2.canvas);
        }
      } else if (type === OFFSCREEN_BLEND$1) {
        var _target3 = offscreen.target;
        ctx = offscreen.ctx;
        ctx.globalCompositeOperation = offscreen.mixBlendMode;
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;

        if (width && height) {
          ctx.drawImage(_target3.canvas, 0, 0, width, height, 0, 0, width, height);
        }

        ctx.globalCompositeOperation = 'source-over';
        _target3.ctx.globalAlpha = 1;

        _target3.ctx.setTransform(1, 0, 0, 1, 0, 0);

        _target3.ctx.clearRect(0, 0, width, height);

        inject.releaseCacheCanvas(_target3.canvas);
      } // 特殊的mask节点汇总结束，还原ctx
      else if (type === OFFSCREEN_MASK2$1) {
        ctx = offscreen.ctx;
      }
    });
    return ctx;
  }

  var offscreen = {
    OFFSCREEN_OVERFLOW: OFFSCREEN_OVERFLOW$1,
    OFFSCREEN_FILTER: OFFSCREEN_FILTER$1,
    OFFSCREEN_MASK: OFFSCREEN_MASK$1,
    OFFSCREEN_BLEND: OFFSCREEN_BLEND$1,
    OFFSCREEN_MASK2: OFFSCREEN_MASK2$1,
    applyOffscreen: applyOffscreen$1
  };

  var MockPage = /*#__PURE__*/_createClass(function MockPage(texture, width, height) {
    this.uuid = Page.genUuid();
    this.time = inject.now();
    this.texture = texture;
    this.width = width;
    this.height = height;
  });

  /**
   * 一个fbo离屏纹理，mock成cache，当webgl需要局部根节点汇总时生成，即cacheTotal，
   * 基于此纹理进行filter、mask等后处理渲染
   */

  var MockCache = /*#__PURE__*/function () {
    function MockCache(gl, texture, sx1, sy1, width, height, bbox) {
      this.gl = gl;
      this.x = 0;
      this.y = 0;
      this.sx1 = sx1;
      this.sy1 = sy1;
      this.width = width;
      this.height = height;
      this.bbox = bbox;
      this.available = true;
      this.page = new MockPage(texture, width, height);
      this.reOffset();
    }

    _createClass(MockCache, [{
      key: "reOffset",
      value: function reOffset() {
        var bbox = this.bbox;
        this.dx = -bbox[0];
        this.dy = -bbox[1];
        this.dbx = this.sx1 - bbox[0];
        this.dby = this.sy1 - bbox[1];
      }
    }, {
      key: "release",
      value: function release() {
        this.available = false;
        this.gl.deleteTexture(this.page.texture);
      }
    }]);

    return MockCache;
  }();

  var vertexBlur = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoordsBlur[3];uniform vec2 u_direction;void main(){gl_Position=a_position;}"; // eslint-disable-line

  var fragmentBlur = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoordsBlur[3];uniform sampler2D u_texture;void main(){gl_FragColor=vec4(0.0);}"; // eslint-disable-line

  var vertexMbm = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentMultiply = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return((1.0-a2/a3)*c1*255.0+a2/a3*((1.0-a1)*c2*255.0+a1*c3*255.0))/255.0;}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=bottom*top;float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentScreen = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return a+b-a*b;}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentOverlay = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5 ?(2.0*a*b):(a+2.0*b-1.0-a*(2.0*b-1.0));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(top.r,bottom.r),op(top.g,bottom.g),op(top.b,bottom.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentDarken = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return min(a,b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentLighten = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return max(a,b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColorDodge = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){if(b==1.0){return a==0.0 ? a : 1.0;}return min(1.0,a/(1.0-b));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColorBurn = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){if(b==0.0){return a==1.0 ? a : 0.0;}return 1.0-min(1.0,(1.0-a)/b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentHardLight = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5 ?(2.0*a*b):(a+2.0*b-1.0-a*(2.0*b-1.0));}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentSoftLight = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return b<=0.5? a-(1.0-2.0*b)*a*(1.0-a): a+(2.0*b-1.0)*(a<=0.25?((16.0*a-12.0)*a+4.0)*a: sqrt(a)-a);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentDifference = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return abs(a-b);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentExclusion = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float op(float a,float b){return a+b-2.0*a*b;}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=vec3(op(bottom.r,top.r),op(bottom.g,top.g),op(bottom.b,top.b));float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentHue = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float s=getSaturation(a);float l=getLuminosity(a);return setLuminosity(setSaturation(b,s),l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentSaturation = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float s=getSaturation(b);float l=getLuminosity(a);return setLuminosity(setSaturation(a,s),l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentColor = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float l=getLuminosity(a);return setLuminosity(b,l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var fragmentLuminosity = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;float getLuminosity(vec3 color){return 0.3*color[0]+0.59*color[1]+0.11*color[2];}float clipLowest(float channel,float lowestChannel,float luminosity){return luminosity+((channel-luminosity)*luminosity)/(luminosity-lowestChannel);}float clipHighest(float channel,float highestChannel,float luminosity){return luminosity+((channel-luminosity)*(1.0-luminosity))/(highestChannel-luminosity);}vec3 clipColor(vec3 rgb){float luminosity=getLuminosity(rgb);float lowestChannel=min(rgb[0],min(rgb[1],rgb[2]));float highestChannel=max(rgb[0],max(rgb[1],rgb[2]));float r=rgb[0],g=rgb[1],b=rgb[2];if(lowestChannel<0.0){r=clipLowest(r,lowestChannel,luminosity);g=clipLowest(g,lowestChannel,luminosity);b=clipLowest(b,lowestChannel,luminosity);}if(highestChannel>1.0){r=clipHighest(r,highestChannel,luminosity);g=clipHighest(g,highestChannel,luminosity);b=clipHighest(b,highestChannel,luminosity);}return vec3(r,g,b);}vec3 setLuminosity(vec3 rgb,float luminosity){float delta=luminosity-getLuminosity(rgb);float r=rgb[0],g=rgb[1],b=rgb[2];return clipColor(vec3(r+delta,g+delta,b+delta));}float getSaturation(vec3 rgb){return max(rgb[0],max(rgb[1],rgb[2]))-min(rgb[0],min(rgb[1],rgb[2]));}vec3 setSaturation(vec3 rgb,float saturation){float r=rgb[0],g=rgb[1],b=rgb[2];float maxC=0.0,minC=0.0,midC=0.0;int maxI=0,minI=0,midI=0;if(r>=g&&r>=b){maxI=0;maxC=r;if(g>=b){minI=2;midI=1;minC=b;midC=g;}else{minI=1;midI=2;minC=g;midC=b;}}else if(g>=r&&g>=b){maxI=1;maxC=g;if(r>=b){minI=2;midI=0;minC=b;midC=r;}else{minI=0;midI=2;minC=r;midC=b;}}else if(b>=r&&b>=g){maxI=2;maxC=b;if(r>=g){minI=1;midI=0;minC=g;midC=r;}else{minI=0;midI=1;minC=r;midC=g;}}vec3 result=vec3(r,g,b);if(maxC>minC){midC=(midC-minC)*saturation/(maxC-minC);maxC=saturation;}else{maxC=midC=0.0;}minC=0.0;if(maxI==0){result[0]=maxC;}else if(maxI==1){result[1]=maxC;}else if(maxI==2){result[2]=maxC;}if(minI==0){result[0]=minC;}else if(minI==1){result[1]=minC;}else if(minI==2){result[2]=minC;}if(midI==0){result[0]=midC;}else if(midI==1){result[1]=midC;}else if(midI==2){result[2]=midC;}return result;}vec3 op(vec3 a,vec3 b){float l=getLuminosity(b);return setLuminosity(a,l);}vec3 premultipliedAlpha(vec4 color){float a=color.a;if(a==0.0){return vec3(0.0,0.0,0.0);}return vec3(color.r/a,color.g/a,color.b/a);}float alphaCompose(float a1,float a2,float a3,float c1,float c2,float c3){return(1.0-a2/a3)*c1+a2/a3*((1.0-a1)*c2+a1*c3);}void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);if(color1.a==0.0){gl_FragColor=color2;}else if(color2.a==0.0){gl_FragColor=color1;}else{vec3 bottom=premultipliedAlpha(color1);vec3 top=premultipliedAlpha(color2);vec3 res=op(bottom,top);float a=color1.a+color2.a-color1.a*color2.a;gl_FragColor=vec4(alphaCompose(color1.a,color2.a,a,bottom.r,top.r,res.r)*a,alphaCompose(color1.a,color2.a,a,bottom.g,top.g,res.g)*a,alphaCompose(color1.a,color2.a,a,bottom.b,top.b,res.b)*a,a);}}"; // eslint-disable-line

  var getCache = Cache.getCache;
  var OFFSCREEN_OVERFLOW = offscreen.OFFSCREEN_OVERFLOW,
      OFFSCREEN_FILTER = offscreen.OFFSCREEN_FILTER,
      OFFSCREEN_MASK = offscreen.OFFSCREEN_MASK,
      OFFSCREEN_BLEND = offscreen.OFFSCREEN_BLEND,
      OFFSCREEN_MASK2 = offscreen.OFFSCREEN_MASK2,
      applyOffscreen = offscreen.applyOffscreen;
  var _enums$STYLE_KEY$1 = enums.STYLE_KEY,
      DISPLAY$1 = _enums$STYLE_KEY$1.DISPLAY,
      OPACITY$1 = _enums$STYLE_KEY$1.OPACITY,
      VISIBILITY$1 = _enums$STYLE_KEY$1.VISIBILITY,
      FILTER = _enums$STYLE_KEY$1.FILTER,
      OVERFLOW = _enums$STYLE_KEY$1.OVERFLOW,
      MIX_BLEND_MODE$1 = _enums$STYLE_KEY$1.MIX_BLEND_MODE,
      FILL = _enums$STYLE_KEY$1.FILL,
      TRANSFORM$1 = _enums$STYLE_KEY$1.TRANSFORM,
      TRANSFORM_ORIGIN = _enums$STYLE_KEY$1.TRANSFORM_ORIGIN,
      PERSPECTIVE = _enums$STYLE_KEY$1.PERSPECTIVE,
      PERSPECTIVE_ORIGIN = _enums$STYLE_KEY$1.PERSPECTIVE_ORIGIN;
      _enums$STYLE_KEY$1.MATRIX;
  var NONE$1 = o$1.NONE,
      TRANSFORM_ALL$1 = o$1.TRANSFORM_ALL,
      OP$1 = o$1.OPACITY,
      FT$1 = o$1.FILTER,
      REPAINT$1 = o$1.REPAINT,
      contain$1 = o$1.contain,
      MBM$1 = o$1.MIX_BLEND_MODE;
      o$1.PERSPECTIVE;
      var CACHE$1 = o$1.CACHE;
  var isE = mx.isE,
      inverse = mx.inverse,
      multiply = mx.multiply;
  var mbmName = mbm.mbmName,
      isValidMbm = mbm.isValidMbm;
  var assignMatrix = util.assignMatrix,
      transformBbox = util.transformBbox;
  /**
   * 生成一个节点及其子节点所包含的矩形范围盒，canvas和webgl的最大尺寸限制不一样，由外部传入
   * 如果某个子节点超限，则视为整个超限，超限返回空
   * @param node
   * @param __structs
   * @param index
   * @param total
   * @param parentIndexHash
   * @param opacityHash
   * @param MAX
   * @param includeLimitCache webgl时即便超限也要强制生成total，所以标识不能跳出
   * @returns {*}
   */

  function genBboxTotal(node, __structs, index, total, parentIndexHash, opacityHash, MAX, includeLimitCache) {
    var sx1 = node.__sx1,
        sy1 = node.__sy1,
        __cache = node.__cache;
    var _node$__computedStyle = node.__computedStyle,
        filter = _node$__computedStyle[FILTER],
        perspective = _node$__computedStyle[PERSPECTIVE],
        perspectiveOrigin = _node$__computedStyle[PERSPECTIVE_ORIGIN]; // 先将局部根节点的bbox算好，可能没内容是空

    var bboxTotal;

    if (__cache && __cache.available) {
      bboxTotal = __cache.bbox;
    } else {
      bboxTotal = node.filterBbox;
    }

    bboxTotal = bboxTotal.slice(0); // 局部根节点如有perspective，则计算pm，这里不会出现嵌套，因为每个出现都会生成局部根节点

    var pm;

    if (perspective) {
      pm = transform.calPerspectiveMatrix(perspective, perspectiveOrigin);
    } // 广度遍历，不断一层层循环下去，用2个hash暂存每层的父matrix和opacity，blur只需记住顶层，因为子的如果有一定是cacheFilter


    var list = [index];
    var d = 0;
    filter.forEach(function (item) {
      var k = item.k,
          v = item.v;

      if (k === 'blur') {
        d = blur.outerSize(v);
      }
    });
    opacityHash[index] = 1; // opacity可以保存下来层级相乘结果供外部使用，但matrix不可以，因为这里按画布原点为坐标系计算，外部合并局部根节点以bbox左上角为原点

    var matrixHash = {};

    while (list.length) {
      var arr = list.splice(0);

      for (var i = 0, len = arr.length; i < len; i++) {
        var parentIndex = arr[i];

        var _total = __structs[parentIndex].total || 0;

        for (var _i = parentIndex + 1, _len = parentIndex + _total + 1; _i < _len; _i++) {
          var _structs$_i = __structs[_i],
              node2 = _structs$_i.node,
              _total2 = _structs$_i.total; // mask也不占bbox位置

          if (node2.__isMask) {
            continue;
          }

          var __sx1 = node2.__sx1,
              __sy1 = node2.__sy1,
              _cache = node2.__cache,
              __cacheTotal = node2.__cacheTotal,
              __cacheFilter = node2.__cacheFilter,
              __cacheMask = node2.__cacheMask,
              __cacheOverflow = node2.__cacheOverflow,
              __limitCache = node2.__limitCache,
              _node2$computedStyle = node2.computedStyle,
              display = _node2$computedStyle[DISPLAY$1],
              visibility = _node2$computedStyle[VISIBILITY$1],
              transform$1 = _node2$computedStyle[TRANSFORM$1],
              transformOrigin = _node2$computedStyle[TRANSFORM_ORIGIN],
              opacity = _node2$computedStyle[OPACITY$1]; // webgl不能跳过超限

          if (__limitCache && !includeLimitCache) {
            return;
          } // display:none跳过整个节点树，visibility只跳过自身


          if (display === 'none') {
            _i += _total2 || 0;
            continue;
          }

          if (visibility === 'hidden') {
            continue;
          }

          parentIndexHash[_i] = parentIndex;
          opacityHash[_i] = opacityHash[parentIndex] * opacity;
          var bbox = void 0,
              dx = 0,
              dy = 0,
              hasTotal = void 0; // text不能用filter

          if (node2 instanceof Text) {
            bbox = node2.bbox;
          } else {
            var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal]);

            if (target) {
              bbox = target.bbox;
              dx = target.dbx;
              dy = target.dby;
              _i += _total2 || 0;
              hasTotal = true;
            } else if (_cache && _cache.available) {
              bbox = _cache.bbox;
              dx = _cache.dbx;
              dy = _cache.dby;
            } else {
              bbox = node2.filterBbox;
            }
          } // 可能Xom没有内容


          if (bbox) {
            bbox = bbox.slice(0); // 相对于根节点偏移

            bbox[0] -= sx1;
            bbox[1] -= sy1;
            bbox[2] -= sx1;
            bbox[3] -= sy1;
            var matrix = matrixHash[parentIndex]; // 父级matrix初始化E为null，自身不为E时才运算，可以加速

            if (transform$1 && !isE(transform$1)) {
              var tfo = transformOrigin.slice(0); // total下的节点tfo的计算，以total为原点，差值坐标即相对坐标

              tfo[0] += __sx1 - sx1 + dx;
              tfo[1] += __sy1 - sy1 + dy;
              var m = transform.calMatrixByOrigin(transform$1, tfo);

              if (matrix) {
                matrix = multiply(matrix, m);
              } else {
                matrix = m;
              }
            }

            if (matrix) {
              matrixHash[_i] = matrix;
            }

            if (pm) {
              matrix = multiply(pm, matrix);
            }

            bbox = transformBbox(bbox, matrix, d, d); // 有孩子才继续存入下层级广度运算

            if (_total2 && !hasTotal) {
              list.push(_i);
            }

            mergeBbox(bboxTotal, bbox, sx1, sy1);
          }
        }
      }
    }

    return [bboxTotal, pm];
  }

  function mergeBbox(bbox, t, sx1, sy1) {
    bbox[0] = Math.min(bbox[0], sx1 + t[0]);
    bbox[1] = Math.min(bbox[1], sy1 + t[1]);
    bbox[2] = Math.max(bbox[2], sx1 + t[2]);
    bbox[3] = Math.max(bbox[3], sy1 + t[3]);
  }
  /**
   * 生成局部根节点离屏缓存，超限时除外
   * cache是每个节点自身的缓存，且共享离屏canvas
   * cacheTotal是基础
   * cacheFilter基于total
   * cacheOverflow基于filter
   * cacheMask基于overflow
   * cacheBlend基于mask
   * @param renderMode
   * @param node
   * @param index
   * @param lv
   * @param total
   * @param __structs
   * @param hasMask
   * @param width
   * @param height
   * @returns {{enabled}|Cache|*}
   */


  function genTotal(renderMode, node, index, lv, total, __structs, hasMask, width, height) {
    var __cacheTotal = node.__cacheTotal; // 先绘制形成基础的total，有可能已经存在无变化，就可省略

    if (!__cacheTotal || !__cacheTotal.available) {
      var sx1 = node.__sx1,
          sy1 = node.__sy1,
          bbox = node.bbox; // 局部根节点视为E且无透明度，用bbox，子节点用filterBbox

      var bboxTotal = bbox.slice(0);
      assignMatrix(node.__matrixEvent, mx.identity());
      node.__opacity = 1; // 先遍历每个节点，以局部根节点为E，求得所占的总的bbox，即合并所有bbox

      for (var i = index + 1, len = index + (total || 0) + 1; i < len; i++) {
        var _structs$i = __structs[i],
            _node = _structs$i.node,
            _total3 = _structs$i.total,
            _hasMask = _structs$i.hasMask; // Text特殊处理，因为有stroke描边

        if (_node instanceof Text) {
          var _bbox2 = _node.filterBbox,
              _matrix = _node.__domParent.__matrixEvent;

          if (!isE(_matrix)) {
            _bbox2 = transformBbox(_bbox2, _matrix, 0, 0);
          }

          mergeBbox(bboxTotal, _bbox2, 0, 0);
          continue;
        }

        var __computedStyle2 = _node.__computedStyle,
            __isMask = _node.__isMask; // 跳过display:none元素和它的所有子节点和mask，本身是mask除外

        if (__computedStyle2[DISPLAY$1] === 'none' || i !== index && __isMask) {
          i += _total3 || 0;

          if (_hasMask) {
            i += countMaskNum(__structs, i + 1, _hasMask);
          }

          continue;
        }

        var __cacheTotal2 = _node.__cacheTotal,
            __cacheFilter2 = _node.__cacheFilter,
            __cacheMask2 = _node.__cacheMask,
            __cacheOverflow2 = _node.__cacheOverflow;
        var p = _node.__domParent;
        _node.__opacity = __computedStyle2[OPACITY$1] * p.__opacity;
        var matrix = multiply(_node.__matrix, p.__matrixEvent);
        assignMatrix(_node.__matrixEvent, matrix);

        var _bbox = void 0; // 子元素有cacheTotal优先使用


        var target = getCache([__cacheMask2, __cacheFilter2, __cacheOverflow2, __cacheTotal2]); // 局部根节点的total不需要考虑filter，子节点要

        if (target) {
          i += _total3 || 0;

          if (_hasMask) {
            i += countMaskNum(__structs, i + 1, _hasMask);
          }

          _bbox = target.bbox;
        } else {
          _bbox = _node.filterBbox;
        } // 老的不变，新的会各自重新生成，根据matrixEvent合并bboxTotal


        _bbox = transformBbox(_bbox, matrix, 0, 0);
        mergeBbox(bboxTotal, _bbox, 0, 0);
      } // 生成cacheTotal，获取偏移dx/dy


      __cacheTotal = node.__cacheTotal = Cache.getInstance(bboxTotal, sx1, sy1);

      if (!__cacheTotal || !__cacheTotal.__enabled) {
        inject.warn('Cache of ' + node.tagName + '(' + index + ')' + ' is oversize: ' + (bboxTotal[2] - bboxTotal[0]) + ', ' + (bboxTotal[3] - bboxTotal[1]));
        return;
      }

      __cacheTotal.__available = true;
      var _cacheTotal = __cacheTotal,
          dx = _cacheTotal.dx,
          dy = _cacheTotal.dy,
          dbx = _cacheTotal.dbx,
          dby = _cacheTotal.dby,
          tx = _cacheTotal.x,
          ty = _cacheTotal.y;
      var ctxTotal = __cacheTotal.ctx;
      /**
       * 再次遍历每个节点，以局部根节点左上角为基准原点，将所有节点绘制上去
       * 每个子节点的opacity有父继承计算在上面循环已经做好了，直接获取
       * 但matrixEvent可能需要重算，因为原点不一定是根节点的原点，影响tfo
       * 另外每个节点的refreshLevel需要设置REPAINT
       * 这样cacheTotal取消时子节点需确保重新计算一次matrix/opacity/filter，保证下次和父元素继承正确
       */

      var matrixList = [];
      var parentMatrix = null;
      var lastMatrix = null;
      var lastLv = lv; // 和外面没cache的类似，mask生成hash记录

      var maskStartHash = {};
      var offscreenHash = {};

      for (var _i2 = index, _len2 = index + (total || 0) + 1; _i2 < _len2; _i2++) {
        var _structs$_i2 = __structs[_i2],
            _node2 = _structs$_i2.node,
            _lv = _structs$_i2.lv,
            _total4 = _structs$_i2.total,
            _hasMask2 = _structs$_i2.hasMask; // 排除Text

        if (_node2 instanceof Text) {
          _node2.render(renderMode, ctxTotal, dx, dy);

          if (offscreenHash.hasOwnProperty(_i2)) {
            ctxTotal = applyOffscreen(ctxTotal, offscreenHash[_i2], width, height, false);
          }
        } else {
          var _computedStyle = _node2.__computedStyle; // none跳过这棵子树，判断下最后一个节点的离屏应用即可

          if (_computedStyle[DISPLAY$1] === 'none') {
            _i2 += _total4 || 0;

            if (_hasMask2) {
              _i2 += countMaskNum(__structs, _i2 + 1, _hasMask2);
            }

            if (offscreenHash.hasOwnProperty(_i2)) {
              ctxTotal = applyOffscreen(ctxTotal, offscreenHash[_i2], width, height, true);
            }

            continue;
          }

          var _cacheTotal2 = _node2.__cacheTotal,
              _cacheFilter = _node2.__cacheFilter,
              _cacheMask = _node2.__cacheMask,
              _cacheOverflow = _node2.__cacheOverflow;
          var transform$1 = _computedStyle[TRANSFORM$1],
              tfo = _computedStyle[TRANSFORM_ORIGIN];

          if (maskStartHash.hasOwnProperty(_i2)) {
            var _maskStartHash$_i = maskStartHash[_i2],
                idx = _maskStartHash$_i.idx,
                _hasMask3 = _maskStartHash$_i.hasMask,
                offscreenMask = _maskStartHash$_i.offscreenMask;

            var _target2 = inject.getCacheCanvas(width, height, null, 'mask2');

            offscreenMask.mask = _target2; // 应用mask用到

            offscreenMask.isClip = _node2.__isClip; // 定位到最后一个mask元素上的末尾

            var j = _i2 + (_total4 || 0) + 1;

            while (--_hasMask3) {
              var _total5 = __structs[j].total;
              j += (_total5 || 0) + 1;
            }

            j--;
            var list = offscreenHash[j] = offscreenHash[j] || [];
            list.push({
              idx: idx,
              lv: _lv,
              type: OFFSCREEN_MASK,
              offscreen: offscreenMask
            });
            list.push({
              idx: j,
              lv: _lv,
              type: OFFSCREEN_MASK2,
              offscreen: {
                ctx: ctxTotal,
                // 保存等待OFFSCREEN_MASK2时还原
                target: _target2
              }
            });
            ctxTotal = _target2.ctx;
          } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理


          if (_i2 === index) ; else if (_lv > lastLv) {
            parentMatrix = lastMatrix;

            if (isE(parentMatrix)) {
              parentMatrix = null;
            }

            matrixList.push(parentMatrix);
          } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
          else if (_lv < lastLv) {
            var diff = lastLv - _lv;
            matrixList.splice(-diff);
            parentMatrix = matrixList[_lv - 1];
          } // 不变是同级兄弟，无需特殊处理 else {}


          lastLv = _lv; // 特殊渲染的matrix，局部根节点为原点考虑，当需要计算时（不为E）再计算

          var m = void 0;

          if (_i2 !== index && (!isE(parentMatrix) || !isE(transform$1))) {
            tfo = tfo.slice(0);
            tfo[0] += dbx + _node2.__sx1 - sx1 + tx;
            tfo[1] += dby + _node2.__sy1 - sy1 + ty;
            m = transform.calMatrixByOrigin(transform$1, tfo);

            if (!isE(parentMatrix)) {
              m = multiply(parentMatrix, m);
            }
          }

          lastMatrix = m; // 子元素有cacheTotal优先使用

          var _target = _i2 > index && getCache([_cacheMask, _cacheFilter, _cacheOverflow, _cacheTotal2]);

          if (_target) {
            _i2 += _total4 || 0;

            if (_hasMask2) {
              _i2 += countMaskNum(__structs, _i2 + 1, _hasMask2);
            }

            ctxTotal.globalAlpha = _node2.__opacity;

            if (m) {
              ctxTotal.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
            } else {
              ctxTotal.setTransform(1, 0, 0, 1, 0, 0);
            }

            var mixBlendMode = _computedStyle[MIX_BLEND_MODE$1];

            if (isValidMbm(mixBlendMode)) {
              ctxTotal.globalCompositeOperation = mbmName(mixBlendMode);
            }

            Cache.drawCache(_target, __cacheTotal);
            ctxTotal.globalCompositeOperation = 'source-over';

            if (offscreenHash.hasOwnProperty(_i2)) {
              ctxTotal = applyOffscreen(ctxTotal, offscreenHash[_i2], width, height, false);
            }
          } else {
            var offscreenBlend = void 0,
                _offscreenMask = void 0,
                offscreenFilter = void 0,
                offscreenOverflow = void 0;

            var _offscreen = _i2 > index && _node2.__calOffscreen(ctxTotal, _computedStyle);

            if (_offscreen) {
              ctxTotal = _offscreen.ctx;
              offscreenBlend = _offscreen.offscreenBlend;
              _offscreenMask = _offscreen.offscreenMask;
              offscreenFilter = _offscreen.offscreenFilter;
              offscreenOverflow = _offscreen.offscreenOverflow;
            }

            ctxTotal.globalAlpha = _node2.__opacity;

            if (m) {
              ctxTotal.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
            } else {
              ctxTotal.setTransform(1, 0, 0, 1, 0, 0);
            }

            _node2.render(renderMode, ctxTotal, dx, dy); // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


            if (offscreenBlend) {
              var _j = _i2 + (_total4 || 0);

              if (_hasMask2) {
                _j += countMaskNum(__structs, _j + 1, _hasMask2);
              }

              var _list = offscreenHash[_j] = offscreenHash[_j] || [];

              _list.push({
                idx: _i2,
                lv: _lv,
                type: OFFSCREEN_BLEND,
                offscreen: offscreenBlend
              });
            } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
            // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


            if (_offscreenMask) {
              var _j2 = _i2 + (_total4 || 0);

              maskStartHash[_j2 + 1] = {
                idx: _i2,
                hasMask: _hasMask2,
                offscreenMask: _offscreenMask
              };
            } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


            if (offscreenFilter) {
              var _j3 = _i2 + (_total4 || 0);

              if (_hasMask2) {
                _j3 += countMaskNum(__structs, _j3 + 1, _hasMask2);
              }

              var _list2 = offscreenHash[_j3] = offscreenHash[_j3] || [];

              _list2.push({
                idx: _i2,
                lv: _lv,
                type: OFFSCREEN_FILTER,
                offscreen: offscreenFilter
              });
            } // overflow:hidden的离屏，最后孩子进行截取


            if (offscreenOverflow) {
              var _j4 = _i2 + (_total4 || 0);

              if (_hasMask2) {
                _j4 += countMaskNum(__structs, _j4 + 1, _hasMask2);
              }

              var _list3 = offscreenHash[_j4] = offscreenHash[_j4] || [];

              _list3.push({
                idx: _i2,
                lv: _lv,
                type: OFFSCREEN_OVERFLOW,
                offscreen: offscreenOverflow
              });
            } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
            // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


            if (offscreenHash.hasOwnProperty(_i2)) {
              ctxTotal = applyOffscreen(ctxTotal, offscreenHash[_i2], width, height, false);
            }
          }
        }
      }
    }

    return __cacheTotal;
  } // 从cacheTotal生成overflow、filter和mask，一定有cacheTotal才会进


  function genTotalOther(renderMode, __structs, __cacheTotal, node, hasMask, width, height) {
    var __computedStyle = node.__computedStyle,
        __cacheOverflow = node.__cacheOverflow,
        __cacheFilter = node.__cacheFilter,
        __cacheMask = node.__cacheMask;
    var overflow = __computedStyle[OVERFLOW],
        filter = __computedStyle[FILTER];
    var target = __cacheTotal,
        needGen;

    if (overflow === 'hidden') {
      if (!__cacheOverflow || !__cacheOverflow.available) {
        node.__cacheOverflow = __cacheOverflow = Cache.genOverflow(target, node);
        needGen = true;
      }

      if (__cacheOverflow && __cacheOverflow.available) {
        target = __cacheOverflow;
      }
    }

    if (filter && filter.length) {
      if (!__cacheFilter || !__cacheFilter.available || needGen) {
        node.__cacheFilter = __cacheFilter = Cache.genFilter(target, filter);
        needGen = true;
      }

      if (__cacheFilter && __cacheFilter.available) {
        target = __cacheFilter;
      }
    }

    if (hasMask && (!__cacheMask || !__cacheMask.available || needGen)) {
      node.__cacheMask = __cacheMask = Cache.genMask(target, node, function (item, cacheMask, inverse) {
        // 和外面没cache的类似，mask生成hash记录，这里mask节点一定是个普通无cache的独立节点
        var maskStartHash = {};
        var offscreenHash = {};
        var dx = cacheMask.dx,
            dy = cacheMask.dy,
            dbx = cacheMask.dbx,
            dby = cacheMask.dby,
            tx = cacheMask.x,
            ty = cacheMask.y,
            ctx = cacheMask.ctx,
            sx1 = cacheMask.sx1,
            sy1 = cacheMask.sy1;
        var struct = item.__struct,
            root = item.__root,
            structs = root.__structs;
        var index = structs.indexOf(struct);
        var total = struct.total,
            lv = struct.lv;
        var matrixList = [];
        var parentMatrix = null;
        var lastMatrix = null;
        var opacityList = [];
        var parentOpacity = 1;
        var lastOpacity = 1;
        var lastLv = lv;

        for (var i = index, len = index + (total || 0) + 1; i < len; i++) {
          var _structs$i2 = __structs[i],
              _node3 = _structs$i2.node,
              _lv2 = _structs$i2.lv,
              _total6 = _structs$i2.total,
              _hasMask4 = _structs$i2.hasMask; // 排除Text

          if (_node3 instanceof Text) {
            _node3.render(renderMode, ctx, dx, dy);

            if (offscreenHash.hasOwnProperty(i)) {
              ctx = applyOffscreen(ctx, offscreenHash[i], width, height, false);
            }
          } else {
            var _computedStyle2 = _node3.__computedStyle; // none跳过这棵子树，判断下最后一个节点的离屏应用即可

            if (_computedStyle2[DISPLAY$1] === 'none') {
              i += _total6 || 0;

              if (_hasMask4) {
                i += countMaskNum(__structs, i + 1, _hasMask4);
              }

              if (offscreenHash.hasOwnProperty(i)) {
                ctx = applyOffscreen(ctx, offscreenHash[i], width, height, true);
              }

              continue;
            }

            var _cacheTotal3 = _node3.__cacheTotal,
                _cacheFilter2 = _node3.__cacheFilter,
                _cacheMask2 = _node3.__cacheMask,
                _cacheOverflow2 = _node3.__cacheOverflow;

            if (maskStartHash.hasOwnProperty(i)) {
              var _maskStartHash$i = maskStartHash[i],
                  idx = _maskStartHash$i.idx,
                  _hasMask5 = _maskStartHash$i.hasMask,
                  offscreenMask = _maskStartHash$i.offscreenMask;

              var _target4 = inject.getCacheCanvas(width, height, null, 'mask2');

              offscreenMask.mask = _target4; // 应用mask用到

              offscreenMask.isClip = _node3.__isClip; // 定位到最后一个mask元素上的末尾

              var j = i + (_total6 || 0) + 1;

              while (--_hasMask5) {
                var _total7 = __structs[j].total;
                j += (_total7 || 0) + 1;
              }

              j--;
              var list = offscreenHash[j] = offscreenHash[j] || [];
              list.push({
                idx: idx,
                lv: _lv2,
                type: OFFSCREEN_MASK,
                offscreen: offscreenMask
              });
              list.push({
                idx: j,
                lv: _lv2,
                type: OFFSCREEN_MASK2,
                offscreen: {
                  ctx: ctx,
                  // 保存等待OFFSCREEN_MASK2时还原
                  target: _target4
                }
              });
              ctx = _target4.ctx;
            } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理


            if (i === index) ; else if (_lv2 > lastLv) {
              parentMatrix = lastMatrix;

              if (isE(parentMatrix)) {
                parentMatrix = null;
              }

              matrixList.push(parentMatrix);
              parentOpacity = lastOpacity;
              opacityList.push(parentOpacity);
            } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
            else if (_lv2 < lastLv) {
              var diff = lastLv - _lv2;
              matrixList.splice(-diff);
              parentMatrix = matrixList[_lv2 - 1];
              opacityList.splice(-diff);
              parentOpacity = opacityList[_lv2 - 1];
            } // 不变是同级兄弟，无需特殊处理 else {}


            lastLv = _lv2; // 计算临时的matrix，先以此节点为局部根节点原点，后面考虑逆矩阵

            var transform$1 = _computedStyle2[TRANSFORM$1],
                tfo = _computedStyle2[TRANSFORM_ORIGIN],
                opacity = _computedStyle2[OPACITY$1];

            if (i !== index) {
              opacity *= parentOpacity;
            }

            _node3.__opacity = lastOpacity = opacity; // 特殊渲染的matrix，局部根节点为原点且考虑根节点自身的transform

            var m = void 0;

            if (!isE(transform$1)) {
              tfo = tfo.slice(0);
              tfo[0] += dbx + _node3.__sx1 - sx1 + tx;
              tfo[1] += dby + _node3.__sy1 - sy1 + ty;
              m = transform.calMatrixByOrigin(transform$1, tfo);

              if (!isE(parentMatrix)) {
                m = multiply(parentMatrix, m);
              }
            }

            lastMatrix = m;

            if (m) {
              // 很多情况mask和target相同matrix，可简化计算
              if (util.equalArr(m, inverse)) {
                m = mx.identity();
              } else if (inverse) {
                inverse = mx.inverse(inverse);
                m = mx.multiply(inverse, m);
              }
            } else if (!isE(inverse)) {
              m = mx.inverse(inverse);
            }

            m = m || mx.identity();
            assignMatrix(_node3.__matrixEvent, m); // 特殊渲染的matrix，局部根节点为原点考虑，本节点需inverse反向

            var _target3 = getCache([_cacheMask2, _cacheFilter2, _cacheOverflow2, _cacheTotal3]);

            if (_target3) {
              i += _total6 || 0;

              if (_hasMask4) {
                i += countMaskNum(__structs, i + 1, _hasMask4);
              }

              ctx.globalAlpha = opacity;
              ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
              var mixBlendMode = _computedStyle2[MIX_BLEND_MODE$1];

              if (isValidMbm(mixBlendMode)) {
                ctx.globalCompositeOperation = mbmName(mixBlendMode);
              } else {
                ctx.globalCompositeOperation = 'source-over';
              }

              var x = _target3.x,
                  y = _target3.y,
                  canvas = _target3.canvas,
                  _width = _target3.width,
                  _height = _target3.height,
                  sx2 = _target3.sx1,
                  sy2 = _target3.sy1,
                  dbx2 = _target3.dbx,
                  dby2 = _target3.dby;
              var ox = tx + sx2 - sx1 + dbx - dbx2;
              var oy = ty + sy2 - sy1 + dby - dby2;
              ctx.drawImage(canvas, x, y, _width, _height, ox, oy, _width, _height);
              ctx.globalCompositeOperation = 'source-over';

              if (offscreenHash.hasOwnProperty(i)) {
                ctx = applyOffscreen(ctx, offscreenHash[i], _width, _height, false);
              }
            } // 等于将外面bbox计算和渲染合一的过程，但不需要bbox本身的内容
            else {
              var offscreenBlend = void 0,
                  _offscreenMask2 = void 0,
                  offscreenFilter = void 0,
                  offscreenOverflow = void 0;

              var _offscreen2 = _node3.__calOffscreen(ctx, _computedStyle2);

              if (_offscreen2) {
                ctx = _offscreen2.ctx;
                offscreenBlend = _offscreen2.offscreenBlend;
                _offscreenMask2 = _offscreen2.offscreenMask;
                offscreenFilter = _offscreen2.offscreenFilter;
                offscreenOverflow = _offscreen2.offscreenOverflow;
              }

              ctx.globalAlpha = opacity;
              ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);

              _node3.render(renderMode, ctx, dx, dy); // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


              if (offscreenBlend) {
                var _j5 = i + (_total6 || 0);

                if (_hasMask4) {
                  _j5 += countMaskNum(__structs, _j5 + 1, _hasMask4);
                }

                var _list4 = offscreenHash[_j5] = offscreenHash[_j5] || [];

                _list4.push({
                  idx: i,
                  lv: _lv2,
                  type: OFFSCREEN_BLEND,
                  offscreen: offscreenBlend
                });
              } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
              // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


              if (_offscreenMask2) {
                var _j6 = i + (_total6 || 0);

                maskStartHash[_j6 + 1] = {
                  idx: i,
                  hasMask: _hasMask4,
                  offscreenMask: _offscreenMask2
                };
              } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


              if (offscreenFilter) {
                var _j7 = i + (_total6 || 0);

                if (_hasMask4) {
                  _j7 += countMaskNum(__structs, _j7 + 1, _hasMask4);
                }

                var _list5 = offscreenHash[_j7] = offscreenHash[_j7] || [];

                _list5.push({
                  idx: i,
                  lv: _lv2,
                  type: OFFSCREEN_FILTER,
                  offscreen: offscreenFilter
                });
              } // overflow:hidden的离屏，最后孩子进行截取


              if (offscreenOverflow) {
                var _j8 = i + (_total6 || 0);

                if (_hasMask4) {
                  _j8 += countMaskNum(__structs, _j8 + 1, _hasMask4);
                }

                var _list6 = offscreenHash[_j8] = offscreenHash[_j8] || [];

                _list6.push({
                  idx: i,
                  lv: _lv2,
                  type: OFFSCREEN_OVERFLOW,
                  offscreen: offscreenOverflow
                });
              } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
              // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


              if (offscreenHash.hasOwnProperty(i)) {
                ctx = applyOffscreen(ctx, offscreenHash[i], width, height);
              }
            }
          }
        }
      });

      if (__cacheMask && __cacheMask.available) {
        target = __cacheMask;
      }
    }

    return target;
  }
  /**
   * canvas/webgl支持任意节点为mask，不像svg仅单节点
   * hasMask的num是指遮罩对象后面的兄弟节点数，需要换算成包含子节点的总数
   * @param __structs
   * @param start
   * @param hasMask
   */


  function countMaskNum(__structs, start, hasMask) {
    var count = 0;

    while (hasMask--) {
      var total = __structs[start].total;
      count += total || 0;
      start += total || 0; // total不算自身，所以还得+1

      count++;
      start++;
    }

    return count;
  } // webgl不太一样，使用fbo离屏绘制到一个纹理上进行汇总


  function genFrameBufferWithTexture(gl, texCache, width, height) {
    var n = texCache.lockOneChannel();
    var texture = webgl.createTexture(gl, null, n, width, height);
    var frameBuffer = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var check = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

    if (check !== gl.FRAMEBUFFER_COMPLETE) {
      inject.error('Framebuffer object is incomplete: ' + check.toString());
    } // 离屏窗口0开始


    gl.viewport(0, 0, width, height);
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    return [n, frameBuffer, texture];
  }
  /**
   * 局部根节点复合图层生成，汇总所有子节点到一颗局部树上的位图缓存，包含超限特殊情况
   * 即便只有自己一个也要返回，因为webgl生成total的原因是有类似filter/mask等必须离屏处理的东西
   * @param renderMode
   * @param gl
   * @param texCache
   * @param node
   * @param index
   * @param total
   * @param __structs
   * @param cache
   * @param limitCache
   * @param W
   * @param H
   * @returns {*}
   */


  function genTotalWebgl(renderMode, gl, texCache, node, index, total, __structs, cache, limitCache, W, H) {
    // 存每层父亲的matrix和opacity和index，bbox计算过程中生成，缓存给下面渲染过程用
    var parentIndexHash = {};
    var opacityHash = {};

    var _genBboxTotal = genBboxTotal(node, __structs, index, total, parentIndexHash, opacityHash, gl.getParameter(gl.MAX_TEXTURE_SIZE), limitCache),
        _genBboxTotal2 = _slicedToArray(_genBboxTotal, 2),
        bboxTotal = _genBboxTotal2[0],
        parentPm = _genBboxTotal2[1]; // 可能局部根节点合成过程中发现整体超限


    var totalLimitCache;

    if (!bboxTotal) {
      totalLimitCache = true;
    } // 超限情况生成画布大小的特殊纹理


    if (limitCache || totalLimitCache) {
      bboxTotal = [0, 0, W, H];
    }

    var width = bboxTotal[2] - bboxTotal[0];
    var height = bboxTotal[3] - bboxTotal[1];

    var _genFrameBufferWithTe = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe2 = _slicedToArray(_genFrameBufferWithTe, 3),
        n = _genFrameBufferWithTe2[0],
        frameBuffer = _genFrameBufferWithTe2[1],
        texture = _genFrameBufferWithTe2[2]; // 以bboxTotal的左上角为原点生成离屏texture


    var sx1 = node.__sx1,
        sy1 = node.__sy1;
    var cx = width * 0.5,
        cy = height * 0.5;
    var dx = -bboxTotal[0],
        dy = -bboxTotal[1];
    var dbx = sx1 - bboxTotal[0],
        dby = sy1 - bboxTotal[1]; // 先绘制自己的cache，起点所以matrix视作E为空，opacity固定1

    if (cache && cache.available) {
      texCache.addTexAndDrawWhenLimit(gl, cache, 1, null, cx, cy, dx, dy, false);
    } // limitCache无cache需先绘制到统一的离屏画布上
    else if (limitCache) {
      var c = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');
      node.render(mode.CANVAS, c.ctx, 0, 0);
      var j = texCache.lockOneChannel();

      var _texture = webgl.createTexture(gl, c.canvas, j);

      var _mockCache = new MockCache(gl, _texture, 0, 0, width, height, [0, 0, width, height]);

      texCache.addTexAndDrawWhenLimit(gl, _mockCache, 1, null, cx, cy, 0, 0, false);
      texCache.refresh(gl, cx, cy);
      c.ctx.setTransform(1, 0, 0, 1, 0, 0);
      c.ctx.globalAlpha = 1;
      c.ctx.clearRect(0, 0, width, height);

      _mockCache.release();

      texCache.releaseLockChannel(j);
    } // 因为cacheTotal不总是以左上角原点为开始，所以必须每个节点重算matrix，合并box时计算的无法用到


    var matrixHash = {}; // 先序遍历汇总到total

    for (var i = index + 1, len = index + (total || 0) + 1; i < len; i++) {
      var _structs$i3 = __structs[i],
          _node4 = _structs$i3.node,
          _total8 = _structs$i3.total,
          hasMask = _structs$i3.hasMask;
      var parentIndex = parentIndexHash[i];
      var matrix = matrixHash[parentIndex]; // 父节点的在每个节点计算后保存，第一个为top的默认为E（空）

      var opacity = opacityHash[i]; // opacity在合并box时已经计算可以直接用
      // 先看text，visibility会在内部判断，display会被parent判断

      if (_node4 instanceof Text) {
        if (parentPm) {
          matrix = multiply(parentPm, matrix);
        }

        texCache.addTexAndDrawWhenLimit(gl, _node4.__cache, opacity, matrix, cx, cy, dx, dy, false);
      } // 再看total缓存/cache，都没有的是无内容的Xom节点
      else {
        var __cache = _node4.__cache,
            __cacheTotal = _node4.__cacheTotal,
            __cacheFilter = _node4.__cacheFilter,
            __cacheMask = _node4.__cacheMask,
            __cacheOverflow = _node4.__cacheOverflow,
            __isMask = _node4.__isMask;
        var _node4$__computedStyl = _node4.__computedStyle,
            display = _node4$__computedStyl[DISPLAY$1],
            visibility = _node4$__computedStyl[VISIBILITY$1],
            transform$1 = _node4$__computedStyl[TRANSFORM$1],
            transformOrigin = _node4$__computedStyl[TRANSFORM_ORIGIN],
            mixBlendMode = _node4$__computedStyl[MIX_BLEND_MODE$1];

        if (display === 'none') {
          i += _total8 || 0;

          if (hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }

          continue;
        } // mask和不可见不能被汇总到top上


        if (visibility === 'hidden' || __isMask) {
          _node4.render(renderMode, gl, dx, dy);

          gl.useProgram(gl.program);
          gl.viewport(0, 0, width, height);
          continue;
        }

        if (transform$1 && !isE(transform$1)) {
          var tfo = transformOrigin.slice(0); // total下的节点tfo的计算，以total为原点，差值坐标即相对坐标

          if (__cache && __cache.available) {
            tfo[0] += __cache.sx1;
            tfo[1] += __cache.sy1;
          } else {
            tfo[0] += _node4.__sx1;
            tfo[1] += _node4.__sy1;
          }

          var _dx = -sx1 + dbx;

          var _dy = -sy1 + dby;

          tfo[0] += _dx;
          tfo[1] += _dy;
          var m = transform.calMatrixByOrigin(transform$1, tfo);

          if (matrix) {
            matrix = multiply(matrix, m);
          } else {
            matrix = m;
          }
        }

        if (matrix) {
          matrixHash[i] = matrix;
        }

        if (parentPm) {
          matrix = multiply(parentPm, matrix);
        }

        var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal, __cache]);

        if (target) {
          // 局部的mbm和主画布一样，先刷新当前fbo，然后把后面这个mbm节点绘入一个新的等画布尺寸的fbo中，再进行2者mbm合成
          if (isValidMbm(mixBlendMode)) {
            texCache.refresh(gl, cx, cy);

            var _genFrameBufferWithTe3 = genFrameBufferWithTexture(gl, texCache, width, height),
                _genFrameBufferWithTe4 = _slicedToArray(_genFrameBufferWithTe3, 3),
                n2 = _genFrameBufferWithTe4[0],
                frameBuffer2 = _genFrameBufferWithTe4[1],
                texture2 = _genFrameBufferWithTe4[2];

            texCache.addTexAndDrawWhenLimit(gl, target, opacity, matrix, cx, cy, dx, dy, false);
            texCache.refresh(gl, cx, cy); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前fbo作为绘制对象

            var _genMbmWebgl = genMbmWebgl(gl, texCache, n, n2, frameBuffer, texture, mbmName(mixBlendMode), width, height);

            var _genMbmWebgl2 = _slicedToArray(_genMbmWebgl, 3);

            n = _genMbmWebgl2[0];
            frameBuffer = _genMbmWebgl2[1];
            texture = _genMbmWebgl2[2];
            gl.deleteFramebuffer(frameBuffer2);
            gl.deleteTexture(texture2);
          } else {
            texCache.addTexAndDrawWhenLimit(gl, target, opacity, matrix, cx, cy, dx, dy, false);
          }

          if (target !== __cache) {
            i += _total8 || 0;

            if (hasMask) {
              i += countMaskNum(__structs, i + 1, hasMask);
            }
          } else {
            // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用
            _node4.render(renderMode, gl, dx, dy);

            gl.useProgram(gl.program);
            gl.viewport(0, 0, width, height);
          }
        }
      }
    }

    node.render(renderMode, gl, dx, dy);
    gl.useProgram(gl.program);
    gl.viewport(0, 0, width, height); // 绘制到fbo的纹理对象上并删除fbo恢复

    texCache.refresh(gl, cx, cy);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    gl.viewport(0, 0, W, H); // 生成的纹理对象本身已绑定一个纹理单元了，释放lock的同时可以给texCache的channel缓存，避免重复上传

    var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bboxTotal);
    texCache.releaseLockChannel(n, mockCache.page);
    return [limitCache || totalLimitCache, mockCache];
  }

  function genFilterWebgl(gl, texCache, node, cache, filter, W, H) {
    var sx1 = cache.sx1,
        sy1 = cache.sy1,
        width = cache.width,
        height = cache.height,
        bbox = cache.bbox;
    var mockCache = cache;
    filter.forEach(function (item) {
      var k = item.k,
          v = item.v;

      if (k === 'blur' && v > 0) {
        var res = genBlurWebgl(gl, texCache, mockCache, v, width, height, sx1, sy1, bbox);

        if (res) {
          var _res = _slicedToArray(res, 4);

          mockCache = _res[0];
          width = _res[1];
          height = _res[2];
          bbox = _res[3];
        }
      } else if (k === 'dropShadow') {
        var _res2 = genDropShadowWebgl(gl, texCache, mockCache, v, width, height, sx1, sy1, bbox);

        if (_res2) {
          var _res3 = _slicedToArray(_res2, 4);

          mockCache = _res3[0];
          width = _res3[1];
          height = _res3[2];
          bbox = _res3[3];
        }
      } else if (k === 'hueRotate') {
        var rotation = geom$1.d2r(v % 360);
        var cosR = Math.cos(rotation);
        var sinR = Math.sin(rotation);

        var _res4 = genColorMatrixWebgl(gl, texCache, mockCache, [0.213 + cosR * 0.787 - sinR * 0.213, 0.715 - cosR * 0.715 - sinR * 0.715, 0.072 - cosR * 0.072 + sinR * 0.928, 0, 0, 0.213 - cosR * 0.213 + sinR * 0.143, 0.715 + cosR * 0.285 + sinR * 0.140, 0.072 - cosR * 0.072 - sinR * 0.283, 0, 0, 0.213 - cosR * 0.213 - sinR * 0.787, 0.715 - cosR * 0.715 + sinR * 0.715, 0.072 + cosR * 0.928 + sinR * 0.072, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res4) {
          var _res5 = _slicedToArray(_res4, 4);

          mockCache = _res5[0];
          width = _res5[1];
          height = _res5[2];
          bbox = _res5[3];
        }
      } else if (k === 'saturate' && v !== 100) {
        var amount = v * 0.01;

        var _res6 = genColorMatrixWebgl(gl, texCache, mockCache, [0.213 + 0.787 * amount, 0.715 - 0.715 * amount, 0.072 - 0.072 * amount, 0, 0, 0.213 - 0.213 * amount, 0.715 + 0.285 * amount, 0.072 - 0.072 * amount, 0, 0, 0.213 - 0.213 * amount, 0.715 - 0.715 * amount, 0.072 + 0.928 * amount, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res6) {
          var _res7 = _slicedToArray(_res6, 4);

          mockCache = _res7[0];
          width = _res7[1];
          height = _res7[2];
          bbox = _res7[3];
        }
      } else if (k === 'brightness' && v !== 100) {
        var b = v * 0.01;

        var _res8 = genColorMatrixWebgl(gl, texCache, mockCache, [b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, b, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res8) {
          var _res9 = _slicedToArray(_res8, 4);

          mockCache = _res9[0];
          width = _res9[1];
          height = _res9[2];
          bbox = _res9[3];
        }
      } else if (k === 'grayscale' && v > 0) {
        v = Math.min(v, 100);
        var oneMinusAmount = 1 - v * 0.01;

        if (oneMinusAmount < 0) {
          oneMinusAmount = 0;
        } else if (oneMinusAmount > 1) {
          oneMinusAmount = 1;
        }

        var _res10 = genColorMatrixWebgl(gl, texCache, mockCache, [0.2126 + 0.7874 * oneMinusAmount, 0.7152 - 0.7152 * oneMinusAmount, 0.0722 - 0.0722 * oneMinusAmount, 0, 0, 0.2126 - 0.2126 * oneMinusAmount, 0.7152 + 0.2848 * oneMinusAmount, 0.0722 - 0.0722 * oneMinusAmount, 0, 0, 0.2126 - 0.2126 * oneMinusAmount, 0.7152 - 0.7152 * oneMinusAmount, 0.0722 + 0.9278 * oneMinusAmount, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res10) {
          var _res11 = _slicedToArray(_res10, 4);

          mockCache = _res11[0];
          width = _res11[1];
          height = _res11[2];
          bbox = _res11[3];
        }
      } else if (k === 'contrast' && v !== 100) {
        var _amount = v * 0.01;

        var o = -0.5 * _amount + 0.5;

        var _res12 = genColorMatrixWebgl(gl, texCache, mockCache, [_amount, 0, 0, 0, o, 0, _amount, 0, 0, o, 0, 0, _amount, 0, o, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res12) {
          var _res13 = _slicedToArray(_res12, 4);

          mockCache = _res13[0];
          width = _res13[1];
          height = _res13[2];
          bbox = _res13[3];
        }
      } else if (k === 'sepia' && v > 0) {
        v = Math.min(v, 100);

        var _oneMinusAmount = 1 - v * 0.01;

        if (_oneMinusAmount < 0) {
          _oneMinusAmount = 0;
        } else if (_oneMinusAmount > 1) {
          _oneMinusAmount = 1;
        }

        var _res14 = genColorMatrixWebgl(gl, texCache, mockCache, [0.393 + 0.607 * _oneMinusAmount, 0.769 - 0.769 * _oneMinusAmount, 0.189 - 0.189 * _oneMinusAmount, 0, 0, 0.349 - 0.349 * _oneMinusAmount, 0.686 + 0.314 * _oneMinusAmount, 0.168 - 0.168 * _oneMinusAmount, 0, 0, 0.272 - 0.272 * _oneMinusAmount, 0.534 - 0.534 * _oneMinusAmount, 0.131 + 0.869 * _oneMinusAmount, 0, 0, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res14) {
          var _res15 = _slicedToArray(_res14, 4);

          mockCache = _res15[0];
          width = _res15[1];
          height = _res15[2];
          bbox = _res15[3];
        }
      } else if (k === 'invert' && v > 0) {
        v = Math.min(v, 100);

        var _o = v * 0.01;

        var _amount2 = 1 - 2 * _o;

        var _res16 = genColorMatrixWebgl(gl, texCache, mockCache, [_amount2, 0, 0, 0, _o, 0, _amount2, 0, 0, _o, 0, 0, _amount2, 0, _o, 0, 0, 0, 1, 0], width, height, sx1, sy1, bbox);

        if (_res16) {
          var _res17 = _slicedToArray(_res16, 4);

          mockCache = _res17[0];
          width = _res17[1];
          height = _res17[2];
          bbox = _res17[3];
        }
      }
    }); // 切换回主程序

    gl.useProgram(gl.program);
    gl.viewport(0, 0, W, H);
    return mockCache;
  }
  /**
   * https://www.w3.org/TR/2018/WD-filter-effects-1-20181218/#feGaussianBlurElement
   * 根据cacheTotal生成cacheFilter，按照css规范的优化方法执行3次，避免卷积核d扩大3倍性能慢
   * 规范的优化方法对d的值分奇偶优化，这里再次简化，d一定是奇数，即卷积核大小
   * 先动态生成gl程序，默认3核源码示例已注释，根据sigma获得d（一定奇数），再计算权重
   * 然后将d尺寸和权重拼接成真正程序并编译成program，再开始绘制
   */


  function genBlurWebgl(gl, texCache, cache, sigma, width, height, sx1, sy1, bbox) {
    var d = blur.kernelSize(sigma);
    var max = Math.max(15, gl.getParameter(gl.MAX_VARYING_VECTORS));

    while (d > max) {
      d -= 2;
    }

    var spread = blur.outerSizeByD(d); // 防止超限，webgl最大纹理尺寸限制

    var limit = gl.getParameter(gl.MAX_TEXTURE_SIZE);

    if (width > limit || height > limit) {
      return;
    }

    var bboxNew = bbox.slice(0);
    bboxNew[0] -= spread;
    bboxNew[1] -= spread;
    bboxNew[2] += spread;
    bboxNew[3] += spread;
    var widthNew = width + spread * 2;
    var heightNew = height + spread * 2;
    var cx = widthNew * 0.5,
        cy = heightNew * 0.5;
    var weights = blur.gaussianWeight(sigma, d);
    var vert = '';
    var frag = '';
    var r = Math.floor(d * 0.5);

    for (var _i3 = 0; _i3 < r; _i3++) {
      var c = (r - _i3) * 0.01;
      vert += "v_texCoordsBlur[".concat(_i3, "] = a_texCoords + vec2(-").concat(c, ", -").concat(c, ") * u_direction;");
      frag += "gl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(_i3, "]) * ").concat(weights[_i3], ";");
    }

    vert += "v_texCoordsBlur[".concat(r, "] = a_texCoords;");
    frag += "gl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(r, "]) * ").concat(weights[r], ";");

    for (var _i4 = 0; _i4 < r; _i4++) {
      var _c = (_i4 + 1) * 0.01;

      vert += "v_texCoordsBlur[".concat(_i4 + r + 1, "] = a_texCoords + vec2(").concat(_c, ", ").concat(_c, ") * u_direction;");
      frag += "gl_FragColor += texture2D(u_texture, v_texCoordsBlur[".concat(_i4 + r + 1, "]) * ").concat(weights[_i4 + r + 1], ";");
    }

    vert = vertexBlur.replace('[3]', '[' + d + ']').replace(/}$/, vert + '}');
    frag = fragmentBlur.replace('[3]', '[' + d + ']').replace(/}$/, frag + '}');
    var program = webgl.initShaders(gl, vert, frag);
    gl.useProgram(program);

    var _genFrameBufferWithTe5 = genFrameBufferWithTexture(gl, texCache, widthNew, heightNew),
        _genFrameBufferWithTe6 = _slicedToArray(_genFrameBufferWithTe5, 3),
        i = _genFrameBufferWithTe6[0],
        frameBuffer = _genFrameBufferWithTe6[1],
        texture = _genFrameBufferWithTe6[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    }

    texture = webgl.drawBlur(gl, program, frameBuffer, texture, cache.page.texture, i, j, width, height, spread, widthNew, heightNew, cx, cy); // 销毁这个临时program

    gl.deleteShader(program.vertexShader);
    gl.deleteShader(program.fragmentShader);
    gl.deleteProgram(program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    texCache.releaseLockChannel(j);
    var mockCache = new MockCache(gl, texture, sx1, sy1, widthNew, heightNew, bboxNew);
    texCache.releaseLockChannel(i, mockCache.page);
    return [mockCache, widthNew, heightNew, bboxNew];
  }

  function genColorMatrixWebgl(gl, texCache, cache, m, width, height, sx1, sy1, bbox) {
    // 生成最终纹理，尺寸为被遮罩节点大小
    var _genFrameBufferWithTe7 = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe8 = _slicedToArray(_genFrameBufferWithTe7, 3),
        i = _genFrameBufferWithTe8[0],
        frameBuffer = _genFrameBufferWithTe8[1],
        texture = _genFrameBufferWithTe8[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    }

    gl.useProgram(gl.programCm);
    webgl.drawCm(gl, gl.programCm, j, m);
    texCache.releaseLockChannel(j); // 切回

    gl.useProgram(gl.program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer); // 同total一样生成一个mockCache

    var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bbox.slice(0));
    texCache.releaseLockChannel(i, mockCache.page);
    return [mockCache, width, height, bbox];
  }

  function genOverflowWebgl(gl, texCache, node, cache, W, H) {
    var bbox = cache.bbox;
    var __sx1 = node.__sx1,
        __sy1 = node.__sy1,
        __clientWidth = node.__clientWidth,
        __clientHeight = node.__clientHeight;
    var xe = __sx1 + __clientWidth;
    var ye = __sy1 + __clientHeight; // 没超过无需生成

    if (bbox[0] >= __sx1 && bbox[1] >= __sy1 && bbox[2] <= xe && ye) {
      return;
    }

    var bboxNew = [__sx1, __sy1, xe, ye]; // 生成最终纹理，尺寸为被遮罩节点大小

    var _genFrameBufferWithTe9 = genFrameBufferWithTexture(gl, texCache, __clientWidth, __clientHeight),
        _genFrameBufferWithTe10 = _slicedToArray(_genFrameBufferWithTe9, 3),
        i = _genFrameBufferWithTe10[0],
        frameBuffer = _genFrameBufferWithTe10[1],
        texture = _genFrameBufferWithTe10[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    } // 绘制，根据坐标裁剪使用原本纹理的一部分


    gl.useProgram(gl.programOverflow);
    webgl.drawOverflow(gl, j, bboxNew[0] - bbox[0], bboxNew[1] - bbox[1], __clientWidth, __clientHeight, cache.width, cache.height);
    texCache.releaseLockChannel(j); // 切回

    gl.useProgram(gl.program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, W, H);
    gl.deleteFramebuffer(frameBuffer); // 同total一样生成一个mockCache

    var overflowCache = new MockCache(gl, texture, cache.sx1, cache.sy1, __clientWidth, __clientHeight, bboxNew);
    texCache.releaseLockChannel(i, overflowCache.page);
    return overflowCache;
  }

  function genMaskWebgl(gl, texCache, node, cache, W, H, lv, __structs) {
    var sx1 = cache.sx1,
        sy1 = cache.sy1,
        width = cache.width,
        height = cache.height,
        bbox = cache.bbox,
        dx = cache.dx,
        dy = cache.dy; // cache一定是mockCache，可能是total/filter/overflow一种

    var cx = width * 0.5,
        cy = height * 0.5; // 先求得被遮罩的matrix，用作inverse给mask计算

    var _node$__computedStyle2 = node.__computedStyle,
        transform$1 = _node$__computedStyle2[TRANSFORM$1],
        transformOrigin = _node$__computedStyle2[TRANSFORM_ORIGIN];
    var inverse;

    if (isE(transform$1)) {
      inverse = mx.identity();
    } else {
      var tfo = transformOrigin.slice(0);
      tfo[0] += sx1 + dx;
      tfo[1] += sy1 + dy;
      inverse = transform.calMatrixByOrigin(transform$1, tfo);
    }

    inverse = mx.inverse(inverse); // 将所有mask绘入一个单独纹理中，尺寸和原点与被遮罩total相同，才能做到顶点坐标一致

    var _genFrameBufferWithTe11 = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe12 = _slicedToArray(_genFrameBufferWithTe11, 3),
        i = _genFrameBufferWithTe12[0],
        frameBuffer = _genFrameBufferWithTe12[1],
        texture = _genFrameBufferWithTe12[2];

    var next = node.next;
    var isClip = next.__isClip;
    var list = [];

    while (next && next.__isMask && next.__isClip === isClip) {
      list.push(next);
      next = next.next;
    }

    for (var _i5 = 0, len = list.length; _i5 < len; _i5++) {
      var item = list[_i5];
      var matrixList = [];
      var parentMatrix = void 0;
      var lastMatrix = void 0;
      var opacityList = [];
      var parentOpacity = 1;
      var lastOpacity = void 0;
      var lastLv = lv;
      var struct = item.__struct;

      var index = __structs.indexOf(struct); // 可以忽略mbm，因为只有透明遮罩


      for (var _i6 = index, _len3 = index + (struct.total || 0) + 1; _i6 < _len3; _i6++) {
        var _structs$_i3 = __structs[_i6],
            _node5 = _structs$_i3.node,
            _lv3 = _structs$_i3.lv,
            total = _structs$_i3.total,
            hasMask = _structs$_i3.hasMask;
        var __cache = _node5.__cache;
        var __limitCache = _node5.__limitCache;
        var computedStyle = _node5.__computedStyle; // 跳过display:none元素和它的所有子节点和mask

        if (computedStyle[DISPLAY$1] === 'none') {
          _i6 += total || 0;

          if (hasMask) {
            _i6 += countMaskNum(__structs, _i6 + 1, hasMask);
          }

          continue;
        }

        if (_node5 instanceof Text) {
          if (__cache && __cache.available) {
            // text用父级的matrixEvent，在之前texCache添加到末尾了
            texCache.addTexAndDrawWhenLimit(gl, __cache, parentOpacity, texCache.last[2], cx, cy, 0, 0, true);
          } else if (__limitCache) {
            return;
          }
        } else {
          var _cache2 = _node5.__cache,
              __cacheMask = _node5.__cacheMask,
              __cacheFilter = _node5.__cacheFilter,
              __cacheOverflow = _node5.__cacheOverflow,
              __cacheTotal = _node5.__cacheTotal;
          var _node5$__computedStyl = _node5.__computedStyle,
              opacity = _node5$__computedStyl[OPACITY$1],
              _transform = _node5$__computedStyl[TRANSFORM$1],
              _transformOrigin = _node5$__computedStyl[TRANSFORM_ORIGIN]; // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，根节点是第一个特殊处理

          if (_i6 === index) ; else if (_lv3 > lastLv) {
            parentMatrix = lastMatrix;

            if (isE(parentMatrix)) {
              parentMatrix = null;
            }

            matrixList.push(parentMatrix);
            parentOpacity = lastOpacity;
            opacityList.push(parentOpacity);
          } // 变小出栈索引需注意，可能不止一层，多层计算diff层级
          else if (_lv3 < lastLv) {
            var diff = lastLv - _lv3;
            matrixList.splice(-diff);
            parentMatrix = matrixList[_lv3 - 1];
            opacityList.splice(-diff);
            parentOpacity = opacityList[_lv3 - 1];
          } // 不变是同级兄弟，无需特殊处理 else {}


          lastLv = _lv3;
          var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, __cacheTotal, _cache2]); // total和自身cache的尝试，visibility不可见时没有cache

          if (target) {
            var m = void 0;

            if (isE(_transform)) {
              m = mx.identity();
            } else {
              var _tfo = _transformOrigin.slice(0);

              _tfo[0] += target.bbox[0] + dx;
              _tfo[1] += target.bbox[1] + dy;
              m = transform.calMatrixByOrigin(_transform, _tfo);
            }

            m = mx.multiply(inverse, m);

            var tfo = _transformOrigin.slice(0);

            tfo[0] += target.bbox[0] + dx;
            tfo[1] += target.bbox[1] + dy;
            lastMatrix = transform.calMatrixByOrigin(_transform, tfo);

            if (!isE(parentMatrix)) {
              lastMatrix = multiply(parentMatrix, lastMatrix);
            }

            lastOpacity = parentOpacity * opacity;
            texCache.addTexAndDrawWhenLimit(gl, target, lastOpacity, m, cx, cy, dx, dy, true);

            if (target !== _cache2) {
              _i6 += total || 0;

              if (hasMask) {
                _i6 += countMaskNum(__structs, _i6 + 1, hasMask);
              }
            }
          } else if (__limitCache) {
            return;
          }
        }
      }
    }

    texCache.refresh(gl, cx, cy);
    gl.deleteFramebuffer(frameBuffer); // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况mask变更引发的可能不在

    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    } // 生成最终纹理，汇总total和maskCache


    var _genFrameBufferWithTe13 = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe14 = _slicedToArray(_genFrameBufferWithTe13, 3),
        n = _genFrameBufferWithTe14[0],
        frameBuffer2 = _genFrameBufferWithTe14[1],
        texture2 = _genFrameBufferWithTe14[2];

    var program;

    if (isClip) {
      program = gl.programClip;
    } else {
      program = gl.programMask;
    }

    gl.useProgram(program);
    webgl.drawMask(gl, i, j, program);
    gl.deleteTexture(texture);
    texCache.releaseLockChannel(i);
    texCache.releaseLockChannel(j); // 切换回主程序

    gl.useProgram(gl.program);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, W, H);
    gl.deleteFramebuffer(frameBuffer2); // 同total一样生成一个mockCache

    var maskCache = new MockCache(gl, texture2, sx1, sy1, width, height, bbox);
    texCache.releaseLockChannel(n, maskCache.page);
    return maskCache;
  }
  /**
   * webgl的dropShadow只生成阴影部分，模糊复用blur，然后进行拼合
   * @param gl
   * @param texCache
   * @param cache
   * @param v
   * @param width
   * @param height
   * @param sx1
   * @param sy1
   * @param bbox
   * @returns {*[]}
   */


  function genDropShadowWebgl(gl, texCache, cache, v, width, height, sx1, sy1, bbox) {
    // 先清空之前所有绘制遗留
    texCache.refresh(gl, width * 0.5, height * 0.5); // 先根据x/y/color生成单色阴影

    var _v = _slicedToArray(v, 5),
        x = _v[0],
        y = _v[1],
        blur = _v[2],
        color = _v[4];

    var _genFrameBufferWithTe15 = genFrameBufferWithTexture(gl, texCache, width, height),
        _genFrameBufferWithTe16 = _slicedToArray(_genFrameBufferWithTe15, 3),
        i = _genFrameBufferWithTe16[0],
        frameBuffer = _genFrameBufferWithTe16[1],
        texture = _genFrameBufferWithTe16[2]; // 将本身total的page纹理放入一个单元，一般刚生成已经在了，少部分情况变更引发的可能不在


    var j = texCache.findExistTexChannel(cache.page);

    if (j === -1) {
      // 直接绑定，因为一定是个mockCache
      j = texCache.lockOneChannel();
      webgl.bindTexture(gl, cache.page.texture, j);
    } else {
      texCache.lockChannel(j);
    }

    gl.useProgram(gl.programDs);
    texture = webgl.drawDropShadow(gl, gl.programDs, frameBuffer, texture, cache.page.texture, i, j, width, height, color); // 部分清除

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.deleteFramebuffer(frameBuffer);
    var bboxOld = bbox;
    var mockCache = new MockCache(gl, texture, sx1, sy1, width, height, bbox.slice(0)); // 复用blur先生成模糊的阴影

    var res = genBlurWebgl(gl, texCache, mockCache, blur, width, height, sx1, sy1, bbox);
    texCache.releaseLockChannel(j); // 不管后续成功如何，都先释放阴影的lock

    gl.useProgram(gl.program);

    if (res) {
      gl.deleteTexture(texture); // 有模糊的阴影后删除之前无模糊的临时阴影

      var _res18 = _slicedToArray(res, 4);

      mockCache = _res18[0];
      width = _res18[1];
      height = _res18[2];
      bbox = _res18[3];

      // 根据dropShadow的x/y偏移重置模糊阴影的相关数据
      if (x || y) {
        bbox[0] += x;
        bbox[1] += y;
        bbox[2] += x;
        bbox[3] += y; // 把模糊阴影当做一张普通的图片

        mockCache.sx1 = bbox[0];
        mockCache.sy1 = bbox[1];
        mockCache.reOffset();
      }

      var bboxMerge = bboxOld.slice(0);
      mergeBbox(bboxMerge, bbox, 0, 0); // 合并原本cache和blur的纹理为最终对象，i是最初的cache，j是

      width = bboxMerge[2] - bboxMerge[0];
      height = bboxMerge[3] - bboxMerge[1];
      var cx = width * 0.5,
          cy = height * 0.5;
      var dx = -bboxMerge[0],
          dy = -bboxMerge[1];

      var _genFrameBufferWithTe17 = genFrameBufferWithTexture(gl, texCache, width, height),
          _genFrameBufferWithTe18 = _slicedToArray(_genFrameBufferWithTe17, 3),
          k = _genFrameBufferWithTe18[0],
          _frameBuffer = _genFrameBufferWithTe18[1],
          texture2 = _genFrameBufferWithTe18[2]; // 以merge的bbox的左上角为原点，每个cache要换算一下


      texCache.addTexAndDrawWhenLimit(gl, cache, 1, null, cx, cy, dx, dy, false);
      texCache.addTexAndDrawWhenLimit(gl, mockCache, 1, null, cx, cy, dx, dy, false);
      texCache.refresh(gl, cx, cy, false); // 回收

      texCache.releaseLockChannel(i);
      texCache.releaseLockChannel(k);
      gl.deleteFramebuffer(_frameBuffer); // 同total一样生成一个mockCache，数据和本身一样

      var mockCache2 = new MockCache(gl, texture2, sx1, sy1, width, height, bboxMerge);
      texCache.releaseLockChannel(k, mockCache.page);
      return [mockCache2, width, height, bboxMerge];
    }
  }
  /**
   * 生成blendMode混合fbo纹理结果，原本是所有元素向一个fbo记A进行绘制，当出现mbm时，进入到这里，
   * 先生成一个新的fbo记B，将A和待混合节点进行对应的mbm模式混合，结果绘制到B中，然后返回B来替换A，包括纹理单元
   * @param gl
   * @param texCache
   * @param i 之前已有的fbo和纹理单元
   * @param j 当前节点绘制的fbo和纹理单元
   * @param mbm
   * @param fbo 之前舞台绑定的fbo和纹理
   * @param tex
   * @param W
   * @param H
   * @returns {number|*}
   */


  function genMbmWebgl(gl, texCache, i, j, fbo, tex, mbm, W, H) {
    var frag;
    mbm = mbmName(mbm);

    if (mbm === 'multiply') {
      frag = fragmentMultiply;
    } else if (mbm === 'screen') {
      frag = fragmentScreen;
    } else if (mbm === 'overlay') {
      frag = fragmentOverlay;
    } else if (mbm === 'darken') {
      frag = fragmentDarken;
    } else if (mbm === 'lighten') {
      frag = fragmentLighten;
    } else if (mbm === 'color-dodge') {
      frag = fragmentColorDodge;
    } else if (mbm === 'color-burn') {
      frag = fragmentColorBurn;
    } else if (mbm === 'hard-light') {
      frag = fragmentHardLight;
    } else if (mbm === 'soft-light') {
      frag = fragmentSoftLight;
    } else if (mbm === 'difference') {
      frag = fragmentDifference;
    } else if (mbm === 'exclusion') {
      frag = fragmentExclusion;
    } else if (mbm === 'hue') {
      frag = fragmentHue;
    } else if (mbm === 'saturation') {
      frag = fragmentSaturation;
    } else if (mbm === 'color') {
      frag = fragmentColor;
    } else if (mbm === 'luminosity') {
      frag = fragmentLuminosity;
    }

    var program = webgl.initShaders(gl, vertexMbm, frag);
    gl.useProgram(program); // 生成新的fbo，将混合结果绘入

    var _genFrameBufferWithTe19 = genFrameBufferWithTexture(gl, texCache, W, H),
        _genFrameBufferWithTe20 = _slicedToArray(_genFrameBufferWithTe19, 3),
        n = _genFrameBufferWithTe20[0],
        frameBuffer = _genFrameBufferWithTe20[1],
        texture = _genFrameBufferWithTe20[2];

    webgl.drawMbm(gl, program, i, j, W, H); // 切换回主程序并销毁这个临时program

    gl.useProgram(gl.program);
    gl.viewport(0, 0, W, H);
    gl.deleteShader(program.vertexShader);
    gl.deleteShader(program.fragmentShader);
    gl.deleteProgram(program);
    gl.deleteFramebuffer(fbo);
    gl.deleteTexture(tex);
    texCache.releaseLockChannel(i);
    texCache.releaseLockChannel(j);
    return [n, frameBuffer, texture];
  }

  function renderSvg(renderMode, ctx, root, isFirst) {
    var __structs = root.__structs,
        width = root.width,
        height = root.height; // mask节点很特殊，本身有matrix会影响，本身没改变但对象节点有改变也需要计算逆矩阵应用顶点

    var maskEffectHash = {};

    if (!isFirst) {
      // 先遍历一遍收集完全不变的defs，缓存起来id，随后再执行遍历渲染生成新的，避免掉重复的id
      for (var i = 0, len = __structs.length; i < len; i++) {
        var _structs$i4 = __structs[i],
            node = _structs$i4.node,
            total = _structs$i4.total,
            hasMask = _structs$i4.hasMask;
        var __cacheDefs = node.__cacheDefs;
        var __refreshLevel = node.__refreshLevel; // 只要涉及到matrix和opacity就影响mask

        var hasEffectMask = hasMask && (__refreshLevel >= REPAINT$1 || contain$1(__refreshLevel, TRANSFORM_ALL$1 | OP$1));

        if (hasEffectMask) {
          var start = i + (total || 0) + 1;
          var end = start + hasMask; // mask索引遍历时处理，暂存遮罩对象的刷新lv

          maskEffectHash[end - 1] = __refreshLevel;
        } // >=REPAINT重绘生成走render()跳过这里


        if (__refreshLevel < REPAINT$1) {
          // 特殊的mask判断，遮罩对象影响这个mask了，除去filter、遮罩对象无TRANSFORM变化外都可缓存
          if (maskEffectHash.hasOwnProperty(i)) {
            var v = maskEffectHash[i];

            if (!contain$1(__refreshLevel, TRANSFORM_ALL$1) && v < REPAINT$1 && !contain$1(v, TRANSFORM_ALL$1)) {
              __cacheDefs.forEach(function (item) {
                ctx.addCache(item);
              });
            }
          } // 去除特殊的filter，普通节点或不影响的mask在<REPAINT下defs的其它都可缓存
          else if (!(node instanceof Text)) {
            __cacheDefs.forEach(function (item) {
              ctx.addCache(item);
            });
          }
        }
      }
    }

    var maskHash = {}; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

    var matrixList = [];
    var parentMatrix;
    var vdList = [];
    var parentVd;
    var lastLv = 0;
    var lastRefreshLv = 0;
    var lastNode;

    var _loop = function _loop(_i8, _len4) {
      var _structs$_i4 = __structs[_i8],
          node = _structs$_i4.node,
          lv = _structs$_i4.lv,
          total = _structs$_i4.total,
          hasMask = _structs$_i4.hasMask;

      var computedStyle = void 0,
          __refreshLevel = void 0,
          __cacheDefs = void 0,
          __cacheTotal = void 0;

      if (node instanceof Text) {
        computedStyle = node.computedStyle;
        __refreshLevel = lastRefreshLv;
      } else {
        computedStyle = node.__computedStyle;
        __cacheDefs = node.__cacheDefs;
        __refreshLevel = node.__refreshLevel;
        __cacheTotal = node.__cacheTotal;
      }

      lastRefreshLv = __refreshLevel;
      node.__refreshLevel = NONE$1;
      var display = computedStyle[DISPLAY$1]; // 将随后的若干个mask节点范围存下来

      if (hasMask && display !== 'none') {
        var _start = _i8 + (total || 0) + 1;

        var _end = _start + hasMask; // svg限制了只能Geom单节点，不可能是Dom，所以end只有唯一


        maskHash[_end - 1] = {
          index: _i8,
          start: _start,
          end: _end,
          isClip: __structs[_start].node.__isClip // 第一个节点是clip为准

        };
      } // lv变大说明是child，相等是sibling，变小可能是parent或另一棵子树，Root节点第一个特殊处理


      if (lv < lastLv) {
        var diff = lastLv - lv;
        matrixList.splice(-diff);
        parentMatrix = matrixList[lv - 1];
        vdList.splice(-diff);
        parentVd = vdList[lv - 1];
      } else if (lv > lastLv) {
        matrixList.push(parentMatrix = lastNode.__matrix);
        var vd = lastNode.__virtualDom;
        vdList.push(vd);
        parentVd = vd;
      }

      lastNode = node;
      lastLv = lv;
      var virtualDom = void 0; // svg小刷新等级时直接修改vd，这样Geom不再感知

      if (__refreshLevel < REPAINT$1 && !(node instanceof Text)) {
        virtualDom = node.__virtualDom; // total可以跳过所有孩子节点省略循环

        if (__cacheTotal && __cacheTotal.available) {
          _i8 += total || 0;
          virtualDom.cache = true;
        } else {
          __cacheTotal && (__cacheTotal.available = true);
          virtualDom = node.__virtualDom = util.extend({}, virtualDom); // dom要清除children缓存，geom和img无需

          if (node instanceof Dom && !(node instanceof Img)) {
            virtualDom.children = [];
          } // 还得判断，和img加载混在一起时，触发刷新如果display:none，则还有cacheTotal


          if (display === 'none') {
            _i8 += total || 0;

            if (hasMask) {
              _i8 += hasMask;
            }
          } else {
            delete virtualDom.cache;
          }
        }

        node.__cacheStyle;
        node.__currentStyle;

        if (contain$1(__refreshLevel, TRANSFORM_ALL$1)) {
          var matrix = node.__matrix;

          if (!matrix || isE(matrix)) {
            delete virtualDom.transform;
          } else {
            virtualDom.transform = 'matrix(' + util.joinArr(mx.m2m6(matrix), ',') + ')';
          }

          if (parentMatrix && matrix) {
            matrix = multiply(parentMatrix, matrix);
          }

          assignMatrix(node.__matrixEvent, matrix);
        }

        if (contain$1(__refreshLevel, OP$1)) {
          var opacity = computedStyle[OPACITY$1];

          if (opacity === 1) {
            delete virtualDom.opacity;
          } else {
            virtualDom.opacity = opacity;
          }
        }

        if (contain$1(__refreshLevel, FT$1)) {
          var filter = computedStyle[FILTER];
          var s = painter.svgFilter(filter);

          if (s) {
            virtualDom.filter = s;
          } else {
            delete virtualDom.filter;
          }
        }

        if (contain$1(__refreshLevel, MBM$1)) {
          var mixBlendMode = computedStyle[MIX_BLEND_MODE$1];

          if (isValidMbm(mixBlendMode)) {
            virtualDom.mixBlendMode = mbmName(mixBlendMode);
          } else {
            delete virtualDom.mixBlendMode;
          }
        }

        virtualDom.lv = __refreshLevel;
      } else {
        // >=REPAINT会调用render，重新生成defsCache，text没有这个东西
        if (!(node instanceof Text)) {
          node.__cacheDefs.splice(0);

          var _matrix2 = node.__matrix;

          if (parentMatrix) {
            _matrix2 = multiply(parentMatrix, _matrix2);
          }

          assignMatrix(node.__matrixEvent, _matrix2);
        }

        node.render(renderMode, ctx, 0, 0);
        virtualDom = node.__virtualDom; // svg mock，每次都生成，每个节点都是局部根，更新时自底向上清除

        if (!(node instanceof Text)) {
          node.__cacheTotal = node.__cacheTotal || {
            available: true,
            release: function release() {
              this.available = false;
              delete virtualDom.cache;
            }
          };
          node.__cacheTotal.available = true;
        } // 渲染后更新取值


        display = computedStyle[DISPLAY$1];

        if (display === 'none') {
          _i8 += total || 0;
          _i8 += hasMask || 0;
        }
      }
      /**
       * mask会在join时过滤掉，这里将假设正常渲染的vd的内容获取出来组成defs的mask内容
       * 另外最初遍历时记录了会影响的mask，在<REPAINT时比较，>=REPAINT始终重新设置
       * 本身有matrix也需要重设
       */


      if (maskHash.hasOwnProperty(_i8) && (maskEffectHash.hasOwnProperty(_i8) || __refreshLevel >= REPAINT$1 || contain$1(__refreshLevel, TRANSFORM_ALL$1 | OP$1))) {
        var _maskHash$_i = maskHash[_i8],
            index = _maskHash$_i.index,
            _start2 = _maskHash$_i.start,
            _end2 = _maskHash$_i.end,
            isClip = _maskHash$_i.isClip;
        var target = __structs[index];
        var dom = target.node;
        var mChildren = []; // clip模式时，先添加兜底整个白色使得全部都可见，mask本身变反色（黑色）

        if (isClip) {
          mChildren.push({
            type: 'item',
            tagName: 'path',
            props: [['d', "M0,0L".concat(width, ",0L").concat(width, ",").concat(height, "L0,").concat(height, "L0,0")], ['fill', 'rgba(255,255,255,1)'], ['stroke-width', 0]]
          });
        }

        for (var j = _start2; j < _end2; j++) {
          var _node6 = __structs[j].node;
          var _node6$computedStyle = _node6.computedStyle,
              _display = _node6$computedStyle[DISPLAY$1],
              visibility = _node6$computedStyle[VISIBILITY$1],
              fill = _node6$computedStyle[FILL],
              _node6$virtualDom = _node6.virtualDom,
              children = _node6$virtualDom.children,
              _opacity = _node6$virtualDom.opacity;

          if (_display !== 'none' && visibility !== 'hidden') {
            // 引用相同无法diff，需要clone
            children = util.clone(children);
            mChildren = mChildren.concat(children);

            for (var k = 0, _len5 = children.length; k < _len5; k++) {
              var _children$k = children[k],
                  tagName = _children$k.tagName,
                  props = _children$k.props;

              if (tagName === 'path') {
                if (isClip) {
                  for (var _j9 = 0, _len6 = props.length; _j9 < _len6; _j9++) {
                    var item = props[_j9];

                    if (item[0] === 'fill') {
                      item[1] = util.int2invert(fill[0]);
                    }
                  }
                }

                var _matrix3 = _node6.matrix;
                var ivs = inverse(dom.matrix);
                _matrix3 = multiply(ivs, _matrix3); // path没有transform属性，在vd上，需要弥补

                props.push(['transform', "matrix(".concat(util.joinArr(mx.m2m6(_matrix3), ','), ")")]); // path没有opacity属性，在vd上，需要弥补

                if (!util.isNil(_opacity) && _opacity !== 1) {
                  props.push(['opacity', _opacity]);
                }
              } // img可能有matrix属性，需判断
              else if (tagName === 'image') {
                var hasTransform = -1;

                for (var m = 0, _len7 = props.length; m < _len7; m++) {
                  if (props[m][0] === 'transform') {
                    hasTransform = m;
                    break;
                  }
                }

                if (hasTransform === -1) {
                  var _ivs = inverse(dom.matrix);

                  if (!isE(_ivs)) {
                    props.push(['transform', "matrix(".concat(util.joinArr(mx.m2m6(_ivs), ','), ")")]);
                  }
                } else {
                  var _matrix4 = props[hasTransform][1].match(/[\d.]+/g).map(function (i) {
                    return parseFloat(i);
                  });

                  var _ivs2 = inverse(dom.matrix);

                  _matrix4 = multiply(_ivs2, _matrix4);
                  props[hasTransform][1] = "matrix(".concat(util.joinArr(mx.m2m6(_matrix4), ','), ")");
                }
              }
            }
          }
        } // 清掉上次的


        for (var _i9 = __cacheDefs.length - 1; _i9 >= 0; _i9--) {
          var _item = __cacheDefs[_i9];

          if (_item.tagName === 'mask') {
            __cacheDefs.splice(_i9, 1);
          }
        }

        var o = {
          tagName: 'mask',
          props: [],
          children: mChildren
        };
        var id = ctx.add(o);

        __cacheDefs.push(o);

        id = 'url(#' + id + ')';
        dom.virtualDom.mask = id;
      } // mask不入children


      if (parentVd && !node.__isMask) {
        parentVd.children.push(virtualDom);
      }

      if (_i8 === 0) {
        parentMatrix = node.__matrix;
        parentVd = virtualDom;
      }

      _i7 = _i8;
    };

    for (var _i7 = 0, _len4 = __structs.length; _i7 < _len4; _i7++) {
      _loop(_i7);
    }
  }

  function renderWebgl(renderMode, gl, root) {
    var __structs = root.__structs,
        width = root.width,
        height = root.height,
        texCache = root.texCache;
    var cx = width * 0.5,
        cy = height * 0.5; // 栈代替递归，存父节点的matrix/opacity，matrix为E时存null省略计算

    var lastRefreshLevel = NONE$1;
    var mergeList = [];
    var hasMbm; // 是否有混合模式出现

    /**
     * 先一遍先序遍历每个节点绘制到自己__cache上，排除Text和已有的缓存以及局部根缓存，
     * 根据refreshLevel进行等级区分，可能是<REPAINT或>=REPAINT，REFLOW布局已前置处理完。
     * 首次绘制没有catchTotal等，后续则可能会有，在<REPAINT可据此跳过所有子节点加快循环，布局过程会提前删除它们。
     * lv的变化根据大小相等进行出入栈parent操作，实现获取节点parent数据的方式，
     * 同时过程中计算出哪些节点要生成局部根，存下来
     */

    for (var i = 0, len = __structs.length; i < len; i++) {
      var _structs$i5 = __structs[i],
          node = _structs$i5.node,
          lv = _structs$i5.lv,
          total = _structs$i5.total,
          hasMask = _structs$i5.hasMask;
      node.__index = i; // Text特殊处理，webgl中先渲染为bitmap，再作为贴图绘制，缓存交由text内部判断，直接调用渲染纹理方法

      if (node instanceof Text) {
        if (lastRefreshLevel >= REPAINT$1) {
          var bbox = node.bbox,
              sx = node.__sx,
              sy = node.__sy;
          var __cache = node.__cache;

          if (__cache) {
            __cache.reset(bbox, sx, sy);
          } else {
            __cache = Cache.getInstance(bbox, sx, sy);
          }

          if (__cache && __cache.enabled) {
            __cache.__bbox = bbox;
            __cache.__available = true;
            node.__cache = __cache;
            node.render(mode.CANVAS, __cache.ctx, __cache.dx, __cache.dy);
          } else {
            __cache && __cache.release();
            node.__limitCache = true;
          }
        }

        continue;
      }

      var __computedStyle = node.__computedStyle; // 跳过display:none元素和它的所有子节点

      if (__computedStyle[DISPLAY$1] === 'none') {
        i += total || 0;

        if (hasMask) {
          i += countMaskNum(__structs, i + 1, hasMask);
        }

        continue;
      } // 根据refreshLevel优化计算


      var __refreshLevel = node.__refreshLevel,
          __currentStyle = node.__currentStyle,
          __cacheTotal = node.__cacheTotal;
      lastRefreshLevel = __refreshLevel;
      node.__refreshLevel = NONE$1;
      /**
       * lv<REPAINT，一般会有__cache，跳过渲染过程，快速运算，没有cache则是自身超限或无内容，目前不感知
       * 可能有cacheTotal，为之前生成的局部根，清除逻辑在更新检查是否>=REPAINT那里，小变化不动
       * 当有遮罩时，如果被遮罩节点本身无变更，需要检查其next的遮罩节点有无变更，
       * 但其实不用检查，因为next变更一定会清空cacheMask，只要检查cacheMask即可
       * 如果没有或无效，直接添加，无视节点本身变化，后面防重即可
       */

      if (__refreshLevel < REPAINT$1) {
        var matrix = node.__matrix;
        var _mbm = __computedStyle[MIX_BLEND_MODE$1];
        var isMbm = contain$1(__refreshLevel, MBM$1) && isValidMbm(_mbm);
        var __domParent = node.__domParent;
        var isPpt = !isE(__domParent && __domParent.__perspectiveMatrix) || transform.isPerspectiveMatrix(matrix);

        if (isMbm) {
          hasMbm = true;
        } // 这里和canvas不一样，前置cacheAsBitmap条件变成或条件之一，新的ppt层级且画中画需要新的fbo


        if (contain$1(__refreshLevel, FT$1 | MBM$1) || isPpt) {
          mergeList.push({
            i: i,
            lv: lv,
            total: total,
            node: node,
            hasMask: hasMask
          });
        } // total可以跳过所有孩子节点省略循环，filter/mask等的强制前提是有total


        if (__cacheTotal && __cacheTotal.available) {
          i += total || 0;

          if (__refreshLevel === NONE$1 && hasMask) {
            i += countMaskNum(__structs, i + 1, hasMask);
          }
        }
      }
      /**
       * >=REPAINT重新渲染，并根据结果判断是否离屏限制错误
       * Geom没有子节点无需汇总局部根，Dom中Img也是，它们的局部根等于自身的cache，其它符合条件的Dom需要生成
       */
      else {
        var hasContent = node.calContent(__currentStyle, __computedStyle); // 有内容先以canvas模式绘制到离屏画布上，自定义渲染设置无内容不实现即可跳过

        if (hasContent) {
          var _bbox3 = node.bbox,
              _cache3 = node.__cache,
              sx1 = node.__sx1,
              sy1 = node.__sy1;

          if (_cache3) {
            _cache3.reset(_bbox3, sx1, sy1);
          } else {
            _cache3 = Cache.getInstance(_bbox3, sx1, sy1);
          }

          if (_cache3 && _cache3.enabled) {
            _cache3.__bbox = _bbox3;
            _cache3.__available = true;
            node.__cache = _cache3;
            node.render(mode.CANVAS, _cache3.ctx, _cache3.dx, _cache3.dy);
          } else {
            _cache3 && _cache3.release();
            node.__limitCache = true;
          }
        } else {
          node.__limitCache = false;
        }

        var overflow = __computedStyle[OVERFLOW],
            filter = __computedStyle[FILTER],
            mixBlendMode = __computedStyle[MIX_BLEND_MODE$1];

        var _isMbm = isValidMbm(mixBlendMode);

        var _domParent = node.__domParent;

        var _isPpt = !isE(_domParent && _domParent.__perspectiveMatrix) || transform.isPerspectiveMatrix(node.__matrix);

        var isOverflow = overflow === 'hidden' && total;
        var isFilter = filter && filter.length;

        if (_isMbm) {
          hasMbm = true;
        }

        if (node.__cacheAsBitmap || hasMask || isFilter || _isMbm || isOverflow || _isPpt) {
          mergeList.push({
            i: i,
            lv: lv,
            total: total,
            node: node,
            hasMask: hasMask
          });
        }
      }
    }

    var limitHash = {}; // 根据收集的需要合并局部根的索引，尝试合并，按照层级从大到小，索引从大到小的顺序，
    // 这样保证子节点在前，后节点在前，后节点是为了mask先应用自身如filter之后再进行遮罩

    if (mergeList.length) {
      mergeList.sort(function (a, b) {
        if (a.lv === b.lv) {
          return b.i - a.i;
        }

        return b.lv - a.lv;
      }); // ppt只有嵌套才需要生成，最下面的孩子节点的ppt无需，因此记录一个hash存index，
      // 同时因为是后序遍历，孩子先存所有父亲的index即可保证父亲才能生成cacheTotal

      var pptHash = {};
      mergeList.forEach(function (item) {
        var i = item.i,
            lv = item.lv,
            total = item.total,
            node = item.node,
            hasMask = item.hasMask;
        var __limitCache = node.__limitCache,
            __matrix = node.__matrix,
            __domParent = node.__domParent,
            __computedStyle = node.__computedStyle;
        var overflow = __computedStyle[OVERFLOW],
            filter = __computedStyle[FILTER];
        var isPerspective = !isE(__domParent && __domParent.__perspectiveMatrix) || transform.isPerspectiveMatrix(__matrix); // 有ppt的，向上查找所有父亲index记录，可能出现重复记得提前跳出

        if (isPerspective) {
          var parent = node.__domParent;

          while (parent) {
            var idx = parent.__index;

            if (pptHash[idx]) {
              break;
            }

            if (transform.isPerspectiveMatrix(parent.__matrix)) {
              pptHash[idx] = true;
            }

            parent = parent.__domParent;

            if (parent && parent.__perspectiveMatrix) {
              pptHash[idx] = true;
            }
          }

          if (!pptHash[i] && !hasMask && !filter.length && !(overflow === 'hidden' && total) && !node.__cacheAsBitmap) {
            return;
          }
        }

        var __cache = node.__cache,
            __cacheTotal = node.__cacheTotal,
            __cacheFilter = node.__cacheFilter,
            __cacheMask = node.__cacheMask,
            __cacheOverflow = node.__cacheOverflow;
        var needGen; // 可能没变化，比如被遮罩节点、filter变更等

        if (!__cacheTotal || !__cacheTotal.available) {
          var _genTotalWebgl = genTotalWebgl(renderMode, gl, texCache, node, i, total || 0, __structs, __cache, __limitCache, width, height),
              _genTotalWebgl2 = _slicedToArray(_genTotalWebgl, 2),
              limit = _genTotalWebgl2[0],
              res = _genTotalWebgl2[1];

          __cacheTotal = res;
          needGen = true;
          __limitCache = limit; // 返回的limit包含各种情况超限，一旦超限，只能生成临时cacheTotal不能保存

          if (!__limitCache) {
            node.__cacheTotal = res;
          }
        } // 即使超限，也有total结果


        var target = __cacheTotal;

        if (overflow === 'hidden') {
          if (!__cacheOverflow || !__cacheOverflow.available || needGen) {
            var temp = genOverflowWebgl(gl, texCache, node, target, width, height);

            if (temp) {
              target = temp;
              needGen = true;

              if (!__limitCache) {
                node.__cacheOverflow = target;
              }
            }
          }

          if (__cacheOverflow && __cacheOverflow.available) {
            target = __cacheOverflow;
          }
        }

        if (filter.length) {
          if (!__cacheFilter || !__cacheFilter.available || needGen) {
            var old = target;
            target = genFilterWebgl(gl, texCache, node, target, filter, width, height);

            if (target !== old) {
              needGen = true;

              if (!__limitCache) {
                node.__cacheFilter = target;
              }
            }
          }

          if (__cacheFilter && __cacheFilter.available) {
            target = __cacheFilter;
          }
        }

        if (hasMask && (!__cacheMask || !__cacheMask.available || needGen)) {
          target = genMaskWebgl(gl, texCache, node, target, width, height, lv, __structs);

          if (!__limitCache) {
            node.__cacheMask = target;
          }
        } // 保存临时的局部根节点


        if (__limitCache) {
          limitHash[i] = target;
        }
      });
    }
    /**
     * 最后先序遍历一次应用__cacheTotal即可，没有的用__cache，以及剩下的超尺寸的和Text
     * 由于mixBlendMode的存在，需先申请个fbo纹理，所有绘制默认向该纹理绘制，最后fbo纹理再进入主画布
     * 前面循环时有记录是否出现mbm，只有出现才申请，否则不浪费直接输出到主画布
     * 超尺寸的要走无cache逻辑render，和canvas很像，除了离屏canvas超限，汇总total也会纹理超限
     */


    var n, frameBuffer, texture;

    if (hasMbm) {
      var _genFrameBufferWithTe21 = genFrameBufferWithTexture(gl, texCache, width, height);

      var _genFrameBufferWithTe22 = _slicedToArray(_genFrameBufferWithTe21, 3);

      n = _genFrameBufferWithTe22[0];
      frameBuffer = _genFrameBufferWithTe22[1];
      texture = _genFrameBufferWithTe22[2];
    }

    for (var _i10 = 0, _len8 = __structs.length; _i10 < _len8; _i10++) {
      var _structs$_i5 = __structs[_i10],
          _node7 = _structs$_i5.node,
          _total9 = _structs$_i5.total,
          _hasMask6 = _structs$_i5.hasMask; // text如果display不可见，parent会直接跳过，不会走到这里，这里一定是直接绘制到root的，visibility在其内部判断

      if (_node7 instanceof Text) {
        // text特殊之处，__config部分是复用parent的
        var _cache4 = _node7.__cache,
            _domParent2 = _node7.__domParent;
        var __matrixEvent = _domParent2.__matrixEvent,
            __opacity = _domParent2.__opacity;

        if (_cache4 && _cache4.available) {
          texCache.addTexAndDrawWhenLimit(gl, _cache4, __opacity, __matrixEvent, cx, cy, 0, 0, true);
        } // 超限特殊处理，先生成画布尺寸大小的纹理然后原始位置绘制，超限一定有文字内容
        else if (_node7.__limitCache && _domParent2.__computedStyle[VISIBILITY$1] !== 'hidden') {
          var c = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');

          _node7.render(mode.CANVAS, c.ctx, 0, 0);

          var j = texCache.lockOneChannel();

          var _texture2 = webgl.createTexture(gl, c.canvas, j);

          var mockCache = new MockCache(gl, _texture2, 0, 0, width, height, [0, 0, width, height]);
          texCache.addTexAndDrawWhenLimit(gl, mockCache, _node7.__opacity, _node7.__matrixEvent, cx, cy, 0, 0, true);
          texCache.refresh(gl, cx, cy, true);
          c.ctx.setTransform(1, 0, 0, 1, 0, 0);
          c.ctx.globalAlpha = 1;
          c.ctx.clearRect(0, 0, width, height);
          mockCache.release();
          texCache.releaseLockChannel(j);
        }
      } else {
        var _computedStyle3 = _node7.__computedStyle; // none跳过这棵子树，判断下最后一个节点的离屏应用即可

        if (_computedStyle3[DISPLAY$1] === 'none') {
          _i10 += _total9 || 0;

          if (_hasMask6) {
            _i10 += countMaskNum(__structs, _i10 + 1, _hasMask6);
          }

          continue;
        }

        var _cache5 = _node7.__cache,
            _cacheTotal4 = _node7.__cacheTotal,
            __cacheFilter = _node7.__cacheFilter,
            __cacheMask = _node7.__cacheMask,
            __cacheOverflow = _node7.__cacheOverflow,
            _domParent3 = _node7.__domParent,
            __matrix = _node7.__matrix;
        var opacity = _computedStyle3[OPACITY$1],
            _mixBlendMode = _computedStyle3[MIX_BLEND_MODE$1];
        var m = __matrix;

        if (_domParent3) {
          opacity *= _domParent3.__opacity;
          var pm = _domParent3.__perspectiveMatrix;

          if (!isE(pm)) {
            m = multiply(pm, m);
          }

          m = multiply(_domParent3.__matrixEvent, m);
        }

        _node7.__opacity = opacity;
        assignMatrix(_node7.__matrixEvent, m); // 有total的可以直接绘制并跳过子节点索引，忽略total本身，其独占用纹理单元，注意特殊不取cacheTotal，
        // 这种情况发生在只有overflow:hidden声明但无效没有生成__cacheOverflow的情况，
        // 因为webgl纹理单元缓存原因，所以不用cacheTotal防止切换性能损耗
        // 已取消，因为perspective需要进行独立上下文渲染

        var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, _cacheTotal4, _cache5]); // total和自身cache的尝试，visibility不可见时没有cache

        if (target) {
          // 有mbm先刷新当前fbo，然后把后面这个mbm节点绘入一个新的等画布尺寸的fbo中，再进行2者mbm合成
          if (hasMbm && isValidMbm(_mixBlendMode)) {
            texCache.refresh(gl, cx, cy, true);

            var _genFrameBufferWithTe23 = genFrameBufferWithTexture(gl, texCache, width, height),
                _genFrameBufferWithTe24 = _slicedToArray(_genFrameBufferWithTe23, 3),
                n2 = _genFrameBufferWithTe24[0],
                frameBuffer2 = _genFrameBufferWithTe24[1],
                texture2 = _genFrameBufferWithTe24[2];

            texCache.addTexAndDrawWhenLimit(gl, target, opacity, m, cx, cy, 0, 0, true);
            texCache.refresh(gl, cx, cy, true); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前画布作为绘制对象

            var _genMbmWebgl3 = genMbmWebgl(gl, texCache, n, n2, frameBuffer, texture, mbmName(_mixBlendMode), width, height);

            var _genMbmWebgl4 = _slicedToArray(_genMbmWebgl3, 3);

            n = _genMbmWebgl4[0];
            frameBuffer = _genMbmWebgl4[1];
            texture = _genMbmWebgl4[2];
            gl.deleteFramebuffer(frameBuffer2);
            gl.deleteTexture(texture2);
          } else {
            texCache.addTexAndDrawWhenLimit(gl, target, opacity, m, cx, cy, 0, 0, true);
          }

          if (target !== _cache5) {
            _i10 += _total9 || 0;

            if (_hasMask6) {
              _i10 += countMaskNum(__structs, _i10 + 1, _hasMask6);
            }
          } else {
            // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用
            _node7.render(renderMode, gl, 0, 0);

            gl.useProgram(gl.program);
            gl.viewport(0, 0, width, height);
          }
        } else if (limitHash.hasOwnProperty(_i10)) {
          var _target5 = limitHash[_i10];

          if (hasMbm && isValidMbm(_mixBlendMode)) {
            texCache.refresh(gl, cx, cy, true);

            var _genFrameBufferWithTe25 = genFrameBufferWithTexture(gl, texCache, width, height),
                _genFrameBufferWithTe26 = _slicedToArray(_genFrameBufferWithTe25, 3),
                _n = _genFrameBufferWithTe26[0],
                _frameBuffer2 = _genFrameBufferWithTe26[1],
                _texture3 = _genFrameBufferWithTe26[2];

            texCache.addTexAndDrawWhenLimit(gl, _target5, opacity, m, cx, cy, 0, 0, true);
            texCache.refresh(gl, cx, cy, true); // 合成结果作为当前frameBuffer，以及纹理和单元，等于替代了当前画布作为绘制对象

            var _genMbmWebgl5 = genMbmWebgl(gl, texCache, n, _n, frameBuffer, texture, mbmName(_mixBlendMode), width, height);

            var _genMbmWebgl6 = _slicedToArray(_genMbmWebgl5, 3);

            n = _genMbmWebgl6[0];
            frameBuffer = _genMbmWebgl6[1];
            texture = _genMbmWebgl6[2];
            gl.deleteFramebuffer(_frameBuffer2);
            gl.deleteTexture(_texture3);
          } else {
            texCache.addTexAndDrawWhenLimit(gl, _target5, opacity, m, cx, cy, 0, 0, true);
          }

          _i10 += _total9 || 0;

          if (_hasMask6) {
            _i10 += countMaskNum(__structs, _i10 + 1, _hasMask6);
          } // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用


          _node7.render(renderMode, gl, 0, 0);

          gl.useProgram(gl.program);
          gl.viewport(0, 0, width, height);
        } // 超限的情况，这里是普通单节点超限，没有合成total后再合成特殊cache如filter/mask/mbm之类的，
        // 直接按原始位置绘制到离屏canvas，再作为纹理绘制即可，特殊的在total那做过降级了
        else if (_node7.__limitCache && _node7.__hasContent) {
          var _c2 = inject.getCacheCanvas(width, height, '__$$OVERSIZE$$__');

          _node7.render(mode.CANVAS, _c2.ctx, 0, 0);

          var _j10 = texCache.lockOneChannel();

          var _texture4 = webgl.createTexture(gl, _c2.canvas, _j10);

          var _mockCache2 = new MockCache(gl, _texture4, 0, 0, width, height, [0, 0, width, height]);

          texCache.addTexAndDrawWhenLimit(gl, _mockCache2, opacity, m, cx, cy, 0, 0, true);
          texCache.refresh(gl, cx, cy, true);

          _c2.ctx.setTransform(1, 0, 0, 1, 0, 0);

          _c2.ctx.globalAlpha = 1;

          _c2.ctx.clearRect(0, 0, width, height);

          _mockCache2.release();

          texCache.releaseLockChannel(_j10); // webgl特殊的外部钩子，比如粒子组件自定义渲染时调用

          _node7.render(renderMode, gl, 0, 0);

          gl.useProgram(gl.program);
          gl.viewport(0, 0, width, height);
        }
      }
    }

    texCache.refresh(gl, cx, cy, true); // 有mbm时将汇总的fbo绘入主画布，否则本身就是到主画布无需多余操作

    if (hasMbm) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      texCache.releaseLockChannel(n);
      gl.deleteFramebuffer(frameBuffer); // 顶点buffer

      var pointBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, pointBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1]), gl.STATIC_DRAW);
      var a_position = gl.getAttribLocation(gl.program, 'a_position');
      gl.vertexAttribPointer(a_position, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_position); // 纹理buffer

      var texBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1]), gl.STATIC_DRAW);
      var a_texCoords = gl.getAttribLocation(gl.program, 'a_texCoords');
      gl.vertexAttribPointer(a_texCoords, 2, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_texCoords); // opacity buffer

      var opacityBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, opacityBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 1, 1, 1, 1]), gl.STATIC_DRAW);
      var a_opacity = gl.getAttribLocation(gl.program, 'a_opacity');
      gl.vertexAttribPointer(a_opacity, 1, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(a_opacity); // 纹理单元

      var u_texture = gl.getUniformLocation(gl.program, 'u_texture');
      gl.uniform1i(u_texture, n);
      gl.drawArrays(gl.TRIANGLES, 0, 6);
      gl.deleteBuffer(pointBuffer);
      gl.deleteBuffer(texBuffer);
      gl.deleteBuffer(opacityBuffer);
      gl.disableVertexAttribArray(a_position);
      gl.disableVertexAttribArray(a_texCoords);
      gl.deleteTexture(texture);
    }
  }

  function renderCanvas(renderMode, ctx, root) {
    var __structs = root.__structs,
        width = root.width,
        height = root.height;
    var mergeList = [];
    /**
     * 先一遍先序遍历收集cacheAsBitmap的节点，说明这棵子树需要缓存，可能出现嵌套，深层级优先、后面优先
     * 可能遇到已有缓存没变化的，这时候不要收集忽略掉，没有缓存的走后面遍历普通渲染
     */

    for (var i = 0, len = __structs.length; i < len; i++) {
      var _structs$i6 = __structs[i],
          node = _structs$i6.node,
          lv = _structs$i6.lv,
          total = _structs$i6.total,
          hasMask = _structs$i6.hasMask; // 排除Text，要么根节点直接绘制，要么被局部根节点汇总，自身并不缓存（fillText比位图更快）

      if (node instanceof Text) {
        continue;
      }

      var __computedStyle = node.__computedStyle; // 跳过display:none元素和它的所有子节点

      if (__computedStyle[DISPLAY$1] === 'none') {
        i += total || 0;

        if (hasMask) {
          i += countMaskNum(__structs, i + 1, hasMask);
        }

        continue;
      } // 根据refreshLevel优化计算，处理其样式


      var __refreshLevel = node.__refreshLevel,
          __cacheTotal = node.__cacheTotal;
      node.__refreshLevel = NONE$1; // filter变化需重新生成，cacheTotal本身就存在要判断下；CACHE取消重新生成则无需判断

      if (node.__cacheAsBitmap) {
        if (contain$1(__refreshLevel, CACHE$1 | FT$1) || __refreshLevel >= REPAINT$1) {
          mergeList.push({
            i: i,
            lv: lv,
            total: total,
            node: node,
            hasMask: hasMask
          });
        }
      } // total可以跳过所有孩子节点省略循环，filter/mask等的强制前提是有total


      if (__cacheTotal && __cacheTotal.available) {
        i += total || 0;

        if (__refreshLevel === NONE$1 && hasMask) {
          i += countMaskNum(__structs, i + 1, hasMask);
        }
      }
    }
    /**
     * 根据收集的需要合并局部根的索引，尝试合并，按照层级从大到小，索引从大到小的顺序，
     * 这样保证子节点在前，后节点在前，后节点是为了mask先应用自身如filter之后再进行遮罩
     */


    if (mergeList.length) {
      mergeList.sort(function (a, b) {
        if (a.lv === b.lv) {
          return b.i - a.i;
        }

        return b.lv - a.lv;
      });
      mergeList.forEach(function (item) {
        var i = item.i,
            lv = item.lv,
            total = item.total,
            node = item.node,
            hasMask = item.hasMask;

        var __cacheTotal = genTotal(renderMode, node, i, lv, total || 0, __structs, hasMask, width, height);

        if (__cacheTotal) {
          genTotalOther(renderMode, __structs, __cacheTotal, node, hasMask, width, height);
        }
      });
    }
    /**
     * 最后先序遍历一次并应用__cacheTotal即可，没有的普通绘制，以及剩下的超尺寸的和Text
     * 特殊离屏和cacheAsBitmap的离屏都已经产生了cacheTotal，除非超限
     * 离屏功能的数据结构和算法逻辑非常复杂，需用到下面2个hash，来完成一些filter、mask等离屏才能完成的绘制
     * 其中overflow、filter、mix-blend-mode是对自身及子节点，mask则是对自身和后续next遮罩节点
     * 一个节点在Xom渲染中申请离屏canvas，是按照一定顺序来的，且多个离屏后面的有前面的ctx引用，第一个则引用最初非离屏的ctx
     * 这个顺序在应用离屏时以反向顺序开始，这样最后ctx被还原到最初的ctx
     * mask是个十分特殊的离屏，因为除了自身外，next节点也需要汇总到另外一个离屏上，为了逻辑一致性
     * 所有离屏应用的索引都以最后一个节点的索引为准，即有mask时以最后一个mask，无mask则以自身节点的最后一个（+total)为索引
     * 由于存在普通非cache绘制，所以依然要用到栈代替递归计算matrix
     */


    var maskStartHash = {};
    var offscreenHash = {};

    for (var _i11 = 0, _len9 = __structs.length; _i11 < _len9; _i11++) {
      var _structs$_i6 = __structs[_i11],
          _node8 = _structs$_i6.node,
          _lv4 = _structs$_i6.lv,
          _total10 = _structs$_i6.total,
          _hasMask7 = _structs$_i6.hasMask; // text如果display不可见，parent会直接跳过，不会走到这里，这里一定是直接绘制到root的，visibility在其内部判断

      if (_node8 instanceof Text) {
        _node8.render(renderMode, ctx, 0, 0);

        if (offscreenHash.hasOwnProperty(_i11)) {
          ctx = applyOffscreen(ctx, offscreenHash[_i11], width, height, false);
        }
      } else {
        var _computedStyle4 = _node8.__computedStyle; // none跳过这棵子树，判断下最后一个节点的离屏应用即可

        if (_computedStyle4[DISPLAY$1] === 'none') {
          _i11 += _total10 || 0;

          if (_hasMask7) {
            _i11 += countMaskNum(__structs, _i11 + 1, _hasMask7);
          }

          if (offscreenHash.hasOwnProperty(_i11)) {
            ctx = applyOffscreen(ctx, offscreenHash[_i11], width, height, true);
          }

          continue;
        }

        var _cacheTotal5 = _node8.__cacheTotal,
            __cacheFilter = _node8.__cacheFilter,
            __cacheMask = _node8.__cacheMask,
            __cacheOverflow = _node8.__cacheOverflow,
            __domParent = _node8.__domParent,
            __matrix = _node8.__matrix; // 遮罩对象申请了个离屏，其第一个mask申请另外一个离屏mask2，开始聚集所有mask元素的绘制，
        // 这是一个十分特殊的逻辑，保存的index是最后一个节点的索引，OFFSCREEN_MASK2是最低优先级，
        // 这样当mask本身有filter时优先自身，然后才是OFFSCREEN_MASK2

        if (maskStartHash.hasOwnProperty(_i11)) {
          var _maskStartHash$_i2 = maskStartHash[_i11],
              idx = _maskStartHash$_i2.idx,
              _hasMask8 = _maskStartHash$_i2.hasMask,
              offscreenMask = _maskStartHash$_i2.offscreenMask;

          var _target6 = inject.getCacheCanvas(width, height, null, 'mask2');

          offscreenMask.mask = _target6; // 应用mask用到

          offscreenMask.isClip = _node8.__isClip; // 定位到最后一个mask元素上的末尾

          var j = _i11 + (_total10 || 0) + 1;

          while (--_hasMask8) {
            var _total11 = __structs[j].total;
            j += (_total11 || 0) + 1;
          }

          j--;
          var list = offscreenHash[j] = offscreenHash[j] || [];
          list.push({
            idx: idx,
            lv: _lv4,
            type: OFFSCREEN_MASK,
            offscreen: offscreenMask
          });
          list.push({
            idx: j,
            lv: _lv4,
            type: OFFSCREEN_MASK2,
            offscreen: {
              ctx: ctx,
              // 保存等待OFFSCREEN_MASK2时还原
              target: _target6
            }
          });
          ctx = _target6.ctx;
        } // 设置opacity/matrix，根节点是没有父节点的不计算继承值


        var opacity = _computedStyle4[OPACITY$1];
        var m = __matrix;

        if (__domParent) {
          opacity *= __domParent.__opacity;
          m = multiply(__domParent.__matrixEvent, m);
        }

        _node8.__opacity = opacity;
        assignMatrix(_node8.__matrixEvent, m); // 有cache声明从而有total的可以直接绘制并跳过子节点索，total生成可能会因超限而失败

        var target = getCache([__cacheMask, __cacheFilter, __cacheOverflow, _cacheTotal5]);

        if (target) {
          _i11 += _total10 || 0;

          if (_hasMask7) {
            _i11 += countMaskNum(__structs, _i11 + 1, _hasMask7);
          }

          ctx.globalAlpha = opacity;
          ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);
          var mixBlendMode = _computedStyle4[MIX_BLEND_MODE$1];

          if (isValidMbm(mixBlendMode)) {
            ctx.globalCompositeOperation = mbmName(mixBlendMode);
          }

          var x = target.x,
              y = target.y,
              canvas = target.canvas,
              sx1 = target.sx1,
              sy1 = target.sy1,
              dbx = target.dbx,
              dby = target.dby,
              _width2 = target.width,
              _height2 = target.height;
          ctx.drawImage(canvas, x, y, _width2, _height2, sx1 - dbx, sy1 - dby, _width2, _height2); // total应用后记得设置回来

          ctx.globalCompositeOperation = 'source-over'; // 父超限但子有total的时候，i此时已经增加到了末尾，也需要检查

          if (offscreenHash.hasOwnProperty(_i11)) {
            ctx = applyOffscreen(ctx, offscreenHash[_i11], _width2, _height2, false);
          }
        } // 没有cacheTotal是普通节点绘制
        else {
          // 如果有离屏则先申请替换ctx
          var offscreenBlend = void 0,
              _offscreenMask3 = void 0,
              offscreenFilter = void 0,
              offscreenOverflow = void 0;

          var _offscreen3 = _node8.__calOffscreen(ctx, _computedStyle4);

          if (_offscreen3) {
            ctx = _offscreen3.ctx;
            offscreenBlend = _offscreen3.offscreenBlend;
            _offscreenMask3 = _offscreen3.offscreenMask;
            offscreenFilter = _offscreen3.offscreenFilter;
            offscreenOverflow = _offscreen3.offscreenOverflow;
          } // 节点自身渲染


          ctx.globalAlpha = opacity;
          ctx.setTransform(m[0], m[1], m[4], m[5], m[12], m[13]);

          _node8.render(renderMode, ctx, 0, 0); // 这里离屏顺序和xom里返回的一致，和下面应用离屏时的list相反


          if (offscreenBlend) {
            var _j11 = _i11 + (_total10 || 0);

            if (_hasMask7) {
              _j11 += countMaskNum(__structs, _j11 + 1, _hasMask7);
            }

            var _list7 = offscreenHash[_j11] = offscreenHash[_j11] || [];

            _list7.push({
              idx: _i11,
              lv: _lv4,
              type: OFFSCREEN_BLEND,
              offscreen: offscreenBlend
            });
          } // 被遮罩的节点要为第一个遮罩和最后一个遮罩的索引打标，被遮罩的本身在一个离屏canvas，遮罩的元素在另外一个
          // 最后一个遮罩索引因数量不好计算，放在maskStartHash做


          if (_offscreenMask3) {
            var _j12 = _i11 + (_total10 || 0);

            maskStartHash[_j12 + 1] = {
              idx: _i11,
              hasMask: _hasMask7,
              offscreenMask: _offscreenMask3
            };
          } // filter造成的离屏，需要将后续一段孩子节点区域的ctx替换，并在结束后应用结果，再替换回来


          if (offscreenFilter) {
            var _j13 = _i11 + (_total10 || 0);

            if (_hasMask7) {
              _j13 += countMaskNum(__structs, _j13 + 1, _hasMask7);
            }

            var _list8 = offscreenHash[_j13] = offscreenHash[_j13] || [];

            _list8.push({
              idx: _i11,
              lv: _lv4,
              type: OFFSCREEN_FILTER,
              offscreen: offscreenFilter
            });
          } // overflow:hidden的离屏，最后孩子进行截取


          if (offscreenOverflow) {
            var _j14 = _i11 + (_total10 || 0);

            if (_hasMask7) {
              _j14 += countMaskNum(__structs, _j14 + 1, _hasMask7);
            }

            var _list9 = offscreenHash[_j14] = offscreenHash[_j14] || [];

            _list9.push({
              idx: _i11,
              lv: _lv4,
              type: OFFSCREEN_OVERFLOW,
              offscreen: offscreenOverflow
            });
          } // 离屏应用，按照lv从大到小即子节点在前先应用，同一个节点多个效果按offscreen优先级从小到大来，
          // 由于mask特殊索引影响，所有离屏都在最后一个mask索引判断，此时mask本身优先结算，以index序大到小判断


          if (offscreenHash.hasOwnProperty(_i11)) {
            ctx = applyOffscreen(ctx, offscreenHash[_i11], width, height, false);
          }
        }
      }
    }
  }

  var struct = {
    renderCanvas: renderCanvas,
    renderSvg: renderSvg,
    renderWebgl: renderWebgl
  };

  var vertex = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;attribute float a_opacity;varying float v_opacity;void main(){gl_Position=a_position;v_texCoords=a_texCoords;v_opacity=a_opacity;}"; // eslint-disable-line

  var fragment = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;varying float v_opacity;uniform sampler2D u_texture;void main(){float opacity=v_opacity;if(opacity<=0.0){discard;}opacity=clamp(opacity,0.0,1.0);vec4 color=texture2D(u_texture,v_texCoords);gl_FragColor=color*opacity;}"; // eslint-disable-line

  var vertexMask = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentMask = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);float a=color1.a*color2.a;gl_FragColor=vec4(color1.rgb*color2.a,a);}"; // eslint-disable-line

  var fragmentClip = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture1;uniform sampler2D u_texture2;void main(){vec4 color1=texture2D(u_texture1,v_texCoords);vec4 color2=texture2D(u_texture2,v_texCoords);float a=color1.a*(1.0-color2.a);gl_FragColor=vec4(color1.rgb*(1.0-color2.a),a);}"; // eslint-disable-line

  var fragmentOverflow = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;void main(){gl_FragColor=texture2D(u_texture,v_texCoords);}"; // eslint-disable-line

  var vertexCm = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentCm = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform float u_m[20];void main(){vec4 c=texture2D(u_texture,v_texCoords);if(c.a>0.0){c.rgb/=c.a;}vec4 result;result.r=(u_m[0]*c.r);result.r+=(u_m[1]*c.g);result.r+=(u_m[2]*c.b);result.r+=(u_m[3]*c.a);result.r+=u_m[4];result.g=(u_m[5]*c.r);result.g+=(u_m[6]*c.g);result.g+=(u_m[7]*c.b);result.g+=(u_m[8]*c.a);result.g+=u_m[9];result.b=(u_m[10]*c.r);result.b+=(u_m[11]*c.g);result.b+=(u_m[12]*c.b);result.b+=(u_m[13]*c.a);result.b+=u_m[14];result.a=(u_m[15]*c.r);result.a+=(u_m[16]*c.g);result.a+=(u_m[17]*c.b);result.a+=(u_m[18]*c.a);result.a+=u_m[19];gl_FragColor=vec4(result.rgb*result.a,result.a);}"; // eslint-disable-line

  var vertexDs = "#version 100\n#define GLSLIFY 1\nattribute vec4 a_position;attribute vec2 a_texCoords;varying vec2 v_texCoords;void main(){gl_Position=a_position;v_texCoords=a_texCoords;}"; // eslint-disable-line

  var fragmentDs = "#version 100\n#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\nvarying vec2 v_texCoords;uniform sampler2D u_texture;uniform float u_color[4];void main(){vec4 c=texture2D(u_texture,v_texCoords);gl_FragColor=vec4(u_color[0]*c.a,u_color[1]*c.a,u_color[2]*c.a,u_color[3]*c.a);}"; // eslint-disable-line

  var TexCache = /*#__PURE__*/function () {
    function TexCache(units) {
      this.__units = units; // 通道数量限制，8~16

      this.__pages = []; // 存当前page列表，通道数量8~16，缓存收留尽可能多的page

      this.__list = []; // 本次渲染暂存的数据，[cache, opacity, matrix, dx, dy]

      this.__channels = []; // 每个纹理通道记录还是个数组，下标即纹理单元，内容为Page

      this.__locks = []; // 锁定纹理单元列表，下标即纹理单元，内容true为锁定

      this.__lockUnits = 0;
    }
    /**
     * webgl每次绘制为添加纹理并绘制，此处尝试尽可能收集所有纹理贴图，以达到尽可能多的共享纹理，再一次性绘制
     * 收集的是Page对象（从cache中取得），里面包含了若干个节点的贴图，canvas本身是2的幂次方大小
     * webgl最少有8个纹理单元最多16个，因此存了一个列表来放这些Page的canvas，刷新后清空，但纹理通道映射记录保留
     * 当8个纹理单元全部满了，进行绘制并清空这个队列，外部主循环结束时也会检查队列是否还有余留并绘制
     * 初始调用队列为空，存入Page对象，后续调用先查看是否存在以便复用，再决定是否存入Page，直到8个满了
     * Page上存有update表示是否更新，每次cache绘制时会变true，以此表示是否有贴图更新，删除可以忽视
     * 还需要一个记录上次纹理通道使用哪个Page的canvas的地方，即映射，清空后队列再次添加时，如果Page之前被添加过，
     * 此次又被添加且没有变更update，可以直接复用上次的纹理单元号且无需再次上传纹理，节省性能
     * 后续接入局部纹理更新也是复用单元号，如果update变更可以选择局部上传纹理而非整个重新上传
     * 判断上传的逻辑在收集满8个后绘制前进行，因为添加队列过程中可能会变更Page及其update
     * @param gl
     * @param cache
     * @param opacity
     * @param matrix
     * @param cx
     * @param cy
     * @param dx
     * @param dy
     * @param revertY
     */


    _createClass(TexCache, [{
      key: "addTexAndDrawWhenLimit",
      value: function addTexAndDrawWhenLimit(gl, cache, opacity, matrix, cx, cy) {
        var dx = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
        var dy = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
        var revertY = arguments.length > 8 ? arguments[8] : undefined;
        var pages = this.__pages;
        var list = this.__list;
        var page = cache.page;
        var i = pages.indexOf(page); // 找到说明已有page在此索引的通道中，记录下来info

        if (i > -1) {
          list.push([cache, opacity, matrix, dx, dy]);
        } // 找不到说明是新的纹理贴图，此时看是否超过纹理单元限制，超过则刷新绘制并清空，然后/否则 存入纹理列表
        else {
          i = pages.length;

          if (i >= this.__units - this.__lockUnits) {
            // 绘制且清空，队列索引重新为0
            this.refresh(gl, cx, cy, revertY);
          }

          pages.push(page);
          list.push([cache, opacity, matrix, dx, dy]);
        }
      }
      /**
       * 刷新
       * @param gl
       * @param cx
       * @param cy
       * @param revertY
       */

    }, {
      key: "refresh",
      value: function refresh(gl, cx, cy, revertY) {
        var pages = this.__pages;
        var list = this.__list; // 防止空调用刷新，struct循环结尾会强制调用一次防止有未渲染的

        if (pages.length) {
          var channels = this.channels;
          var locks = this.locks; // 先将上次渲染的纹理单元使用的Page形成一个hash，键为page的uuid，值为纹理单元

          var lastHash = {};
          channels.forEach(function (item, i) {
            if (item) {
              var uuid = item.uuid;
              lastHash[uuid] = i;
            }
          });
          var units = this.__units; // 再遍历，查找相同的Page并保持其使用的纹理单元不变，存入相同索引下标oldList，不同的按顺序收集放newList

          var oldList = new Array(units),
              newList = [];
          pages.forEach(function (page) {
            var uuid = page.uuid;

            if (lastHash.hasOwnProperty(uuid)) {
              var index = lastHash[uuid];
              oldList[index] = page;
            } else {
              newList.push(page);
            }
          });
          /**
           * 以oldList为基准，将newList依次存入oldList中
           * 优先使用未用过的纹理单元，以便用过的可能下次用到无需重新上传
           * 找不到未用过的后，尝试NRU算法，优先淘汰最近未使用的Page，相等则尺寸小的
           */

          if (newList.length) {
            // 先循环找空的，oldList空且channels空且locks空
            for (var i = 0; i < units; i++) {
              if (!oldList[i] && !channels[i] && !locks[i]) {
                oldList[i] = newList.shift();

                if (!newList.length) {
                  break;
                }
              }
            }

            var len = newList.length;

            if (len) {
              // 按时间排序已使用channel且未被当前占用的，以便淘汰最久未使用的
              var cl = [];

              for (var _i = 0; _i < units; _i++) {
                if (!oldList[_i] && !locks[_i]) {
                  cl.push([_i, channels[_i]]);
                }
              }

              cl.sort(function (a, b) {
                if (a[1].time !== b[1].time) {
                  return (a[1].time || 0) - (b[1].time || 0);
                }

                if (a[1].fullSize !== b[1].fullSize) {
                  return a[1].fullSize - b[1].fullSize;
                }

                return a[0] - b[0];
              }); // cl靠前是时间小尺寸小的，优先使用替换

              for (var _i2 = 0; _i2 < len; _i2++) {
                oldList[cl[_i2][0]] = newList[_i2];
              }
            }
          }
          /**
           * 对比上帧渲染的和这次纹理单元情况，Page相同且!update可以省略更新，其它均重新赋值纹理
           * 后续局部更新Page相同但有update，会出现没有上帧的情况如初始渲染，此时先创建纹理单元再更新
           * 将新的数据赋给老的，可能新的一帧使用的少于上一帧，老的没用到的需继续保留
           */


          var hash = {};

          for (var _i3 = 0, _len = oldList.length; _i3 < _len; _i3++) {
            var page = oldList[_i3]; // 可能为空，不满的情况下前面单元保留老tex先用的后面的单元

            if (!page) {
              continue;
            }

            var last = channels[_i3];

            if (!last || last !== page || page.update) {
              // page可能为一个已有fbo纹理，或者贴图
              if (page instanceof MockPage) {
                webgl.bindTexture(gl, page.texture, _i3);
              } else {
                // 可能老的先删除，注意只删Page，MockPage是fbo生成的texture即total缓存不能自动清除
                if (last && !(last instanceof MockPage)) {
                  gl.deleteTexture(last.texture);
                }

                page.texture = webgl.createTexture(gl, page.canvas, _i3);
              }

              channels[_i3] = page;
            }

            hash[page.uuid] = _i3; // 标识没有更新，以及最后使用时间

            page.update = false;
            page.time = inject.now();
          } // 再次遍历开始本次渲染并清空


          webgl.drawTextureCache(gl, list, hash, cx, cy, revertY);
          pages.splice(0);
          list.splice(0);
        }
      }
    }, {
      key: "findExistTexChannel",
      value: function findExistTexChannel(page) {
        return this.channels.indexOf(page);
      }
      /**
       * 获取并锁定一个纹理单元优先使用空的，其次最久未使用的
       * @returns {number|*}
       */

    }, {
      key: "lockOneChannel",
      value: function lockOneChannel() {
        // 优先返回空单元
        var channels = this.channels;
        var locks = this.locks;

        for (var i = 0; i < this.__units; i++) {
          if (!channels[i] && !locks[i]) {
            locks[i] = true;
            this.__lockUnits++;
            return i;
          }
        } // 根据NRU返回最久未使用的


        var units = this.__units;
        var cl = [];

        for (var _i4 = 0; _i4 < units; _i4++) {
          if (!locks[_i4]) {
            cl.push([_i4, channels[_i4]]);
          }
        }

        if (cl.length) {
          cl.sort(function (a, b) {
            if (a[1].time !== b[1].time) {
              return (a[1].time || 0) - (b[1].time || 0);
            }

            if (a[1].fullSize !== b[1].fullSize) {
              return a[1].fullSize - b[1].fullSize;
            }

            return a[0] - b[0];
          });
          var _i5 = cl[0][0];
          channels[_i5] = null;
          locks[_i5] = true;
          this.__lockUnits++;
          return _i5;
        }

        throw new Error('No free texture unit');
      }
      /**
       * 释放掉i单元，并且设置内容到缓存channel中
       * @param i
       * @param setToChannel
       */

    }, {
      key: "releaseLockChannel",
      value: function releaseLockChannel(i, setToChannel) {
        if (this.locks[i]) {
          this.locks[i] = false;
          this.__lockUnits--;

          if (setToChannel) {
            this.channels[i] = setToChannel;
          }
        }
      } // 指定锁定一个单元

    }, {
      key: "lockChannel",
      value: function lockChannel(i) {
        var channels = this.channels;
        var locks = this.locks;

        if (!locks[i]) {
          channels[i] = null;
          locks[i] = true;
          this.__lockUnits++;
        }
      }
      /**
       * 释放纹理单元
       * @param gl
       */

    }, {
      key: "release",
      value: function release(gl) {
        this.channels.forEach(function (item) {
          if (item) {
            gl.deleteTexture(item.texture);
          }
        });
      }
    }, {
      key: "channels",
      get: function get() {
        return this.__channels;
      }
    }, {
      key: "locks",
      get: function get() {
        return this.__locks;
      }
    }, {
      key: "last",
      get: function get() {
        var list = this.__list,
            len = list.length;

        if (len) {
          return list[len - 1];
        }
      }
    }]);

    return TexCache;
  }();

  var _enums$STYLE_KEY = enums.STYLE_KEY,
      TOP = _enums$STYLE_KEY.TOP,
      RIGHT = _enums$STYLE_KEY.RIGHT,
      BOTTOM = _enums$STYLE_KEY.BOTTOM,
      LEFT = _enums$STYLE_KEY.LEFT,
      POSITION = _enums$STYLE_KEY.POSITION,
      DISPLAY = _enums$STYLE_KEY.DISPLAY,
      VISIBILITY = _enums$STYLE_KEY.VISIBILITY,
      COLOR = _enums$STYLE_KEY.COLOR,
      WIDTH = _enums$STYLE_KEY.WIDTH,
      HEIGHT = _enums$STYLE_KEY.HEIGHT,
      Z_INDEX = _enums$STYLE_KEY.Z_INDEX,
      POINTER_EVENTS = _enums$STYLE_KEY.POINTER_EVENTS,
      WRITING_MODE = _enums$STYLE_KEY.WRITING_MODE,
      TEXT_STROKE_COLOR = _enums$STYLE_KEY.TEXT_STROKE_COLOR,
      TEXT_STROKE_WIDTH = _enums$STYLE_KEY.TEXT_STROKE_WIDTH,
      TEXT_STROKE_OVER = _enums$STYLE_KEY.TEXT_STROKE_OVER,
      MATRIX = _enums$STYLE_KEY.MATRIX,
      TRANSFORM = _enums$STYLE_KEY.TRANSFORM,
      OPACITY = _enums$STYLE_KEY.OPACITY,
      MIX_BLEND_MODE = _enums$STYLE_KEY.MIX_BLEND_MODE;
  var isNil$7 = util.isNil,
      isObject = util.isObject,
      isFunction$1 = util.isFunction;
  var PX = o$4.PX,
      INHERIT = o$4.INHERIT;
  var contain = o$1.contain,
      getLevel = o$1.getLevel,
      isRepaint = o$1.isRepaint,
      NONE = o$1.NONE,
      FT = o$1.FILTER,
      PPT = o$1.PERSPECTIVE,
      REPAINT = o$1.REPAINT,
      REFLOW = o$1.REFLOW,
      REBUILD = o$1.REBUILD,
      CACHE = o$1.CACHE,
      TF = o$1.TRANSFORM,
      TRANSFORM_ALL = o$1.TRANSFORM_ALL,
      OP = o$1.OPACITY,
      MBM = o$1.MIX_BLEND_MODE;
  var isGeom = o$2.isGeom;
  var ROOT_DOM_NAME = {
    canvas: 'canvas',
    svg: 'svg',
    webgl: 'canvas'
  };

  function getDom(dom) {
    if (util.isString(dom) && dom) {
      var o = document.querySelector(dom);

      if (!o) {
        throw new Error('Can not find dom of selector: ' + dom);
      }

      return o;
    }

    if (!dom) {
      throw new Error('Can not find dom: ' + dom);
    }

    return dom;
  }

  function renderProp(k, v) {
    var s = Array.isArray(v) ? util.joinSourceArray(v) : util.stringify(v);

    if (k === 'className') {
      k = 'class';
    } else if (k === 'style') {
      return '';
    }

    return ' ' + k + '="' + util.encodeHtml(s, true) + '"';
  }

  var EVENT_LIST = ['click', 'dblclick', 'mousedown', 'mousemove', 'mouseup', 'touchstart', 'touchmove', 'touchend', 'touchcancel'];

  function initEvent(dom, Root) {
    var list = [];
    EVENT_LIST.forEach(function (type) {
      function cb(e) {
        var root = dom.__root;

        if (root && root instanceof Root) {
          if (['touchend', 'touchcancel', 'touchmove'].indexOf(type) > -1) {
            var target = root.__touchstartTarget;

            var event = root.__wrapEvent(e);

            event.target = target;

            while (target) {
              target.__emitEvent(event, null, true);

              target = target.domParent;
            }
          } else {
            root.__cb(e);
          }
        }
      }

      dom.addEventListener(type, cb);
      list.push([type, cb]);
    });
    return list;
  }

  function removeEvent(dom, list) {
    list.forEach(function (item) {
      dom.removeEventListener(item[0], item[1]);
    });
  }

  var uuid = 0;

  var Root = /*#__PURE__*/function (_Dom) {
    _inherits(Root, _Dom);

    function Root(tagName, props, children) {
      var _this;

      _this = _Dom.call(this, tagName, props, children) || this;
      _this.__dom = null; // 真实DOM引用

      _this.__mw = 0; // 记录最大宽高，防止尺寸变化清除不完全

      _this.__mh = 0; // this.__scx = 1; // 默认缩放，css改变canvas/svg缩放后影响事件坐标，有值手动指定，否则自动计算
      // this.__scy = 1;

      _this.__taskUp = [];
      _this.__task = [];
      _this.__ref = {};
      _this.__reflowList = [{
        node: _assertThisInitialized(_this)
      }]; // 初始化填自己，第一次布局时复用逻辑完全重新布局

      _this.__animateController = new Controller();
      Event.mix(_assertThisInitialized(_this));
      _this.__updateHash = {};
      _this.__uuid = uuid++;
      _this.__rlv = REBUILD; // 每次刷新最大lv

      builder.buildRoot(_assertThisInitialized(_this), _this.__children);
      return _this;
    }

    _createClass(Root, [{
      key: "__initProps",
      value: function __initProps() {
        var w = this.props.width;

        if (!isNil$7(w)) {
          var value = parseFloat(w) || 0;

          if (value > 0) {
            this.__width = value;
          }
        }

        var h = this.props.height;

        if (!isNil$7(h)) {
          var _value = parseFloat(h) || 0;

          if (_value > 0) {
            this.__height = _value;
          }
        }
      }
    }, {
      key: "__genHtml",
      value: function __genHtml(domName) {
        var _this2 = this;

        var res = "<".concat(domName); // 拼接处理属性

        Object.keys(this.props).forEach(function (k) {
          var v = _this2.props[k]; // 忽略事件

          if (!/^on[a-zA-Z]/.test(k)) {
            res += renderProp(k, v);
          }
        });
        res += "></".concat(domName, ">");
        return res;
      }
    }, {
      key: "__wrapEvent",
      value: function __wrapEvent(e) {
        var x, y; // 触摸结束取消特殊没有touches

        if (['touchend', 'touchcancel'].indexOf(e.type) === -1) {
          var dom = this.dom,
              __scx = this.__scx,
              __scy = this.__scy;

          var _dom$getBoundingClien = dom.getBoundingClientRect(),
              x2 = _dom$getBoundingClien.x,
              y2 = _dom$getBoundingClien.y,
              left = _dom$getBoundingClien.left,
              top = _dom$getBoundingClien.top,
              width = _dom$getBoundingClien.width,
              height = _dom$getBoundingClien.height;

          x = x2 || left || 0;
          y = y2 || top || 0;

          var _ref = e.touches ? e.touches[0] : e,
              clientX = _ref.clientX,
              clientY = _ref.clientY;

          x = clientX - x;
          y = clientY - y; // 外边的scale影响元素事件响应，根据倍数计算真实的坐标，优先手动指定，否则自动计算

          if (!isNil$7(__scx)) {
            x /= __scx;
          } else {
            x *= this.width / width;
          }

          if (!isNil$7(__scy)) {
            y /= __scy;
          } else {
            y *= this.height / height;
          }
        }

        return {
          event: e,
          stopPropagation: function stopPropagation() {
            this.__stopPropagation = true;
            e.stopPropagation();
          },
          stopImmediatePropagation: function stopImmediatePropagation() {
            this.__stopPropagation = true;
            this.__stopImmediatePropagation = true;
            e.stopImmediatePropagation();
          },
          preventDefault: function preventDefault() {
            e.preventDefault();
          },
          x: x,
          y: y,
          __hasEmitted: false
        };
      } // 类似touchend/touchcancel/touchmove这种无需判断是否发生于元素上，直接响应

    }, {
      key: "__cb",
      value: function __cb(e) {
        if (e.type === 'touchmove' && !this.__touchstartTarget) {
          return;
        }

        var data = this.__wrapEvent(e);

        this.__emitEvent(data, null, false);

        return data;
      }
      /**
       * 添加到真实Dom上，优先已存在的同名canvas/svg节点，没有则dom下生成新的
       * @param dom
       */

    }, {
      key: "appendTo",
      value: function appendTo(dom) {
        dom = getDom(dom); // this.__children = builder.initRoot(this.__cd, this);

        this.__isDestroyed = false;

        this.__initProps();

        var tagName = this.tagName;
        var domName = ROOT_DOM_NAME[tagName]; // OffscreenCanvas兼容，包含worker的

        if (typeof window !== 'undefined' && window.OffscreenCanvas && dom instanceof window.OffscreenCanvas || typeof self !== 'undefined' && self.OffscreenCanvas && dom instanceof self.OffscreenCanvas) {
          this.__dom = dom;
          this.__width = dom.width;
          this.__height = dom.height;
        } // 已有root节点
        else if (dom.nodeName.toLowerCase() === domName) {
          this.__dom = dom;

          if (this.width) {
            dom.setAttribute('width', this.width);
          }

          if (this.height) {
            dom.setAttribute('height', this.height);
          }
        } // 没有canvas/svg节点则生成一个新的
        else {
          this.__dom = dom.querySelector(domName);

          if (!this.__dom) {
            dom.innerHTML = this.__genHtml(domName);
            this.__dom = dom.querySelector(domName);
          }
        }

        this.__defs = this.dom.__defs || Defs.getInstance(this.__uuid); // 没有设置width/height则采用css计算形式

        if (!this.width || !this.height) {
          var domCss = window.getComputedStyle(dom, null);

          if (!this.width) {
            this.__width = parseFloat(domCss.getPropertyValue('width')) || 0;
            dom.setAttribute('width', this.width);
          }

          if (!this.height) {
            this.__height = parseFloat(domCss.getPropertyValue('height')) || 0;
            dom.setAttribute('height', this.height);
          }
        } // 最终无宽高给出警告


        if (!this.width || !this.height) {
          inject.warn('Karas render target with a width or height of 0.');
        }

        var params = Object.assign({}, ca, this.props.contextAttributes); // 只有canvas有ctx，svg用真实dom

        if (this.tagName === 'canvas') {
          this.__ctx = this.__dom.getContext('2d', params);
          this.__renderMode = mode.CANVAS;
        } else if (this.tagName === 'svg') {
          this.__renderMode = mode.SVG;
        } else if (this.tagName === 'webgl') {
          var gl = this.__ctx = this.__dom.getContext('webgl', params);

          this.__renderMode = mode.WEBGL;
          gl.program = webgl.initShaders(gl, vertex, fragment);
          gl.programMask = webgl.initShaders(gl, vertexMask, fragmentMask);
          gl.programClip = webgl.initShaders(gl, vertexMask, fragmentClip);
          gl.programOverflow = webgl.initShaders(gl, vertexMask, fragmentOverflow);
          gl.programCm = webgl.initShaders(gl, vertexCm, fragmentCm);
          gl.programDs = webgl.initShaders(gl, vertexDs, fragmentDs);
          gl.useProgram(gl.program); // 第一次渲染生成纹理缓存管理对象，收集渲染过程中生成的纹理并在gl纹理单元满了时进行绘制和清空，减少texImage2d耗时问题

          var MAX_TEXTURE_IMAGE_UNITS = Math.min(16, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS));
          this.__texCache = new TexCache(MAX_TEXTURE_IMAGE_UNITS);
        }

        this.refresh(true); // 第一次节点没有__root，渲染一次就有了才能diff

        if (this.dom.__root && this.dom.__root instanceof Root) {
          this.dom.__root.destroy();
        }

        this.__eventCbList = initEvent(this.dom, Root);
        this.dom.__root = this;
      }
    }, {
      key: "__reLayout",
      value: function __reLayout() {
        var renderMode = this.renderMode,
            width = this.width,
            height = this.height;

        this.__checkRoot(renderMode, width, height);

        var wm = this.__currentStyle[WRITING_MODE];
        var isUpright = wm.v && wm.v.indexOf('vertical') === 0; // 布局分为两步，普通流和定位流，互相递归

        this.__layout({
          x: 0,
          y: 0,
          w: width,
          h: height,
          isUpright: isUpright
        }, false, false, false); // 绝对布局需要从根开始保存相对坐标系的容器引用，并根据relative/absolute情况变更


        this.__layoutAbs(this, {
          x: 0,
          y: 0,
          w: width,
          h: height,
          isUpright: isUpright
        }, null);

        this.__structs = this.__structure(0, 0);
      }
    }, {
      key: "refresh",
      value: function refresh(isFirst) {
        // this.__hookTask = null;
        var isDestroyed = this.isDestroyed,
            renderMode = this.renderMode,
            ctx = this.ctx,
            defs = this.defs;

        if (isDestroyed) {
          return;
        }

        defs.clear(); // 首次递归测量整树的继承，后续更改各自更新机制做，防止每次整树遍历；root检查首次直接做，后续在checkUpdate()中插入

        if (isFirst) {
          this.__reLayout();
        } // 非首次刷新如果没有更新则无需继续
        // else if(!this.__checkUpdate(renderMode, ctx, width, height)) {
        //   return;
        // }
        // this.__checkReflow(width, height);


        if (this.props.noRender) {
          return;
        }

        if (renderMode === mode.CANVAS) {
          this.__clear(ctx, renderMode);

          struct.renderCanvas(renderMode, ctx, this);
        } // svg的特殊diff需要
        else if (renderMode === mode.SVG) {
          struct.renderSvg(renderMode, defs, this, isFirst);
          var nvd = this.virtualDom;
          nvd.defs = defs.value;

          if (this.dom.__vd) {
            // console.log(this.dom.__vd);
            // console.log(nvd);
            diff(this.dom, this.dom.__vd, nvd);
          } else {
            this.dom.innerHTML = util.joinVirtualDom(nvd);
          }

          this.dom.__vd = nvd;
          this.dom.__defs = defs;
        } else if (renderMode === mode.WEBGL) {
          this.__clear(ctx, renderMode);

          struct.renderWebgl(renderMode, ctx, this);
        } // 特殊cb，供小程序绘制完回调使用
        // if(isFunction(cb)) {
        //   cb();
        // }


        this.emit(Event.REFRESH, this.__rlv);
        this.__rlv = NONE;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.__destroy();

        this.animateController.__destroy();

        var n = this.dom;

        if (n) {
          removeEvent(n, this.__eventCbList || []);
          n.__root = null;
        }

        var gl = this.ctx;

        if (this.__texCache && gl) {
          this.__texCache.release(gl);

          if (gl.program) {
            gl.deleteShader(gl.program.vertexShader);
            gl.deleteShader(gl.program.fragmentShader);
            gl.deleteProgram(gl.program);
          }

          if (gl.programMask) {
            gl.deleteShader(gl.programMask.vertexShader);
            gl.deleteShader(gl.programMask.fragmentShader);
            gl.deleteProgram(gl.programMask);
          }

          if (gl.programOverflow) {
            gl.deleteShader(gl.programOverflow.vertexShader);
            gl.deleteShader(gl.programOverflow.fragmentShader);
            gl.deleteProgram(gl.programOverflow);
          }
        }
      }
    }, {
      key: "scale",
      value: function scale() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
        this.__scx = x;
        this.__scy = y;
      }
    }, {
      key: "resize",
      value: function resize(w, h, cb) {
        var self = this;

        if (w !== self.width || h !== self.height) {
          self.__width = w;
          self.__height = h;
          self.updateStyle({
            width: w,
            height: h
          }, cb);
        } else if (isFunction$1(cb)) {
          cb(-1);
        }
      }
    }, {
      key: "addRefreshTask",
      value: function addRefreshTask(cb) {
        var _this3 = this;

        var taskUp = this.taskUp,
            isDestroyed = this.isDestroyed;

        if (isDestroyed) {
          return;
        } // 第一个添加延迟侦听，后续放队列等待一并执行


        if (!taskUp.length) {
          var clone;
          frame.nextFrame({
            __before: function __before(diff) {
              if (_this3.isDestroyed) {
                return;
              }

              clone = taskUp.splice(0); // 前置一般是动画计算此帧样式应用，然后刷新后出发frame事件，图片加载等同

              if (clone.length) {
                clone.forEach(function (item, i) {
                  if (isObject(item) && isFunction$1(item.__before)) {
                    item.__before(diff);
                  }
                });
              }
            },
            __after: function __after(diff) {
              if (_this3.isDestroyed) {
                return;
              }

              clone.forEach(function (item) {
                if (isObject(item) && isFunction$1(item.__after)) {
                  item.__after(diff);
                } else if (isFunction$1(item)) {
                  item(diff);
                }
              });
            }
          });

          this.__frameHook();
        }

        if (taskUp.indexOf(cb) === -1) {
          taskUp.push(cb);
        }
      } // addForceRefreshTask(cb) {
      //   this.__hasRootUpdate = true;
      //   this.addRefreshTask(cb);
      // }

    }, {
      key: "delRefreshTask",
      value: function delRefreshTask(cb) {
        if (!cb) {
          return;
        }

        var taskUp = this.taskUp;

        for (var i = 0, len = taskUp.length; i < len; i++) {
          if (taskUp[i] === cb) {
            taskUp.splice(i, 1);
            break;
          }
        }
      }
    }, {
      key: "getTargetAtPoint",
      value: function getTargetAtPoint(x, y, includeIgnore) {
        function scan(vd, x, y, path, zPath) {
          var __sx1 = vd.__sx1,
              __sy1 = vd.__sy1,
              offsetWidth = vd.offsetWidth,
              offsetHeight = vd.offsetHeight,
              matrixEvent = vd.matrixEvent,
              children = vd.children,
              zIndexChildren = vd.zIndexChildren,
              _vd$computedStyle = vd.computedStyle,
              display = _vd$computedStyle[DISPLAY],
              pointerEvents = _vd$computedStyle[POINTER_EVENTS];

          if (!includeIgnore && display === 'none') {
            return;
          }

          if (Array.isArray(zIndexChildren)) {
            for (var i = 0, len = children.length; i < len; i++) {
              children[i].__index__ = i;
            }

            for (var _i = zIndexChildren.length - 1; _i >= 0; _i--) {
              var item = zIndexChildren[_i];

              if (item instanceof karas.Text) {
                continue;
              }

              var path2 = path.slice();
              path2.push(item.__index__);
              var zPath2 = zPath.slice();
              zPath2.push(_i);
              var res = scan(item, x, y, path2, zPath2);

              if (res) {
                return res;
              }
            }
          }

          if (!includeIgnore && pointerEvents === 'none') {
            return;
          }

          var inThis = geom$1.pointInQuadrilateral(x, y, __sx1, __sy1, __sx1 + offsetWidth, __sy1, __sx1 + offsetWidth, __sy1 + offsetHeight, __sx1, __sy1 + offsetHeight, matrixEvent);

          if (inThis) {
            return {
              target: vd,
              path: path,
              zPath: zPath
            };
          }
        }

        return scan(this, x, y, [], []);
      }
      /**
       * 每次刷新前检查root节点的样式，有些固定的修改无效，有些继承的作为根初始化
       * @param renderMode
       * @param width
       * @param height
       * @private
       */

    }, {
      key: "__checkRoot",
      value: function __checkRoot(renderMode, width, height) {
        var dom = this.dom,
            currentStyle = this.currentStyle,
            computedStyle = this.computedStyle; // canvas/svg作为根节点一定是block或flex，不会是inline

        if (['flex', 'block'].indexOf(currentStyle[DISPLAY]) === -1) {
          computedStyle[DISPLAY] = currentStyle[DISPLAY] = 'block';
        } // 同理position不能为absolute


        if (currentStyle[POSITION] === 'absolute') {
          computedStyle[POSITION] = currentStyle[POSITION] = 'static';
        } // 根节点满宽高


        currentStyle[WIDTH] = {
          v: width,
          u: PX
        };
        currentStyle[HEIGHT] = {
          v: height,
          u: PX
        };
        computedStyle[WIDTH] = width;
        computedStyle[HEIGHT] = height; // 可能调用resize()导致变更，要重设，canvas无论离屏与否都可使用直接赋值，svg则按dom属性api

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          if (dom.width !== width) {
            dom.width = width;
          }

          if (dom.height !== height) {
            dom.height = height;
          }
        } else if (renderMode === mode.SVG) {
          dom.setAttribute('width', width);
          dom.setAttribute('height', height);
        }
      }
      /**
       * 添加更新，分析repaint/reflow和上下影响，异步刷新
       */

    }, {
      key: "__addUpdate",
      value: function __addUpdate(node, o) {
        if (node instanceof Component) {
          node = node.shadowRoot;
        }

        var keys = o.keys,
            focus = o.focus,
            addDom = o.addDom,
            removeDom = o.removeDom;
        var _node = node,
            computedStyle = _node.computedStyle,
            currentStyle = _node.currentStyle,
            cacheStyle = _node.cacheStyle,
            __cacheProps = _node.__cacheProps,
            __isMask = _node.__isMask,
            __domParent = _node.__domParent;
        var hasZ, hasVisibility, hasColor, hasDisplay, hasTsColor, hasTsWidth, hasTsOver;
        var lv = focus || NONE; // 清空对应改变的cacheStyle

        if (keys) {
          for (var i = 0, len = keys.length; i < len; i++) {
            var k = keys[i];

            if (node instanceof Geom && isGeom(node.tagName, k)) {
              lv |= REPAINT;
              __cacheProps[k] = undefined;
            } else {
              // repaint置空，如果reflow会重新生成空的
              cacheStyle[k] = undefined; // TRBL变化只对relative/absolute起作用，其它忽视

              if ([TOP, RIGHT, BOTTOM, LEFT].indexOf(k) > -1 && ['relative', 'absolute'].indexOf(computedStyle[POSITION]) === -1) {
                continue;
              } // 细化等级


              lv |= getLevel(k);

              if (k === DISPLAY) {
                hasDisplay = true;
              } else if (k === Z_INDEX) {
                hasZ = node !== this && ['relative', 'absolute'].indexOf(computedStyle[POSITION]) > -1;
              } else if (k === VISIBILITY) {
                hasVisibility = true;
              } else if (k === COLOR) {
                hasColor = true;
              } else if (k === TEXT_STROKE_COLOR) {
                hasTsColor = true;
              } else if (k === TEXT_STROKE_WIDTH) {
                hasTsWidth = true;
              } else if (k === TEXT_STROKE_OVER) {
                hasTsOver = true;
              }
            }
          }
        } // 没有变化，add/remove强制focus
        // 本身节点为none，变更无效，此时没有display变化，add/remove在操作时已经判断不会进入


        if (lv === NONE || computedStyle[DISPLAY] === 'none' && !hasDisplay) {
          if (isFunction$1(o.cb)) {
            o.cb();
          }

          return;
        } // transform变化清空重算，比较特殊，MATRIX的cache需手动清理


        if (contain(lv, TF)) {
          cacheStyle[MATRIX] = computedStyle[TRANSFORM] = undefined;
        } // mask需清除遮罩对象的缓存


        if (__isMask) {
          var prev = node.__prev;

          while (prev && prev.__isMask) {
            prev = prev.__prev;
          }

          if (prev && prev.__cacheMask) {
            prev.__cacheMask.release();

            prev.__refreshLevel |= CACHE;
          }
        }

        var isRp = isRepaint(lv);

        if (isRp) {
          // dom在>=REPAINT时total失效，svg的Geom比较特殊
          var need = lv >= REPAINT;

          if (need) {
            if (node.__cache) {
              node.__cache.release();
            }

            node.__calStyle(lv, currentStyle, computedStyle, cacheStyle);

            node.__calPerspective(currentStyle, computedStyle, cacheStyle);
          } // < REPAINT特殊的优化computedStyle计算
          else {
            if (contain(lv, PPT)) {
              node.__calPerspective(currentStyle, computedStyle, cacheStyle);
            }

            if (contain(lv, TRANSFORM_ALL)) {
              node.__calMatrix(lv, currentStyle, computedStyle, cacheStyle);
            }

            if (contain(lv, OP)) {
              computedStyle[OPACITY] = currentStyle[OPACITY];
            }

            if (contain(lv, FT)) {
              node.__calFilter(currentStyle, computedStyle, cacheStyle);
            }

            if (contain(lv, MBM)) {
              computedStyle[MIX_BLEND_MODE] = currentStyle[MIX_BLEND_MODE];
            }
          } // 影响子继承REPAINT的变化，如果被cache住需要清除


          if (hasVisibility || hasColor || hasTsColor || hasTsWidth || hasTsOver) {
            for (var __structs = this.__structs, __struct = node.__struct, _i2 = __structs.indexOf(__struct) + 1, _len = _i2 + (__struct.total || 0); _i2 < _len; _i2++) {
              var _structs$_i = __structs[_i2],
                  _node2 = _structs$_i.node,
                  total = _structs$_i.total; // text的style指向parent，不用管

              if (_node2 instanceof Text) {
                continue;
              }

              var _currentStyle = _node2.__currentStyle,
                  _cacheStyle = _node2.__cacheStyle;

              var _need = void 0;

              if (hasVisibility && _currentStyle[VISIBILITY].u === INHERIT) {
                _need = true;
                _cacheStyle[VISIBILITY] = undefined;
              } else if (hasColor && _currentStyle[COLOR].u === INHERIT) {
                _need = true;
                _cacheStyle[COLOR] = undefined;
              } else if (hasTsColor && _currentStyle[TEXT_STROKE_COLOR].u === INHERIT) {
                _need = true;
                _cacheStyle[TEXT_STROKE_COLOR] = undefined;
              } else if (hasTsWidth && _currentStyle[TEXT_STROKE_WIDTH].u === INHERIT) {
                _need = true;
                _cacheStyle[TEXT_STROKE_WIDTH] = undefined;
              } else if (hasTsOver && _currentStyle[TEXT_STROKE_OVER].u === INHERIT) {
                _need = true;
                _cacheStyle[TEXT_STROKE_OVER] = undefined;
              }

              if (_need) {
                _node2.__refreshLevel |= REPAINT;

                _node2.clearCache();

                _node2.__calStyle(REPAINT, _currentStyle, _node2.__computedStyle, _cacheStyle);
              } // 不为inherit此子树可跳过，因为不影响
              else {
                _i2 += total || 0;
              }
            }
          } // perspective也特殊只清空total的cache，和>=REPAINT清空total共用，TODO:优化判断ppt


          if (need || contain(lv, PPT)) {
            if (node.__cacheTotal) {
              node.__cacheTotal.release();
            }

            if (node.__cacheMask) {
              node.__cacheMask.release();
            }

            if (node.__cacheOverflow) {
              node.__cacheOverflow.release();
            }
          } // 特殊的filter清除cache


          if ((need || contain(lv, FT)) && node.__cacheFilter) {
            node.__cacheFilter.release();
          } // 向上清除cache汇总缓存信息，过程中可能会出现重复，根据refreshLevel判断，reflow已经自己清过了


          var p = __domParent;

          while (p) {
            if (contain(p.__refreshLevel, CACHE | REPAINT | REFLOW)) {
              break;
            }

            p.__refreshLevel |= CACHE;

            if (p.__cacheTotal) {
              p.__cacheTotal.release();
            }

            if (p.__cacheFilter) {
              p.__cacheFilter.release();
            }

            if (p.__cacheMask) {
              p.__cacheMask.release();
            }

            if (p.__cacheOverflow) {
              p.__cacheOverflow.release();
            }

            p = p.__domParent;
          } // 清除parent的zIndexChildren缓存，强制所有孩子重新渲染


          if (hasZ && __domParent) {
            __domParent.__zIndexChildren = null;

            __domParent.__updateStruct();

            if (this.renderMode === mode.SVG) {
              node.__cacheTotal.release();

              reflow.clearSvgCache(__domParent);
            }
          }
        } else {
          var top = reflow.checkTop(this, node, addDom, removeDom);

          if (top === this) {
            this.__reLayout();

            if (removeDom) {
              var temp = node;

              while (temp.isShadowRoot) {
                temp = temp.__host;

                temp.__destroy();
              }
            }
          } // 布局影响next的所有节点，重新layout的w/h数据使用之前parent暂存的，x使用parent，y使用prev或者parent的
          else {
            reflow.checkNext(this, top, node, hasZ, addDom, removeDom);
          }
        }

        node.__refreshLevel |= lv;

        if (addDom || removeDom) {
          this.__rlv |= REBUILD;
        } else {
          this.__rlv |= lv;
        }

        if (o.cb && !isFunction$1(o.cb)) {
          o.cb = null;
        }

        this.__frameRefresh(o.cb);
      } // 异步进行root刷新操作，多次调用缓存结果，刷新成功后回调

    }, {
      key: "__frameRefresh",
      value: function __frameRefresh(cb) {
        var _this4 = this;

        if (!this.__task.length) {
          frame.nextFrame(function () {});

          frame.__rootTask.push(function () {
            // 需要先获得累积的刷新回调再刷新，防止refresh触发事件中再次调用刷新
            var list = _this4.__task.splice(0);

            _this4.refresh();

            list.forEach(function (item) {
              item && item();
            });
          });
        }

        this.__task.push(cb);
      }
    }, {
      key: "__clear",
      value: function __clear(ctx, renderMode) {
        if (renderMode === mode.CANVAS) {
          // 可能会调整宽高，所以每次清除用最大值
          this.__mw = Math.max(this.__mw, this.width);
          this.__mh = Math.max(this.__mh, this.height); // 清除前得恢复默认matrix，防止每次布局改变了属性

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.clearRect(0, 0, this.__mw, this.__mh);
        } else if (renderMode === mode.WEBGL) {
          ctx.clearColor(0, 0, 0, 0);
          ctx.clear(ctx.COLOR_BUFFER_BIT);
        }
      }
    }, {
      key: "dom",
      get: function get() {
        return this.__dom;
      }
    }, {
      key: "uuid",
      get: function get() {
        return this.__uuid;
      }
    }, {
      key: "renderMode",
      get: function get() {
        return this.__renderMode;
      }
    }, {
      key: "ctx",
      get: function get() {
        return this.__ctx;
      }
    }, {
      key: "defs",
      get: function get() {
        return this.__defs;
      }
    }, {
      key: "taskUp",
      get: function get() {
        return this.__taskUp;
      }
    }, {
      key: "ref",
      get: function get() {
        return this.__ref;
      }
    }, {
      key: "animateController",
      get: function get() {
        return this.__animateController;
      }
    }, {
      key: "texCache",
      get: function get() {
        return this.__texCache;
      }
    }]);

    return Root;
  }(Dom);

  var STROKE_WIDTH$5 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$6 = util.isNil;

  function reBuild(target, origin, base, isMulti) {
    if (isMulti) {
      return target.map(function (item) {
        return origin + item * base;
      });
    } else {
      return origin + target * base;
    }
  }

  function reBuildC(target, originX, originY, width, height, isMulti) {
    if (isMulti) {
      if (target) {
        return target.map(function (item) {
          return reBuildC(item, originX, originY, width, height);
        });
      }
    } else {
      if (target && target.length >= 2) {
        return [originX + target[0] * width, originY + target[1] * height];
      }
    }

    return [];
  }

  function curveNum(controlA, controlB) {
    var num = 0;

    if (controlA && controlA.length >= 2) {
      num++;
    }

    if (controlB && controlB.length >= 2) {
      num += 2;
    }

    return num;
  }

  function getNewPoint(x1, y1, x2, y2, controlA, controlB, num) {
    var start = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
    var end = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;

    if (start === 0 && end === 1) {
      return [x1, y1, x2, y2, controlA, controlB];
    }

    if (start === end) {
      return [];
    }

    if (start > end) {
      var _ref = [end, start];
      start = _ref[0];
      end = _ref[1];
    }

    start = Math.max(0, start);
    end = Math.min(1, end);

    if (num === 3) {
      var _bezier$sliceBezier2B = bezier$1.sliceBezier2Both([[x1, y1], controlA, controlB, [x2, y2]], start, end);

      var _bezier$sliceBezier2B2 = _slicedToArray(_bezier$sliceBezier2B, 4);

      var _bezier$sliceBezier2B3 = _slicedToArray(_bezier$sliceBezier2B2[0], 2);

      x1 = _bezier$sliceBezier2B3[0];
      y1 = _bezier$sliceBezier2B3[1];
      controlA = _bezier$sliceBezier2B2[1];
      controlB = _bezier$sliceBezier2B2[2];

      var _bezier$sliceBezier2B4 = _slicedToArray(_bezier$sliceBezier2B2[3], 2);

      x2 = _bezier$sliceBezier2B4[0];
      y2 = _bezier$sliceBezier2B4[1];
    } else if (num === 2) {
      var _bezier$sliceBezier2B5 = bezier$1.sliceBezier2Both([[x1, y1], controlB, [x2, y2]], start, end);

      var _bezier$sliceBezier2B6 = _slicedToArray(_bezier$sliceBezier2B5, 3);

      var _bezier$sliceBezier2B7 = _slicedToArray(_bezier$sliceBezier2B6[0], 2);

      x1 = _bezier$sliceBezier2B7[0];
      y1 = _bezier$sliceBezier2B7[1];
      controlB = _bezier$sliceBezier2B6[1];

      var _bezier$sliceBezier2B8 = _slicedToArray(_bezier$sliceBezier2B6[2], 2);

      x2 = _bezier$sliceBezier2B8[0];
      y2 = _bezier$sliceBezier2B8[1];
    } else if (num === 1) {
      var _bezier$sliceBezier2B9 = bezier$1.sliceBezier2Both([[x1, y1], controlA, [x2, y2]], start, end);

      var _bezier$sliceBezier2B10 = _slicedToArray(_bezier$sliceBezier2B9, 3);

      var _bezier$sliceBezier2B11 = _slicedToArray(_bezier$sliceBezier2B10[0], 2);

      x1 = _bezier$sliceBezier2B11[0];
      y1 = _bezier$sliceBezier2B11[1];
      controlA = _bezier$sliceBezier2B10[1];

      var _bezier$sliceBezier2B12 = _slicedToArray(_bezier$sliceBezier2B10[2], 2);

      x2 = _bezier$sliceBezier2B12[0];
      y2 = _bezier$sliceBezier2B12[1];
    } else {
      var a = x2 - x1;
      var b = y2 - y1;
      x1 += a * start;
      y1 += b * start;
      x2 += a * (1 - end);
      y2 += b * (1 - end);
    }

    return [x1, y1, x2, y2, controlA, controlB];
  }

  var Line = /*#__PURE__*/function (_Geom) {
    _inherits(Line, _Geom);

    function Line(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // x1,y1和x2,y2表明线段的首尾坐标，control表明控制点坐标

      if (_this.isMulti) {
        _this.__x1 = [0];
        _this.__y1 = [0];
        _this.__x2 = [1];
        _this.__y2 = [1];
        _this.__controlA = [[]];
        _this.__controlB = [[]];
        _this.__start = [0];
        _this.__end = [1];

        if (Array.isArray(props.x1)) {
          _this.__x1 = props.x1.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$6(props.x1)) {
          _this.__x1 = [parseFloat(props.x1) || 0];
        }

        if (Array.isArray(props.y1)) {
          _this.__y1 = props.y1.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$6(props.y1)) {
          _this.__y1 = [parseFloat(props.y1) || 0];
        }

        if (Array.isArray(props.x2)) {
          _this.__x2 = props.x2.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$6(props.x2)) {
          _this.__x2 = [parseFloat(props.x2) || 0];
        }

        if (Array.isArray(props.y2)) {
          _this.__y2 = props.y2.map(function (i) {
            return parseFloat(i) || 0;
          });
        } else if (!isNil$6(props.y2)) {
          _this.__y2 = [parseFloat(props.y2) || 0];
        }

        if (Array.isArray(props.controlA)) {
          _this.__controlA = props.controlA.map(function (item) {
            if (Array.isArray(item)) {
              return item;
            }

            return [];
          });
        }

        if (Array.isArray(props.controlB)) {
          _this.__controlB = props.controlB.map(function (item) {
            if (Array.isArray(item)) {
              return item;
            }

            return [];
          });
        }

        if (Array.isArray(props.start)) {
          _this.__start = props.start.map(function (i) {
            return parseFloat(i) || 0;
          });

          for (var i = _this.__start.length; i < _this.__x1.length; i++) {
            _this.__start.push(0);
          }
        } else if (!isNil$6(props.start)) {
          var v = parseFloat(props.start) || 0;
          _this.__start = _this.__x1.map(function () {
            return v;
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            var v = parseFloat(i);

            if (isNaN(v)) {
              v = 1;
            }

            return v;
          });

          for (var _i = _this.__end.length; _i < _this.__x1.length; _i++) {
            _this.__end.push(1);
          }
        } else if (!isNil$6(props.end)) {
          var _v = parseFloat(props.end);

          if (isNaN(_v)) {
            _v = 1;
          }

          _this.__end = _this.__x1.map(function () {
            return _v;
          });
        }
      } else {
        _this.__x1 = _this.__y1 = _this.__start = 0;
        _this.__x2 = _this.__y2 = _this.__end = 1;
        _this.__controlA = [];
        _this.__controlB = [];

        if (!isNil$6(props.x1)) {
          _this.__x1 = parseFloat(props.x1) || 0;
        }

        if (!isNil$6(props.y1)) {
          _this.__y1 = parseFloat(props.y1) || 0;
        }

        if (!isNil$6(props.x2)) {
          _this.__x2 = parseFloat(props.x2) || 0;
        }

        if (!isNil$6(props.y2)) {
          _this.__y2 = parseFloat(props.y2) || 0;
        }

        if (!isNil$6(props.start)) {
          _this.__start = parseFloat(props.start) || 0;
        }

        if (!isNil$6(props.end)) {
          var _v2 = parseFloat(props.end);

          if (isNaN(_v2)) {
            _v2 = 1;
          }

          _this.__end = _v2;
        }

        if (Array.isArray(props.controlA)) {
          _this.__controlA = props.controlA;
        }

        if (Array.isArray(props.controlB)) {
          _this.__controlB = props.controlB;
        }
      }

      return _this;
    }

    _createClass(Line, [{
      key: "buildCache",
      value: function buildCache(originX, originY, focus) {
        var _this2 = this;

        var width = this.width,
            height = this.height,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;
        ['x1', 'x2'].forEach(function (k) {
          if (isNil$6(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuild(_this2[k], originX, width, isMulti);
          }
        });
        ['y1', 'y2'].forEach(function (k) {
          if (isNil$6(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuild(_this2[k], originY, height, isMulti);
          }
        });
        ['controlA', 'controlB'].forEach(function (k) {
          if (isNil$6(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = reBuildC(_this2[k], originX, originY, width, height, isMulti);
          }
        });
        ['start', 'end'].forEach(function (k) {
          if (isNil$6(__cacheProps[k]) || focus) {
            rebuild = true;
            __cacheProps[k] = _this2[k];
          }
        });
        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx2, dy2) {
        var _this3 = this;

        var res = _get(_getPrototypeOf(Line.prototype), "render", this).call(this, renderMode, ctx, dx2, dy2);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        var sx3 = res.sx3,
            sy3 = res.sy3,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild = this.buildCache(sx3, sy3);

        if (rebuild && renderMode === mode.SVG) {
          var d = '';

          if (isMulti) {
            __cacheProps.x1.forEach(function (xa, i) {
              var xb = __cacheProps.x2[i];
              var ya = __cacheProps.y1[i];
              var yb = __cacheProps.y2[i];
              var ca = __cacheProps.controlA[i];
              var cb = __cacheProps.controlB[i];
              var start = __cacheProps.start[i];
              var end = __cacheProps.end[i];
              var curve = curveNum(ca, cb);

              if (start !== 0 || end !== 1) {
                var _getNewPoint = getNewPoint(xa, ya, xb, ya, ca, cb, curve, start, end, __cacheProps.len);

                var _getNewPoint2 = _slicedToArray(_getNewPoint, 6);

                xa = _getNewPoint2[0];
                ya = _getNewPoint2[1];
                xb = _getNewPoint2[2];
                ya = _getNewPoint2[3];
                ca = _getNewPoint2[4];
                cb = _getNewPoint2[5];
              }

              d += painter.svgLine(xa, ya, xb, yb, ca, cb, curve);
            });
          } else {
            var curve = curveNum(__cacheProps.controlA, __cacheProps.controlB);
            var x1 = __cacheProps.x1,
                y1 = __cacheProps.y1,
                x2 = __cacheProps.x2,
                y2 = __cacheProps.y2,
                controlA = __cacheProps.controlA,
                controlB = __cacheProps.controlB,
                start = __cacheProps.start,
                end = __cacheProps.end;

            if (start !== 0 || end !== 1) {
              var _getNewPoint3 = getNewPoint(x1, y1, x2, y2, controlA, controlB, curve, start, end, __cacheProps.len);

              var _getNewPoint4 = _slicedToArray(_getNewPoint3, 6);

              x1 = _getNewPoint4[0];
              y1 = _getNewPoint4[1];
              x2 = _getNewPoint4[2];
              y2 = _getNewPoint4[3];
              controlA = _getNewPoint4[4];
              controlB = _getNewPoint4[5];
            }

            d = painter.svgLine(x1, y1, x2, y2, controlA, controlB, curve);
          }

          __cacheProps.d = d;
        }

        if (renderMode === mode.CANVAS || renderMode === mode.WEBGL) {
          strokes.forEach(function (stroke, i) {
            var strokeWidth = strokeWidths[i];
            var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);

            if (strokeWidth > 0 && stroke !== 'none') {
              _this3.__preSetCanvas(renderMode, ctx, {
                stroke: stroke,
                strokeWidth: strokeWidth,
                strokeDasharray: strokeDasharrays[i],
                strokeLinecap: strokeLinecaps[i],
                strokeLinejoin: strokeLinejoins[i],
                strokeMiterlimit: strokeMiterlimits[i]
              });

              if (isStrokeRE) {
                ctx.strokeStyle = stroke.v[0];
              }

              ctx.beginPath();

              if (isMulti) {
                __cacheProps.x1.forEach(function (xa, i) {
                  var xb = __cacheProps.x2[i];
                  var ya = __cacheProps.y1[i];
                  var yb = __cacheProps.y2[i];
                  var ca = __cacheProps.controlA[i];
                  var cb = __cacheProps.controlB[i];
                  var start = __cacheProps.start[i];
                  var end = __cacheProps.end[i];
                  var curve = curveNum(ca, cb);

                  if (start !== 0 || end !== 1) {
                    var _getNewPoint5 = getNewPoint(xa, ya, xb, ya, ca, cb, curve, start, end, __cacheProps.len);

                    var _getNewPoint6 = _slicedToArray(_getNewPoint5, 6);

                    xa = _getNewPoint6[0];
                    ya = _getNewPoint6[1];
                    xb = _getNewPoint6[2];
                    ya = _getNewPoint6[3];
                    ca = _getNewPoint6[4];
                    cb = _getNewPoint6[5];
                  }

                  painter.canvasLine(ctx, xa, ya, xb, yb, ca, cb, curve, dx, dy);
                });
              } else {
                var _curve = curveNum(__cacheProps.controlA, __cacheProps.controlB);

                var _x = __cacheProps.x1,
                    _y = __cacheProps.y1,
                    _x2 = __cacheProps.x2,
                    _y2 = __cacheProps.y2,
                    _controlA = __cacheProps.controlA,
                    _controlB = __cacheProps.controlB,
                    _start = __cacheProps.start,
                    _end = __cacheProps.end;

                if (_start !== 0 || _end !== 1) {
                  var _getNewPoint7 = getNewPoint(_x, _y, _x2, _y2, _controlA, _controlB, _curve, _start, _end, __cacheProps.len);

                  var _getNewPoint8 = _slicedToArray(_getNewPoint7, 6);

                  _x = _getNewPoint8[0];
                  _y = _getNewPoint8[1];
                  _x2 = _getNewPoint8[2];
                  _y2 = _getNewPoint8[3];
                  _controlA = _getNewPoint8[4];
                  _controlB = _getNewPoint8[5];
                }

                painter.canvasLine(ctx, _x, _y, _x2, _y2, _controlA, _controlB, _curve, dx, dy);
              }

              ctx.stroke();
              ctx.closePath();
            }
          });
        } else if (renderMode === mode.SVG) {
          strokes.forEach(function (stroke, i) {
            var strokeWidth = strokeWidths[i];
            var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);
            var props = [['d', __cacheProps.d], ['fill', 'none'], ['stroke', isStrokeRE ? stroke.v[0] : stroke.v || stroke], ['stroke-width', strokeWidth]];

            _this3.__propsStrokeStyle(props, strokeDasharrayStrs[i], strokeLinecaps[i], strokeLinejoins[i], strokeMiterlimits[i]);

            _this3.addGeom('path', props);
          });
        }

        return res;
      }
    }, {
      key: "x1",
      get: function get() {
        return this.getProps('x1');
      }
    }, {
      key: "y1",
      get: function get() {
        return this.getProps('y1');
      }
    }, {
      key: "x2",
      get: function get() {
        return this.getProps('x2');
      }
    }, {
      key: "y2",
      get: function get() {
        return this.getProps('y2');
      }
    }, {
      key: "controlA",
      get: function get() {
        return this.getProps('controlA');
      }
    }, {
      key: "controlB",
      get: function get() {
        return this.getProps('controlB');
      }
    }, {
      key: "start",
      get: function get() {
        return this.getProps('start');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "bbox",
      get: function get() {
        var isMulti = this.isMulti,
            __cacheProps = this.__cacheProps,
            originX = this.__sx3,
            originY = this.__sy3,
            strokeWidth = this.computedStyle[STROKE_WIDTH$5];
        this.buildCache(originX, originY);
        var x1 = __cacheProps.x1,
            y1 = __cacheProps.y1,
            x2 = __cacheProps.x2,
            y2 = __cacheProps.y2,
            controlA = __cacheProps.controlA,
            controlB = __cacheProps.controlB;

        var bbox = _get(_getPrototypeOf(Line.prototype), "bbox", this);

        var half = 0;
        strokeWidth.forEach(function (item) {
          half = Math.max(half, item);
        });
        half = Math.ceil(half * 0.5) + 1;

        if (!isMulti) {
          x1 = [x1];
          x2 = [x2];
          y1 = [y1];
          y2 = [y2];
          controlA = [controlA];
          controlB = [controlB];
        }

        x1.forEach(function (xa, i) {
          var ya = y1[i];
          var xb = x2[i];
          var yb = y2[i];
          var ca = controlA[i];
          var cb = controlB[i];

          if ((isNil$6(ca) || ca.length < 2) && (isNil$6(cb) || cb.length < 2)) {
            bbox[0] = Math.min(bbox[0], xa - half);
            bbox[0] = Math.min(bbox[0], xb - half);
            bbox[1] = Math.min(bbox[1], ya - half);
            bbox[1] = Math.min(bbox[1], yb - half);
            bbox[2] = Math.max(bbox[2], xa + half);
            bbox[2] = Math.max(bbox[2], xb + half);
            bbox[3] = Math.max(bbox[3], ya + half);
            bbox[3] = Math.max(bbox[3], yb + half);
          } else if (isNil$6(ca) || ca.length < 2) {
            var bezierBox = bezier$1.bboxBezier(xa, ya, cb[0], cb[1], xb, yb);
            bbox[0] = Math.min(bbox[0], bezierBox[0] - half);
            bbox[0] = Math.min(bbox[0], bezierBox[2] - half);
            bbox[1] = Math.min(bbox[1], bezierBox[1] - half);
            bbox[1] = Math.min(bbox[1], bezierBox[3] - half);
            bbox[2] = Math.max(bbox[2], bezierBox[0] + half);
            bbox[2] = Math.max(bbox[2], bezierBox[2] + half);
            bbox[3] = Math.max(bbox[3], bezierBox[1] + half);
            bbox[3] = Math.max(bbox[3], bezierBox[3] + half);
          } else if (isNil$6(cb) || cb.length < 2) {
            var _bezierBox = bezier$1.bboxBezier(xa, ya, ca[0], ca[1], xb, yb);

            bbox[0] = Math.min(bbox[0], _bezierBox[0] - half);
            bbox[0] = Math.min(bbox[0], _bezierBox[2] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox[1] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox[3] - half);
            bbox[2] = Math.max(bbox[2], _bezierBox[0] + half);
            bbox[2] = Math.max(bbox[2], _bezierBox[2] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox[1] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox[3] + half);
          } else {
            var _bezierBox2 = bezier$1.bboxBezier(xa, ya, ca[0], ca[1], cb[0], cb[1], xb, yb);

            bbox[0] = Math.min(bbox[0], _bezierBox2[0] - half);
            bbox[0] = Math.min(bbox[0], _bezierBox2[2] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox2[1] - half);
            bbox[1] = Math.min(bbox[1], _bezierBox2[3] - half);
            bbox[2] = Math.max(bbox[2], _bezierBox2[0] + half);
            bbox[2] = Math.max(bbox[2], _bezierBox2[2] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox2[1] + half);
            bbox[3] = Math.max(bbox[3], _bezierBox2[3] + half);
          }
        });
        return bbox;
      }
    }]);

    return Line;
  }(Geom);

  var intersect = bo.intersect,
      union = bo.union,
      subtract = bo.subtract,
      subtract2 = bo.subtract2,
      xor = bo.xor,
      chain = bo.chain;
  var STROKE_WIDTH$4 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$5 = util.isNil;

  function concatPointAndControl(point, control) {
    if (Array.isArray(control) && (control.length === 2 || control.length === 4) && Array.isArray(point) && point.length === 2) {
      return control.concat(point);
    }

    return point;
  }

  function getLength(list, isMulti) {
    var res = [];
    var total = 0;
    var increase = [];

    if (isMulti) {
      total = [];
      list.forEach(function (list) {
        var temp = getLength(list);
        res.push(temp.list);
        total.push(temp.total);
        increase.push([0].concat(temp.increase));
      });
    } else if (Array.isArray(list)) {
      total = 0;
      increase.push(0);
      var start = 0;

      for (var i = 0, len = list.length; i < len; i++) {
        var item = list[i];

        if (Array.isArray(item)) {
          start = i;
          break;
        }
      }

      var prev = list[start];

      for (var _i = start + 1, _len = list.length; _i < _len; _i++) {
        var _item = list[_i];

        if (!Array.isArray(_item)) {
          continue;
        }

        if (_item.length === 2) {
          var a = Math.abs(_item[0] - prev[0]);
          var b = Math.abs(_item[1] - prev[1]);
          var c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
          res.push(c);
          total += c;
          increase.push(total);
          prev = _item;
        } else if (_item.length === 4) {
          var _c = bezier$1.bezierLength([prev, [_item[0], _item[1]], [_item[2], _item[3]]]);

          res.push(_c);
          total += _c;
          increase.push(total);
          prev = [_item[2], _item[3]];
        } else if (_item.length === 6) {
          var _c2 = bezier$1.bezierLength([prev, [_item[0], _item[1]], [_item[2], _item[3]], [_item[4], _item[5]]]);

          res.push(_c2);
          total += _c2;
          increase.push(total);
          prev = [_item[4], _item[5]];
        }
      }
    }

    return {
      list: res,
      total: total,
      increase: increase
    };
  }

  function getIndex(list, t, i, j) {
    if (i === j) {
      if (list[i] > t) {
        return i - 1;
      }

      return i;
    }

    var middle = i + (j - i >> 1);

    if (list[middle] === t) {
      return middle;
    } else if (list[middle] > t) {
      return getIndex(list, t, i, Math.max(middle - 1, i));
    } else {
      return getIndex(list, t, Math.min(middle + 1, j), j);
    }
  }

  function getNewList(list, len) {
    var start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    if (start === 0 && end === 1) {
      return list;
    }

    if (start === end) {
      return [];
    }

    if (start > end) {
      var _ref = [end, start];
      start = _ref[0];
      end = _ref[1];
    } // start和end只能相差<=1，如果>1则校正


    while (end - start > 1) {
      end--;
    } // 将start和end统一至最接近0的正值


    while (end < 0 || start < 0) {
      end++;
      start++;
    }

    while (end >= 1 && start >= 1) {
      end--;
      start--;
    } // clone出原本顶点列表，防止干扰


    var length = list.length;
    list = util.clone(list);
    var res = [];
    var start2 = start > 1 ? start - 1 : start;
    var end2 = end > 1 ? end - 1 : end;
    var i = getIndex(len.increase, start2 * len.total, 0, length - 1);
    var j = getIndex(len.increase, end2 * len.total, 0, length - 1); // start<0或者end>1或者普通情况，一共3种，start和end不可能同时超限

    var isStartLt0 = start < 0;
    var isEndGt1 = end > 1;
    end2 *= len.total;
    var prePercent = 1;
    var endPoint;

    if (end2 > len.increase[j]) {
      var prev = list[j].slice(list[j].length - 2); // 最后2个点是x,y，前面是control

      var current = list[j + 1];
      var l = len.list[j];
      var diff = end2 - len.increase[j];
      var t = diff / l;
      prePercent = t;

      if (current.length === 2) {
        var a = current[0] - prev[0];
        var b = current[1] - prev[1];

        if (isEndGt1) {
          endPoint = [prev[0] + t * a, prev[1] + t * b];
        } else {
          t = 1 - t;
          endPoint = [current[0] - t * a, current[1] - t * b];
        }
      } else if (current.length === 4) {
        var r = bezier$1.sliceBezier([prev, [current[0], current[1]], [current[2], current[3]]], t);
        endPoint = [r[1][0], r[1][1], r[2][0], r[2][1]];
      } else if (current.length === 6) {
        var _r = bezier$1.sliceBezier([prev, [current[0], current[1]], [current[2], current[3]], [current[4], current[5]]], t);

        endPoint = [_r[1][0], _r[1][1], _r[2][0], _r[2][1], _r[3][0], _r[3][1]];
      }
    }

    start2 *= len.total;

    if (start2 > len.increase[i]) {
      var _current;

      var _prev = list[i].slice(list[i].length - 2);

      var _l = len.list[i]; // 同一条线段时如果有end裁剪，会影响start长度，这里还要防止头尾绕了一圈的情况

      if (i === j && !isStartLt0 && !isEndGt1 && prePercent !== 1) {
        _l *= prePercent;

        if (endPoint) {
          _current = endPoint;
        }
      }

      if (!_current) {
        _current = list[i + 1];
      }

      var _diff = start2 - len.increase[i];

      var _t = _diff / _l;

      if (_current.length === 2) {
        var _a = _current[0] - _prev[0];

        var _b = _current[1] - _prev[1];

        if (isStartLt0) {
          _t = 1 - _t;
          res.push([_current[0] - _t * _a, _current[1] - _t * _b]);
        } else {
          res.push([_prev[0] + _t * _a, _prev[1] + _t * _b]);
        }

        res.push(_current);
      } else if (_current.length === 4) {
        var _r2 = bezier$1.sliceBezier([[_current[2], _current[3]], [_current[0], _current[1]], _prev], 1 - _t).reverse();

        res.push(_r2[0]);
        res.push([_r2[1][0], _r2[1][1], _r2[2][0], _r2[2][1]]); // 同一条线段上去除end冲突

        if (i === j && !isStartLt0 && !isEndGt1) {
          endPoint = null;
        }
      } else if (_current.length === 6) {
        var _r3 = bezier$1.sliceBezier([[_current[4], _current[5]], [_current[2], _current[3]], [_current[0], _current[1]], _prev], 1 - _t).reverse();

        res.push(_r3[0]);
        res.push([_r3[1][0], _r3[1][1], _r3[2][0], _r3[2][1], _current[4], _current[5]]);

        if (i === j && !isStartLt0 && !isEndGt1) {
          endPoint = null;
        }
      }
    } // start和end之间的线段，注意头尾饶了一圈的情况，以及起始点被上方考虑过了


    for (var k = i + 2; k <= j + (!isStartLt0 && !isEndGt1 ? 0 : length); k++) {
      res.push(list[k % length]);
    }

    if (endPoint) {
      res.push(endPoint);
    }

    return res;
  }

  var Polyline = /*#__PURE__*/function (_Geom) {
    _inherits(Polyline, _Geom);

    function Polyline(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 所有点的列表

      if (_this.isMulti) {
        _this.__points = [[]];
        _this.__controls = [[]];
        _this.__start = [0];
        _this.__end = [1];

        if (Array.isArray(props.start)) {
          _this.__start = props.start.map(function (i) {
            return parseFloat(i) || 0;
          });

          for (var i = _this.__start.length; i < _this.__points.length; i++) {
            _this.__start.push(0);
          }
        } else if (!isNil$5(props.start)) {
          var v = parseFloat(props.start) || 0;
          _this.__start = _this.__points.map(function () {
            return v;
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            var v = parseFloat(i);

            if (isNaN(v)) {
              v = 1;
            }

            return v;
          });

          for (var _i2 = _this.__end.length; _i2 < _this.__points.length; _i2++) {
            _this.__end.push(1);
          }
        } else if (!isNil$5(props.end)) {
          var _v = parseFloat(props.end);

          if (isNaN(_v)) {
            _v = 1;
          }

          _this.__end = _this.__points.map(function () {
            return _v;
          });
        }
      } else {
        _this.__points = []; // 控制点

        _this.__controls = [];
        _this.__start = 0;
        _this.__end = 1;

        if (!isNil$5(props.start)) {
          _this.__start = parseFloat(props.start) || 0;
        }

        if (!isNil$5(props.end)) {
          var _v2 = parseFloat(props.end);

          if (isNaN(_v2)) {
            _v2 = 1;
          }

          _this.__end = _v2;
        }
      }

      if (Array.isArray(props.controls)) {
        _this.__controls = props.controls;
      }

      if (Array.isArray(props.points)) {
        _this.__points = props.points;
      }

      if (props.booleanOperations) {
        _this.__booleanOperations = props.booleanOperations;
      }

      return _this;
    }

    _createClass(Polyline, [{
      key: "__getPoints",
      value: function __getPoints(originX, originY, width, height, points, isControl) {
        return points.map(function (item) {
          if (!Array.isArray(item)) {
            return;
          }

          var len = item.length;

          if (isControl) {
            if (len !== 0 && len !== 2 && len !== 4) {
              return;
            }
          } else {
            if (len !== 0 && len !== 2) {
              return;
            }
          }

          var res = [];

          for (var i = 0; i < len; i++) {
            if (i % 2 === 0) {
              res.push(originX + item[i] * width);
            } else {
              res.push(originY + item[i] * height);
            }
          }

          return res;
        });
      } // 供polygon覆盖，后处理booleanOperations

    }, {
      key: "__reprocessing",
      value: function __reprocessing(list, isMulti) {
        if (!isMulti || list.length < 2) {
          return list;
        }

        var bo = this.booleanOperations,
            len = list.length;

        if (!bo) {
          return list;
        }

        if (!Array.isArray(bo)) {
          var old = bo;
          bo = [bo];

          for (var i = 1; i < len - 1; i++) {
            bo.push(old);
          }
        }

        if (Array.isArray(bo) && bo.length) {
          var res = [],
              temp = list[0];

          for (var _i3 = 1; _i3 < len; _i3++) {
            var op = (bo[_i3 - 1] || '').toString().toLowerCase();
            var cur = list[_i3];

            if (['intersect', 'intersection', 'union', 'subtract', 'subtract2', 'diff', 'difference', 'xor'].indexOf(op) === -1) {
              res = res.concat(chain(temp));
              temp = cur || [];
              continue;
            }

            switch (op) {
              case 'intersect':
              case 'intersection':
                temp = intersect(temp, cur, true);
                break;

              case 'union':
                temp = union(temp, cur, true);
                break;

              case 'subtract':
              case 'diff':
              case 'difference':
                temp = subtract(temp, cur, true);
                break;

              case 'subtract2':
                temp = subtract2(temp, cur, true);
                break;

              case 'xor':
                temp = xor(temp, cur, true);
                break;
            }
          }

          return res.concat(chain(temp));
        }

        return list;
      } // 同polygon覆盖，booleanOperations改变时需刷新缓冲顶点坐标

    }, {
      key: "__needRebuildSE",
      value: function __needRebuildSE(__cacheProps) {
        if (util.isNil(__cacheProps.booleanOperations)) {
          __cacheProps.booleanOperations = true;
          return true;
        }
      }
    }, {
      key: "buildCache",
      value: function buildCache(originX, originY) {
        var _this2 = this;

        var width = this.width,
            height = this.height,
            points = this.points,
            controls = this.controls,
            start = this.start,
            end = this.end,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild, rebuildSE;

        if (isNil$5(__cacheProps.points)) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.points = points.map(function (item) {
              if (Array.isArray(item)) {
                return _this2.__getPoints(originX, originY, width, height, item);
              }
            });
          } else {
            __cacheProps.points = this.__getPoints(originX, originY, width, height, points);
          }
        }

        if (isNil$5(__cacheProps.controls)) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.controls = controls.map(function (item) {
              if (Array.isArray(item)) {
                return _this2.__getPoints(originX, originY, width, height, item, true);
              }

              return item;
            });
          } else {
            __cacheProps.controls = this.__getPoints(originX, originY, width, height, controls, true);
          }
        }

        if (isNil$5(__cacheProps.start)) {
          rebuildSE = true;
          __cacheProps.start = start;
        }

        if (isNil$5(__cacheProps.end)) {
          rebuildSE = true;
          __cacheProps.end = end;
        } // polygon会覆盖检查booleanOperations缓存


        if (this.__needRebuildSE(__cacheProps)) {
          rebuildSE = true;
        } // points/controls有变化就需要重建顶点


        if (rebuild) {
          var _points = __cacheProps.points,
              _controls = __cacheProps.controls;

          if (isMulti) {
            __cacheProps.list2 = _points.map(function (item, i) {
              var cl = _controls[i];

              if (Array.isArray(item)) {
                return item.map(function (point, j) {
                  if (j) {
                    return concatPointAndControl(point, cl && cl[j - 1]);
                  }

                  return point;
                });
              }
            });
            __cacheProps.len = getLength(__cacheProps.list2, isMulti);
          } else {
            __cacheProps.list2 = _points.map(function (point, i) {
              if (i) {
                return concatPointAndControl(point, _controls[i - 1]);
              }

              return point;
            });
            __cacheProps.len = getLength(__cacheProps.list2, isMulti);
          }
        }

        if (rebuild || rebuildSE) {
          if (isMulti) {
            __cacheProps.list = __cacheProps.list2.map(function (item, i) {
              if (Array.isArray(item)) {
                var len = __cacheProps.len;
                return getNewList(item, {
                  list: len.list[i],
                  total: len.total[i],
                  increase: len.increase[i]
                }, __cacheProps.start[i], __cacheProps.end[i]);
              }
            });
          } else {
            __cacheProps.list = getNewList(__cacheProps.list2, __cacheProps.len, __cacheProps.start, __cacheProps.end);
          } // 后处理一次，让polygon支持布尔运算


          __cacheProps.list = this.__reprocessing(__cacheProps.list, isMulti);
        }

        return rebuild || rebuildSE;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Polyline.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.buildCache(res.sx3, res.sy3);

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "points",
      get: function get() {
        return this.getProps('points');
      }
    }, {
      key: "controls",
      get: function get() {
        return this.getProps('controls');
      }
    }, {
      key: "start",
      get: function get() {
        return this.getProps('start');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__sx3,
              originY = this.__sy3,
              strokeWidth = this.computedStyle[STROKE_WIDTH$4];
          this.buildCache(originX, originY);

          var bbox = _get(_getPrototypeOf(Polyline.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var points = __cacheProps.points,
              controls = __cacheProps.controls;

          if (!isMulti) {
            points = [points];
            controls = [controls];
          }

          points.forEach(function (pointList, i) {
            if (!pointList || pointList.length < 2 || !pointList[0] || !pointList[1] || pointList[0].length < 2 || pointList[1].length < 2) {
              return;
            }

            var controlList = controls[i] || [];

            var _pointList$ = _slicedToArray(pointList[0], 2),
                xa = _pointList$[0],
                ya = _pointList$[1];

            for (var _i4 = 1, len = pointList.length; _i4 < len; _i4++) {
              var item = pointList[_i4];

              if (!item || item.length < 2) {
                continue;
              }

              var _pointList$_i = _slicedToArray(pointList[_i4], 2),
                  xb = _pointList$_i[0],
                  yb = _pointList$_i[1];

              var c = controlList[_i4 - 1];

              if (c && c.length === 4) {
                var bezierBox = bezier$1.bboxBezier(xa, ya, c[0], c[1], c[2], c[3], xb, yb);
                bbox[0] = Math.min(bbox[0], bezierBox[0] - half);
                bbox[1] = Math.min(bbox[1], bezierBox[1] - half);
                bbox[2] = Math.max(bbox[2], bezierBox[2] + half);
                bbox[3] = Math.max(bbox[3], bezierBox[3] + half);
              } else if (c && c.length === 2) {
                var _bezierBox = bezier$1.bboxBezier(xa, ya, c[0], c[1], xb, yb);

                bbox[0] = Math.min(bbox[0], _bezierBox[0] - half);
                bbox[1] = Math.min(bbox[1], _bezierBox[1] - half);
                bbox[2] = Math.max(bbox[2], _bezierBox[2] + half);
                bbox[3] = Math.max(bbox[3], _bezierBox[3] + half);
              } else {
                bbox[0] = Math.min(bbox[0], xa - half);
                bbox[1] = Math.min(bbox[1], ya - half);
                bbox[2] = Math.max(bbox[2], xa + half);
                bbox[3] = Math.max(bbox[3], ya + half);
              }

              xa = xb;
              ya = yb;
            }
          });
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }, {
      key: "booleanOperations",
      get: function get() {
        return this.getProps('booleanOperations');
      }
    }]);

    return Polyline;
  }(Geom);

  var Polygon = /*#__PURE__*/function (_Polyline) {
    _inherits(Polygon, _Polyline);

    function Polygon(tagName, props) {
      return _Polyline.call(this, tagName, props) || this;
    }

    _createClass(Polygon, [{
      key: "__getPoints",
      value: function __getPoints(originX, originY, width, height, points, isControl) {
        var res = _get(_getPrototypeOf(Polygon.prototype), "__getPoints", this).call(this, originX, originY, width, height, points, isControl);

        if (!isControl) {
          res.push(res[0]);
        }

        return res;
      }
    }]);

    return Polygon;
  }(Polyline);

  var STROKE_WIDTH$3 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$4 = util.isNil;
  var sectorPoints = geom$1.sectorPoints;

  function getR$3(v, dft) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = dft;
    }

    return v;
  }

  var Sector = /*#__PURE__*/function (_Geom) {
    _inherits(Sector, _Geom);

    function Sector(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 角度

      if (_this.isMulti) {
        _this.__begin = [0];
        _this.__end = [0];
        _this.__r = [1];

        if (Array.isArray(props.begin)) {
          _this.__begin = props.begin.map(function (i) {
            return getR$3(i, 0);
          });
        }

        if (Array.isArray(props.end)) {
          _this.__end = props.end.map(function (i) {
            return getR$3(i, 0);
          });
        }

        if (Array.isArray(props.r)) {
          _this.__r = props.r.map(function (i) {
            return getR$3(i, 1);
          });
        }

        if (Array.isArray(props.edge)) {
          _this.__edge = props.edge.map(function (i) {
            return !!i;
          });
        }

        if (Array.isArray(props.closure)) {
          _this.__closure = props.closure.map(function (i) {
            return !!i;
          });
        }
      } else {
        _this.__begin = _this.__end = 0; // 半径[0, ∞)，默认1

        _this.__r = 1; // 扇形两侧是否有边

        _this.__edge = false; // 扇形大于180°时，是否闭合两端

        _this.__closure = false;

        if (!isNil$4(props.begin)) {
          _this.__begin = getR$3(props.begin, 0);
        }

        if (!isNil$4(props.end)) {
          _this.__end = getR$3(props.end, 0);
        }

        if (!isNil$4(props.r)) {
          _this.__r = getR$3(props.r, 1);
        }

        if (!isNil$4(props.edge)) {
          _this.__edge = !!props.edge;
        }

        if (!isNil$4(props.closure)) {
          _this.__closure = !!props.closure;
        }
      }

      return _this;
    }

    _createClass(Sector, [{
      key: "buildCache",
      value: function buildCache(cx, cy, focus) {
        var width = this.width,
            begin = this.begin,
            end = this.end,
            r = this.r,
            edge = this.edge,
            closure = this.closure,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$4(__cacheProps.begin) || focus) {
          rebuild = true;
          __cacheProps.begin = (begin || 0) % 360;
        }

        if (isNil$4(__cacheProps.end) || focus) {
          rebuild = true;
          __cacheProps.end = (end || 0) % 360;
        }

        if (isNil$4(__cacheProps.r) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.r = r.map(function (r) {
              return r * width * 0.5;
            });
          } else {
            __cacheProps.r = r * width * 0.5;
          }
        }

        r = __cacheProps.r;

        if (isNil$4(__cacheProps.edge) || focus) {
          rebuild = true;
          __cacheProps.edge = edge;
        }

        if (isNil$4(__cacheProps.closure) || focus) {
          rebuild = true;
          __cacheProps.closure = closure;
        }

        if (rebuild) {
          if (isMulti) {
            __cacheProps.list = [];
            __cacheProps.sList = [];
            begin.forEach(function (begin, i) {
              var r2 = isNil$4(r[i]) ? width * 0.5 : r[i];
              var list = sectorPoints(cx, cy, r2, parseFloat(begin || 0) % 360, parseFloat(end[i] || 0) % 360);
              var sList = list.slice(0);

              if (closure[i]) {
                list.push(list[0].slice(0));

                if (edge) {
                  sList.push(sList[0].slice(0));
                }
              } else {
                list.unshift([cx, cy]);
                list.push([cx, cy]);

                if (edge) {
                  sList.unshift([cx, cy]);
                  sList.push([cx, cy]);
                }
              }

              __cacheProps.list.push(list);

              __cacheProps.sList.push(sList);
            });
          } else {
            var list = sectorPoints(cx, cy, r, parseFloat(begin || 0), parseFloat(end || 0));
            var sList = list.slice(0);

            if (closure) {
              list.push(list[0].slice(0));

              if (edge) {
                sList.push(sList[0].slice(0));
              }
            } else {
              list.unshift([cx, cy]);
              list.push([cx, cy]);

              if (edge) {
                sList.unshift([cx, cy]);
                sList.push([cx, cy]);
              }
            }

            __cacheProps.list = list;
            __cacheProps.sList = sList;
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx2, dy2) {
        var res = _get(_getPrototypeOf(Sector.prototype), "render", this).call(this, renderMode, ctx, dx2, dy2);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.buildCache(res.cx, res.cy);
        var fills = res.fill,
            fillRules = res.fillRule,
            strokes = res.stroke,
            strokeWidths = res.strokeWidth,
            strokeDasharrays = res.strokeDasharray,
            strokeDasharrayStrs = res.strokeDasharrayStr,
            strokeLinecaps = res.strokeLinecap,
            strokeLinejoins = res.strokeLinejoin,
            strokeMiterlimits = res.strokeMiterlimit,
            dx = res.dx,
            dy = res.dy;
        var _this$__cacheProps = this.__cacheProps,
            list = _this$__cacheProps.list,
            sList = _this$__cacheProps.sList,
            isMulti = this.isMulti; // 普通情况下只有1个，按普通情况走

        if (fills.length <= 1 && strokes.length <= 1) {
          var o = {
            fill: fills[0],
            fillRule: fillRules[0],
            stroke: strokes[0],
            strokeWidth: strokeWidths[0],
            strokeDasharray: strokeDasharrays[0],
            strokeDasharrayStr: strokeDasharrayStrs[0],
            strokeLinecap: strokeLinecaps[0],
            strokeLinejoin: strokeLinejoins[0],
            strokeMiterlimit: strokeMiterlimits[0],
            dx: dx,
            dy: dy
          };

          this.__renderOneSector(renderMode, ctx, isMulti, list, sList, o);
        } // 多个需要fill在下面，stroke在上面，依次循环
        else {
          for (var i = 0, len = fills.length; i < len; i++) {
            var fill = fills[i];

            if (fill) {
              var _o = {
                fill: fill,
                fillRule: fillRules[i],
                dx: dx,
                dy: dy
              };

              this.__renderOneSector(renderMode, ctx, isMulti, list, sList, _o);
            }
          }

          for (var _i = 0, _len = strokes.length; _i < _len; _i++) {
            var stroke = strokes[_i];

            if (stroke) {
              var _o2 = {
                stroke: stroke,
                strokeWidth: strokeWidths[_i],
                strokeDasharray: strokeDasharrays[_i],
                strokeDasharrayStr: strokeDasharrayStrs[_i],
                strokeLinecap: strokeLinecaps[_i],
                strokeLinejoin: strokeLinejoins[_i],
                strokeMiterlimit: strokeMiterlimits[_i],
                dx: dx,
                dy: dy
              };

              this.__renderOnePolygon(renderMode, ctx, isMulti, list, sList, _o2);
            }
          }
        }

        return res;
      }
    }, {
      key: "__renderOneSector",
      value: function __renderOneSector(renderMode, ctx, isMulti, list, sList, res) {
        var fill = res.fill,
            stroke = res.stroke,
            strokeWidth = res.strokeWidth;
        var isFillCE = fill.k === 'conic';
        var isStrokeCE = stroke.k === 'conic';
        var isFillRE = fill.k === 'radial' && Array.isArray(fill.v);
        var isStrokeRE = strokeWidth > 0 && stroke.k === 'radial' && Array.isArray(stroke.v);

        if (isFillCE || isStrokeCE) {
          if (isFillCE) {
            this.__conicGradient(renderMode, ctx, list, isMulti, res);
          } else if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          }

          if (strokeWidth > 0 && isStrokeCE) {
            inject.warn('Stroke style can not use conic-gradient');
          } else if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        } else if (isFillRE || isStrokeRE) {
          if (isFillRE) {
            this.__radialEllipse(renderMode, ctx, list, isMulti, res, 'fill');
          } else if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true);
          } // stroke椭圆渐变matrix会变形，降级为圆


          if (strokeWidth > 0 && isStrokeRE) {
            inject.warn('Stroke style can not use radial-gradient for ellipse');
            res.stroke = res.stroke.v[0];

            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          } else if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        } else {
          if (fill && fill !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, list, res, true, false);
          }

          if (strokeWidth > 0 && stroke && stroke !== 'none') {
            this.__drawPolygon(renderMode, ctx, isMulti, sList, res, false, true);
          }
        }
      }
    }, {
      key: "__genSector",
      value: function __genSector(edge, d, fill, stroke, strokeWidth, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit) {
        if (edge) {
          var props = [['d', d[0]], ['fill', fill.v || fill], ['stroke', stroke.v || stroke], ['stroke-width', strokeWidth]];

          this.__propsStrokeStyle(props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);

          this.addGeom('path', props);
        } else {
          this.addGeom('path', [['d', d[0]], ['fill', fill.v || fill]]);

          if (strokeWidth > 0) {
            var _props = [['d', d[1]], ['fill', 'none'], ['stroke', stroke.v || stroke], ['stroke-width', strokeWidth]];

            this.__propsStrokeStyle(_props, strokeDasharrayStr, strokeLinecap, strokeLinejoin, strokeMiterlimit);

            this.addGeom('path', _props);
          }
        }
      }
    }, {
      key: "begin",
      get: function get() {
        return this.getProps('begin');
      }
    }, {
      key: "end",
      get: function get() {
        return this.getProps('end');
      }
    }, {
      key: "r",
      get: function get() {
        return this.getProps('r');
      }
    }, {
      key: "edge",
      get: function get() {
        return this.getProps('edge');
      } // >180°时是否链接端点

    }, {
      key: "closure",
      get: function get() {
        return this.getProps('closure');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__sx3,
              originY = this.__sy3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$3];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;
          this.buildCache(cx, cy);
          var r = 0;

          if (isMulti) {
            var max = 0;

            __cacheProps.r.forEach(function (r) {
              max = Math.max(r, max);
            });

            r = max;
          } else {
            r = __cacheProps.r;
          }

          var bbox = _get(_getPrototypeOf(Sector.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - r - half;
          var xb = cx + r - half;
          var ya = cy - r + half;
          var yb = cy + r + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Sector;
  }(Geom);

  var STROKE_WIDTH$2 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$3 = util.isNil;

  function genVertex(x, y, width, height) {
    var rx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    var ry = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (rx === 0 || ry === 0) {
      return [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]];
    }

    var ox = rx * geom$1.H;
    var oy = ry * geom$1.H;
    return [[x + rx, y], [x + width - rx, y], [x + width + ox - rx, y, x + width, y + ry - oy, x + width, y + ry], [x + width, y + height - ry], [x + width, y + height + oy - ry, x + width + ox - rx, y + height, x + width - rx, y + height], [x + rx, y + height], [x + rx - ox, y + height, x, y + height + oy - ry, x, y + height - ry], [x, y + ry], [x, y + ry - oy, x + rx - ox, y, x + rx, y]];
  }

  function getR$2(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 0;
    }

    return v;
  }

  var Rect = /*#__PURE__*/function (_Geom) {
    _inherits(Rect, _Geom);

    function Rect(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 圆角

      if (_this.isMulti) {
        _this.__rx = [0];
        _this.__ry = [0];

        if (Array.isArray(props.rx)) {
          _this.__rx = props.rx.map(function (i) {
            return getR$2(i);
          });
        }

        if (Array.isArray(props.ry)) {
          _this.__ry = props.ry.map(function (i) {
            return getR$2(i);
          });
        }
      } else {
        _this.__rx = _this.__ry = 0;

        if (!isNil$3(props.rx)) {
          _this.__rx = getR$2(props.rx);
        }

        if (!isNil$3(props.ry)) {
          _this.__ry = getR$2(props.ry);
        }
      }

      return _this;
    }

    _createClass(Rect, [{
      key: "buildCache",
      value: function buildCache(originX, originY, focus) {
        var width = this.width,
            height = this.height,
            rx = this.rx,
            ry = this.ry,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$3(__cacheProps.rx) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.rx = rx.map(function (rx) {
              return Math.min(rx, 0.5) * width;
            });
          } else {
            __cacheProps.rx = Math.min(rx, 0.5) * width;
          }
        }

        if (isNil$3(__cacheProps.ry) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.ry = rx.map(function (ry) {
              return Math.min(ry, 0.5) * height;
            });
          } else {
            __cacheProps.ry = Math.min(ry, 0.5) * height;
          }
        }

        if (rebuild) {
          var _rx = __cacheProps.rx,
              _ry = __cacheProps.ry;

          if (isMulti) {
            __cacheProps.list = _rx.map(function (rx, i) {
              return genVertex(originX, originY, width, height, rx, _ry[i]);
            });
          } else {
            __cacheProps.list = genVertex(originX, originY, width, height, _rx, _ry);
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Rect.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.buildCache(res.sx3, res.sy3);

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "rx",
      get: function get() {
        return this.getProps('rx');
      }
    }, {
      key: "ry",
      get: function get() {
        return this.getProps('ry');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var originX = this.__sx3,
              originY = this.__sy3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$2];
          this.buildCache(originX, originY);

          var bbox = _get(_getPrototypeOf(Rect.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          bbox[0] = Math.min(bbox[0], originX - half);
          bbox[1] = Math.min(bbox[1], originY - half);
          bbox[2] = Math.max(bbox[2], originX + width + half);
          bbox[3] = Math.max(bbox[3], originY + height + half);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Rect;
  }(Geom);

  var STROKE_WIDTH$1 = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$2 = util.isNil;

  function getR$1(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 1;
    }

    return v;
  }

  var Circle = /*#__PURE__*/function (_Geom) {
    _inherits(Circle, _Geom);

    function Circle(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 半径[0, ∞)，默认1

      if (_this.isMulti) {
        _this.__r = [1];

        if (Array.isArray(props.r)) {
          _this.__r = props.r.map(function (i) {
            return getR$1(i);
          });
        } else if (!isNil$2(props.r)) {
          _this.__r = getR$1(props.r);
        }
      } else {
        _this.__r = 1;

        if (!isNil$2(props.r)) {
          _this.__r = getR$1(props.r);
        }
      }

      return _this;
    }

    _createClass(Circle, [{
      key: "buildCache",
      value: function buildCache(cx, cy, focus) {
        var width = this.width,
            r = this.r,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;

        if (isNil$2(__cacheProps.r) || focus) {
          if (isMulti) {
            __cacheProps.r = r.map(function (i) {
              return i * width * 0.5;
            });
            __cacheProps.list = __cacheProps.r.map(function (r) {
              return geom$1.ellipsePoints(cx, cy, r, r);
            });
          } else {
            __cacheProps.r = r * width * 0.5;
            __cacheProps.list = geom$1.ellipsePoints(cx, cy, __cacheProps.r, __cacheProps.r);
          }
        }
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Circle.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.buildCache(res.cx, res.cy);

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "r",
      get: function get() {
        return this.getProps('r');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__sx3,
              originY = this.__sy3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH$1];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;
          this.buildCache(cx, cy);
          var r = 0;

          if (isMulti) {
            var max = 0;

            __cacheProps.r.forEach(function (r) {
              max = Math.max(r, max);
            });

            r = max;
          } else {
            r = __cacheProps.r;
          }

          var bbox = _get(_getPrototypeOf(Circle.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - r - half;
          var ya = cy - r - half;
          var xb = cx + r + half;
          var yb = cy + r + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Circle;
  }(Geom);

  var STROKE_WIDTH = enums.STYLE_KEY.STROKE_WIDTH;
  var isNil$1 = util.isNil;

  function getR(v) {
    v = parseFloat(v);

    if (isNaN(v)) {
      v = 1;
    }

    return v;
  }

  var Ellipse = /*#__PURE__*/function (_Geom) {
    _inherits(Ellipse, _Geom);

    function Ellipse(tagName, props) {
      var _this;

      _this = _Geom.call(this, tagName, props) || this; // 半径[0, ∞)，默认1

      if (_this.isMulti) {
        _this.__rx = [1];
        _this.__ry = [1];

        if (Array.isArray(props.rx)) {
          _this.__rx = props.rx.map(function (i) {
            return getR(i);
          });
        } else if (!isNil$1(props.rx)) {
          _this.__rx = [getR(props.rx)];
        }

        if (Array.isArray(props.ry)) {
          _this.__ry = props.ry.map(function (i) {
            return getR(i);
          });
        } else if (!isNil$1(props.ry)) {
          _this.__ry = [getR(props.ry)];
        }
      } else {
        _this.__rx = 1;

        if (!isNil$1(props.rx)) {
          _this.__rx = getR(props.rx);
        }

        _this.__ry = 1;

        if (!isNil$1(props.ry)) {
          _this.__ry = getR(props.ry);
        }
      }

      return _this;
    }

    _createClass(Ellipse, [{
      key: "buildCache",
      value: function buildCache(cx, cy, focus) {
        var width = this.width,
            height = this.height,
            rx = this.rx,
            ry = this.ry,
            __cacheProps = this.__cacheProps,
            isMulti = this.isMulti;
        var rebuild;

        if (isNil$1(__cacheProps.rx) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.rx = rx.map(function (i) {
              return i * width * 0.5;
            });
          } else {
            __cacheProps.rx = rx * width * 0.5;
          }
        }

        if (isNil$1(__cacheProps.ry) || focus) {
          rebuild = true;

          if (isMulti) {
            __cacheProps.ry = ry.map(function (i) {
              return i * height * 0.5;
            });
          } else {
            __cacheProps.ry = ry * height * 0.5;
          }
        }

        if (rebuild) {
          var _rx = __cacheProps.rx,
              _ry = __cacheProps.ry;

          if (isMulti) {
            __cacheProps.list = _rx.map(function (rx, i) {
              return geom$1.ellipsePoints(cx, cy, rx, _ry[i]);
            });
          } else {
            __cacheProps.list = geom$1.ellipsePoints(cx, cy, _rx, _ry);
          }
        }

        return rebuild;
      }
    }, {
      key: "render",
      value: function render(renderMode, ctx, dx, dy) {
        var res = _get(_getPrototypeOf(Ellipse.prototype), "render", this).call(this, renderMode, ctx, dx, dy);

        if (res["break"] || renderMode === mode.WEBGL) {
          return res;
        }

        this.buildCache(res.cx, res.cy);

        this.__renderPolygon(renderMode, ctx, res);

        return res;
      }
    }, {
      key: "rx",
      get: function get() {
        return this.getProps('rx');
      }
    }, {
      key: "ry",
      get: function get() {
        return this.getProps('ry');
      }
    }, {
      key: "bbox",
      get: function get() {
        if (!this.__bbox) {
          var isMulti = this.isMulti,
              __cacheProps = this.__cacheProps,
              originX = this.__sx3,
              originY = this.__sy3,
              width = this.width,
              height = this.height,
              strokeWidth = this.computedStyle[STROKE_WIDTH];
          var cx = originX + width * 0.5;
          var cy = originY + height * 0.5;
          this.buildCache(cx, cy);
          var rx = 0,
              ry = 0;

          if (isMulti) {
            var mx = 0,
                my = 0;

            __cacheProps.rx.forEach(function (rx, i) {
              mx = Math.max(rx, mx);
              my = Math.max(ry, __cacheProps.ry[i]);
            });

            rx = mx;
            ry = my;
          } else {
            rx = __cacheProps.rx;
            ry = __cacheProps.ry;
          }

          var bbox = _get(_getPrototypeOf(Ellipse.prototype), "bbox", this);

          var half = 0;
          strokeWidth.forEach(function (item) {
            half = Math.max(half, item);
          });
          half = Math.ceil(half * 0.5) + 1;
          var xa = cx - rx - half;
          var xb = cx + rx + half;
          var ya = cy - ry - half;
          var yb = cy + ry + half;
          bbox[0] = Math.min(bbox[0], xa);
          bbox[1] = Math.min(bbox[1], ya);
          bbox[2] = Math.max(bbox[2], xb);
          bbox[3] = Math.max(bbox[3], yb);
          this.__bbox = bbox;
        }

        return this.__bbox;
      }
    }]);

    return Ellipse;
  }(Geom);

  var TYPE_VD$2 = $$type.TYPE_VD,
      TYPE_GM$2 = $$type.TYPE_GM,
      TYPE_CP$2 = $$type.TYPE_CP;
  /**
   * 2. 打平children中的数组，变成一维
   * 3. 合并相连的Text节点，即string内容
   */

  function flattenJson(parent) {
    if (Array.isArray(parent)) {
      return parent.map(function (item) {
        return flattenJson(item);
      });
    } else if (!parent || [TYPE_VD$2, TYPE_GM$2, TYPE_CP$2].indexOf(parent.$$type) === -1 || !Array.isArray(parent.children)) {
      return parent;
    }

    var list = [];
    traverseJson(list, parent.children, {
      lastText: null
    });
    parent.children = list;
    return parent;
  }

  function traverseJson(list, children, options) {
    if (Array.isArray(children)) {
      children.forEach(function (item) {
        traverseJson(list, item, options);
      });
    } else if (children && (children.$$type === TYPE_VD$2 || children.$$type === TYPE_GM$2)) {
      if (['canvas', 'svg', 'webgl'].indexOf(children.tagName) > -1) {
        throw new Error('Can not nest canvas/svg/webgl');
      }

      if (children.$$type === TYPE_VD$2) {
        flattenJson(children);
      }

      list.push(children);
      options.lastText = null;
    } else if (children && children.$$type === TYPE_CP$2) {
      list.push(children); // 强制component即便返回text也形成一个独立的节点，合并在layout布局中做

      options.lastText = null;
    } // 排除掉空的文本，连续的text合并
    else if (!util.isNil(children) && children !== '') {
      if (options.lastText !== null) {
        list[list.length - 1] = options.lastText += children;
      } else {
        list.push(children);
      }
    }
  }

  var TYPE_VD$1 = $$type.TYPE_VD,
      TYPE_GM$1 = $$type.TYPE_GM,
      TYPE_CP$1 = $$type.TYPE_CP;
  var updateList = [];
  var removeList = [];
  var KEY_FLAG = {};
  /**
   * setState后刷新前先根遍历检查组件开始进行shouldComponentUpdate判断
   */

  function check(vd) {
    if (vd instanceof Dom) {
      vd.children.forEach(function (child) {
        if (child instanceof Dom) {
          check(child);
        } // 当组件有setState更新时，从叶子到根链路会标识__hasCpUpdate，以便节约遍历成本忽略那些没变化的链路
        else if (child instanceof Component && child.__hasCpUpdate) {
          child.__hasCpUpdate = false;
          checkCp(child, child.props);
        }
      });
    } // 高阶组件会进入此分支，被父组件调用
    else if (vd instanceof Component && vd.__hasCpUpdate) {
      vd.__hasCpUpdate = false;
      checkCp(vd, vd.props);
    }
  }
  /**
   * 检查cp是否有state变更，注意递归检查时需要看shadow不能看shadowRoot，
   * 否则高阶组件会被跳过，其更新无法触发update生命周期
   * @param cp
   * @param nextProps
   * @param forceCheckUpdate，被render()后的json的二级组件，发现props有变更强制检查更新，否则可以跳过
   */


  function checkCp(cp, nextProps, forceCheckUpdate) {
    if (cp.__nextState || forceCheckUpdate) {
      var shouldUpdate;

      if (util.isFunction(cp.shouldComponentUpdate)) {
        shouldUpdate = cp.shouldComponentUpdate(nextProps, cp.__nextState || cp.state);
      } else {
        // 没有默认更新
        shouldUpdate = true;
      }

      if (shouldUpdate) {
        updateCp(cp, nextProps, cp.__nextState || cp.state);
      } // 不更新则递归检查子tree的cp
      else {
        cp.props = nextProps;
        cp.state = cp.__nextState || cp.state;
        check(cp.shadow);
      }
    } else {
      check(cp.shadow);
    }
  }
  /**
   * 更新组件的props和state，清空__nextState
   * @param cp
   * @param props
   * @param state
   */


  function updateCp(cp, props, state) {
    cp.props = props;
    cp.state = state;
    cp.__nextState = null; // 同步在refresh前清除component的新state标识，这样frame动画在after回调中可以新设

    var oldS = cp.shadow;
    var oldSr = cp.shadowRoot;
    var oldJson = cp.__cd;
    var json = flattenJson(cp.render()); // 对比新老render()返回的内容，更新后重新生成sr

    diffSr(oldS, oldJson, json);

    cp.__init(json); // 为了局部dom布局需要知道老的css信息


    var sr = cp.shadowRoot;

    if (sr instanceof Xom) {
      ['__outerWidth', '__outerHeight', '__sx', '__sy', '__sx2', '__sx3', '__sx4', '__sx5', '__sx6', '__sy2', '__sy3', '__sy4', '__sy5', '__sy6'].forEach(function (k) {
        sr[k] = oldSr[k];
      });
      sr.__computedStyle = oldSr.computedStyle;
    }

    ['__x', '__y', '__width', '__height', '__sx1', // text和xom
    '__sy1', '__layoutData', '__parent', '__domParent'].forEach(function (k) {
      sr[k] = oldSr[k];
    });
    sr.__domParent = oldSr.__domParent;
    sr.__struct = oldSr.__struct;
    updateList.push(cp); // 老的需回收，diff会生成新的dom，唯一列外是cp直接返回一个没变化的cp

    if (!util.isObject(json) || !json.__placeholder) {
      removeList.push(oldS);
    } // 子组件使用老的json时标识，更新后删除，render()返回空会没json对象


    if (json && json.__placeholder) {
      delete json.__placeholder;
    }

    if (json && json.__inheritAnimate) {
      delete json.__inheritAnimate;
    }

    if (json && json.__animateRecords) {
      delete json.__animateRecords;
    } // 高阶组件时需判断，子组件更新后生成新的sr，父组件的sr/host需要同时更新引用


    var host = cp.host;

    while (host) {
      if (host.shadow === cp) {
        host.__shadowRoot = sr;
        sr.__hostRoot = host;
        cp = host;
        host = host.host;
      } else {
        break;
      }
    }
  }
  /**
   * 非一级组件sr进行对比，key相同的无需重新生成且继承动画
   * @param vd
   * @param oj oldJson
   * @param nj
   */


  function diffSr(vd, oj, nj) {
    // 先遍历检查key相同的，将没有变化的key暂存下来，深度优先，这样叶子节点出现在前面，当key的叶子也有key时，确保叶子先对比
    var ojk = getKeyHash(oj, {}, vd);
    var njk = getKeyHash(nj, {});
    var keyList = [];
    var cpList = []; // 先对比key对应的节点，如果新老有一方对不上则落空

    Object.keys(ojk).forEach(function (k) {
      var o = ojk[k];
      var n = njk[k];

      if (!n) {
        o.json.key = KEY_FLAG;
      }
    });
    Object.keys(njk).forEach(function (k) {
      var o = ojk[k];
      var n = njk[k]; // 有可能老的没有这个key，新key落空

      if (!o) {
        n.json.key = KEY_FLAG;
        return;
      }

      var oj = o.json;
      var nj = n.json;
      var vd = o.vd; // 相同class的组件进行对比替换

      if (oj.$$type === TYPE_CP$1 && nj.$$type === TYPE_CP$1) {
        if (oj.klass === nj.klass) {
          // 对比props和children看是否全等，是则直接替换新json类型为占位符，引用老vd，否则强制更新
          diffCp(oj, nj, vd); // 标识对比过了

          oj.key = nj.key = KEY_FLAG; // 老的sr里需删除这个vd，因为老sr会回收

          cpList.push(vd);
        }
      } // 相同类型的vd进行对比继承动画
      else if (oj.$$type === nj.$$type && oj.tagName === nj.tagName) {
        // 需判断矢量标签mutil是否相等
        if (nj.$$type !== TYPE_GM$1 || oj.props.multi === nj.props.multi) {
          nj.__inheritAnimate = vd;
        }

        oj.key = nj.key = KEY_FLAG; // key相同的dom暂存下来

        if (nj.$$type === TYPE_VD$1) {
          keyList.push({
            vd: vd,
            oj: oj,
            nj: nj
          });
        }
      }
    }); // key相同的dom对比children，下面非key逻辑就不做了

    keyList.forEach(function (item) {
      diffChildren(item.vd, item.oj, item.nj);
    }); // 整体tree进行对比

    diffChild(vd, oj, nj); // 已更新的cp需被老sr删除，因为老sr会回收，而此cp继续存在于新sr中不能回收，这里处理key的

    cpList.forEach(function (vd) {
      removeCpFromOldTree(vd);
    });
  }
  /**
   * 递归检查dom的children，相同的无需重新生成，用PL类型占位符代替直接返回老vd
   * @param vd
   * @param oj
   * @param nj
   */


  function diffChild(vd, oj, nj) {
    if (util.isObject(nj)) {
      if (nj.$$type === TYPE_CP$1) {
        // key对比过了忽略
        if (nj.key === KEY_FLAG) {
          return;
        } // 相同class的组件处理


        if (oj && oj.$$type === nj.$$type && oj.klass === nj.klass) {
          diffCp(oj, nj, vd); // 已更新的cp需被老sr删除，因为老sr会回收，而此cp继续存在于新sr中不能回收

          removeCpFromOldTree(vd);
        }
      } else if (nj.$$type === TYPE_GM$1 && oj && oj.$$type === TYPE_GM$1) {
        // $geom的multi必须一致
        if (oj.tagName === nj.tagName && oj.props.multi === nj.props.multi) {
          nj.__inheritAnimate = vd;
        }
      } // dom类型递归children
      else if (nj.$$type === TYPE_VD$1 && oj && oj.$$type === TYPE_VD$1) {
        if (oj.tagName === nj.tagName) {
          nj.__inheritAnimate = vd;
        }

        diffChildren(vd, oj, nj);
      }
    }
  }
  /**
   * dom类型的vd对比children
   * @param vd
   * @param oj
   * @param nj
   */


  function diffChildren(vd, oj, nj) {
    var oc = oj.children;
    var nc = nj.children;
    var ol = oc.length;
    var nl = nc.length;
    var children = vd.children;

    for (var i = 0, of = 0, nf = 0, len = Math.min(ol, nl); i < len; i++) {
      var o = oc[i + of];
      var n = nc[i + nf]; // 新老都是key直接跳过

      if (o.key === KEY_FLAG && n.key === KEY_FLAG) ; // 其中一个是key对比过了调整索引和长度
      else if (o.key === KEY_FLAG) {
        of++;
        i--;
        ol--;
        len = Math.min(ol, nl);
      } else if (n.key === KEY_FLAG) {
        nf++;
        i--;
        nl--;
        len = Math.min(ol, nl);
      } else {
        diffChild(children[i + of], o, n);
      }
    } // 长度不同增减的无需关注，新json创建cp有didMount，老vd会调用cp的destroy

  }
  /**
   * 根据json对比看cp如何更新，被render()后的json的二级组件对比才会出现
   * @param oj
   * @param nj
   * @param vd
   */


  function diffCp(oj, nj, vd) {
    // props全等，直接替换新json类型为占位符，引用老vd内容，无需重新创建，暂时存在json的placeholder上
    // 否则需要强制触发组件更新，包含setState内容
    nj.__placeholder = vd;
    var sr = vd.shadowRoot; // 对比需忽略on开头的事件，直接改老的引用到新的上，这样只变了on的话无需更新

    var exist = {};
    Object.keys(oj.props).forEach(function (k) {
      var v = oj.props[k];
      exist[k] = v;
    });
    Object.keys(nj.props).forEach(function (k) {
      var v = nj.props[k];

      if (/^on[a-zA-Z]/.test(k)) {
        oj.props[k] = v;
        var ex = exist[k];

        if (ex) {
          delete exist[k];

          if (ex !== v) {
            k = k.slice(2).toLowerCase();
            sr.listener[k] = v;
          }
        } else {
          k = k.slice(2).toLowerCase();
          sr.listener[k] = v;
        }
      } else if (/^on-[a-zA-Z\d_$]/.test(k)) {
        oj.props[k] = v;
        var _ex = exist[k];

        if (_ex) {
          delete exist[k];

          if (_ex !== v) {
            k = k.slice(2).toLowerCase();
            vd.off(k, exist[k]);
            vd.on(k, v);
          }

          delete exist[k];
        } else {
          k = k.slice(2).toLowerCase();
          vd.on(k, v);
        }
      }
    }); // 新的少的事件取消

    Object.keys(exist).forEach(function (k) {
      var v = exist[k];

      if (/^on[a-zA-Z]/.test(k)) {
        nj.props[k] = v;
        k = k.slice(2).toLowerCase();
        delete sr.listener[k];
      } else if (/^on-[a-zA-Z\d_$]/.test(k)) {
        nj.props[k] = v;
        k = k.slice(2).toLowerCase();
        vd.off(k, v);
      }
    });
    checkCp(vd, nj.props, !util.equal(oj.props, nj.props));
  }
  /**
   * 深度优先遍历json，将有key的记录在hash中，如果传入根vd，同步递归保存对应位置的vd
   * @param json
   * @param hash
   * @param vd
   * @returns {*}
   */


  function getKeyHash(json, hash, vd) {
    if (Array.isArray(json)) {
      json.forEach(function (item, i) {
        return getKeyHash(item, hash, vd && vd[i]);
      });
    } else if (util.isObject(json)) {
      if (json.$$type === TYPE_VD$1 || json.$$type === TYPE_GM$1 || json.$$type === TYPE_CP$1) {
        // 深度优先
        if (json.$$type === TYPE_VD$1) {
          getKeyHash(json.children, hash, vd && vd.children);
        }

        var key = json.props.key;

        if (!util.isNil(key) && key !== '') {
          // 重复key错误警告
          if (hash.hasOwnProperty(key)) {
            inject.warn('Component ' + vd.tagName + ' has duplicate key: ' + key);
          }

          hash[key] = {
            json: json,
            vd: vd
          };
        }
      }
    }

    return hash;
  }
  /**
   * 非一级组件diff发生更新时，其需要从sr的tree中移除，因为sr会销毁
   */


  function removeCpFromOldTree(vd) {
    // root下的一级组件不会发生回收情况，忽略
    if (!vd.host) {
      return;
    }

    var parent = vd.parent;

    if (parent) {
      var i = parent.children.indexOf(vd);

      if (i > -1) {
        parent.children[i] = null;
      } else {
        throw new Error('Can not find child: ' + vd.tagName);
      }
    }
  }
  /**
   * 执行componentDidUpdate/destroy
   */


  function did() {
    updateList.forEach(function (item) {
      if (util.isFunction(item.componentDidUpdate)) {
        item.componentDidUpdate();
      }
    });
    updateList.splice(0);
    removeList.forEach(function (item) {
      item.__destroy();
    });
    removeList = [];
  }

  var updater = {
    updateList: updateList,
    check: check,
    did: did
  };

  var TYPE_VD = $$type.TYPE_VD,
      TYPE_GM = $$type.TYPE_GM,
      TYPE_CP = $$type.TYPE_CP;
  var isPrimitive$1 = util.isPrimitive;
  /**
   * 入口方法，animateRecords记录所有的动画结果等初始化后分配开始动画
   * hash为library库的hash格式，将原本数组转为id和value访问，每递归遇到library形成一个新的scope重新初始化
   * offsetTime默认0，递归传下去为右libraryId引用的元素增加偏移时间，为了库元素动画复用而开始时间不同
   * @param karas
   * @param json
   * @param animateRecords
   * @param opt
   * @param offsetTime
   * @returns {Node|Component|*}
   */

  function parse(karas, json, animateRecords, opt, offsetTime) {
    if (isPrimitive$1(json) || json instanceof Node || json instanceof Component) {
      return json;
    }

    if (Array.isArray(json)) {
      return json.map(function (item) {
        return parse(karas, item, animateRecords, opt, offsetTime);
      });
    }

    var oft = offsetTime; // 暂存，后续生成动画用这个值

    offsetTime += json.offsetTime || 0; // 可能有时间偏移加上为递归准备

    var tagName = json.tagName,
        _json$props = json.props,
        props = _json$props === void 0 ? {} : _json$props,
        _json$children = json.children,
        children = _json$children === void 0 ? [] : _json$children,
        _json$animate = json.animate,
        animate = _json$animate === void 0 ? [] : _json$animate;

    if (!tagName) {
      throw new Error('Dom must have a tagName: ' + JSON.stringify(json));
    }

    if (!Array.isArray(children)) {
      throw new Error('children must be an array');
    }

    var vd;

    if (tagName.charAt(0) === '$') {
      vd = karas.createGm(tagName, props);
    } else if (/^[A-Z]/.test(tagName)) {
      var cp = Component.getRegister(tagName);
      vd = karas.createCp(cp, props, children.map(function (item) {
        if (item && [TYPE_VD, TYPE_GM, TYPE_CP].indexOf(item.$$type) > -1) {
          return item;
        }

        return parse(karas, item, animateRecords, opt, offsetTime);
      }));
    } else {
      vd = karas.createVd(tagName, props, children.map(function (item) {
        if (item && [TYPE_VD, TYPE_GM, TYPE_CP].indexOf(item.$$type) > -1) {
          return item;
        }

        return parse(karas, item, animateRecords, opt, offsetTime);
      }));
    }

    if (animate) {
      if (!Array.isArray(animate)) {
        animate = [animate];
      }

      var has;
      animate.forEach(function (item) {
        var value = item.value; // 忽略空动画

        if (Array.isArray(value) && value.length) {
          has = true;
        }
      }); // 产生实际动画运行才存入列表供root调用执行

      if (has) {
        animateRecords.push({
          animate: animate,
          target: vd,
          offsetTime: oft
        });
      }
    }

    return vd;
  }

  var fullCssProperty = {
    skewX: 'kx',
    skewY: 'ky',
    transform: 'tf',
    fontSize: 'fz',
    offset: 'os',
    easing: 'e',
    filter: 'ft',
    boxShadow: 'bd',
    overflow: 'of',
    backgroundClip: 'bp',
    textOverflow: 'tof',
    flexWrap: 'fp',
    perspective: 'ppt',
    rotate3d: 'r3'
  };
  var abbrCssProperty$1 = {
    os: 'offset',
    // 非css属性不会被下面反向遍历插入，手动
    e: 'easing'
  };
  var fullAnimate = {
    value: 'v',
    options: 'o'
  };
  var abbrAnimate$1 = {};
  var fullAnimateOption = {
    duration: 'dt',
    delay: 'd',
    endDelay: 'ed',
    iterations: 'i',
    direction: 'dc',
    fill: 'f',
    fps: 'fp',
    playbackRate: 'p',
    spfLimit: 'sl'
  };
  var abbrAnimateOption$1 = {};
  reset.DOM_KEY_SET.concat(reset.GEOM_KEY_SET).forEach(function (k) {
    if (fullCssProperty.hasOwnProperty(k)) {
      abbrCssProperty$1[fullCssProperty[k]] = k;
      return;
    }

    var v = k.charAt(0) + k.replace(/[a-z]/g, '').toLowerCase();
    fullCssProperty[k] = v;
    abbrCssProperty$1[v] = k;
  });
  Object.keys(fullAnimate).forEach(function (k) {
    abbrAnimate$1[fullAnimate[k]] = k;
  });
  Object.keys(fullAnimateOption).forEach(function (k) {
    abbrAnimateOption$1[fullAnimateOption[k]] = k;
  });
  var abbr = {
    fullCssProperty: fullCssProperty,
    abbrCssProperty: abbrCssProperty$1,
    fullAnimate: fullAnimate,
    abbrAnimate: abbrAnimate$1,
    fullAnimateOption: fullAnimateOption,
    abbrAnimateOption: abbrAnimateOption$1
  };

  var isNil = util.isNil,
      isFunction = util.isFunction,
      isPrimitive = util.isPrimitive,
      clone = util.clone,
      extend = util.extend;
  var abbrCssProperty = abbr.abbrCssProperty,
      abbrAnimateOption = abbr.abbrAnimateOption,
      abbrAnimate = abbr.abbrAnimate;
  /**
   * 还原缩写到全称，涉及样式和动画属性，已过时
   * @param target 还原的对象
   * @param hash 缩写映射
   */

  function abbr2full(target, hash) {
    // 也许节点没写样式
    if (target) {
      Object.keys(target).forEach(function (k) {
        // var-attr格式特殊考虑，仅映射attr部分，var-还要保留
        if (k.indexOf('var-') === 0) {
          var k2 = k.slice(4);

          if (hash.hasOwnProperty(k2)) {
            var fk = hash[k2];
            target['var-' + fk] = target[k]; // delete target[k];
          }
        } // 普通样式缩写还原
        else if (hash.hasOwnProperty(k)) {
          var _fk = hash[k];
          target[_fk] = target[k]; // 删除以免二次解析

          delete target[k];
        }
      });
    }
  }
  /**
   * 链接json中的某个child到library文件，
   * props需要是clone的，因为防止多个child使用同一个库文件
   * children则直接引用，无需担心多个使用同一个
   * library也需要带上，在library直接子元素还包含library时会用到
   * @param child
   * @param libraryItem
   */


  function linkLibrary(child, libraryItem) {
    // 规定图层child只有init和动画，属性和子图层来自库
    child.tagName = libraryItem.tagName;
    child.props = clone(libraryItem.props) || {};
    child.children = libraryItem.children || [];

    if (libraryItem.vars && !child.vars) {
      child.vars = libraryItem.vars;
    }

    if (libraryItem.library) {
      child.library = libraryItem.library;
    } // library的var-也要继承过来，本身的var-优先级更高，目前只有children会出现优先级情况


    Object.keys(libraryItem).forEach(function (k) {
      if (k.indexOf('var-') === 0 && !child.hasOwnProperty(k)) {
        child[k] = libraryItem[k];
      }
    }); // 删除以免二次解析

    delete child.libraryId;
    var init = child.init;

    if (init) {
      var props = child.props;
      var style = props.style;
      extend(props, init); // style特殊处理，防止被上面覆盖丢失原始值

      if (style) {
        extend(style, init.style);
        props.style = style;
      } // 删除以免二次解析


      delete child.init;
    }
  }
  /**
   * 遍历一遍library的一级，将一级的id存到hash上，无需递归二级，
   * 因为顺序前提要求排好且无循环依赖，所以被用到的一定在前面出现，
   * 一般是无children的元件在前，包含children的div在后
   * 即便library中的元素有children或library，在linkChild时将其link过去，parse递归会继续处理
   * @param item：library的一级孩子
   * @param hash：存放library的key/value引用
   */


  function initLibrary(item, hash) {
    var id = item.id; // library中一定有id，因为是一级，二级+特殊需求才会出现放开

    if (isNil(id)) {
      throw new Error('Library item miss id: ' + JSON.stringify(item));
    } else {
      hash[id] = item;
    }
  } // 有library的json一级初始化library供链接前，可以替换library里的内容


  function replaceLibraryVars(json, hash, vars) {
    // 新版同级vars语法，增加可以修改library子元素中递归子属性
    if (json.hasOwnProperty('vars')) {
      var slot = json.vars;
      delete json.vars;

      if (!Array.isArray(slot)) {
        slot = [slot];
      }

      slot.forEach(function (item) {
        var id = item.id,
            member = item.member;

        if (!Array.isArray(member)) {
          member = [member];
        } // library.xxx，需要>=2的长度，开头必须是library


        if (Array.isArray(member) && member.length > 1 && vars && vars.hasOwnProperty(id)) {
          if (member[0] === 'library') {
            var target = hash;

            for (var i = 1, len = member.length; i < len; i++) {
              var k = member[i]; // 最后一个属性可以为空

              if (target.hasOwnProperty(k) || i === len - 1) {
                // 最后一个member表达式替换
                if (i === len - 1) {
                  var v = vars[id];
                  var old = target[k]; // 支持函数模式和值模式

                  if (isFunction(v)) {
                    v = v(old);
                  } // 直接替换library的子对象，需补充id和tagName


                  if (i === 1) {
                    target[k] = Object.assign({
                      id: old.id,
                      tagName: old.tagName
                    }, v);
                  } // 替换library中子对象的一个属性直接赋值
                  else {
                    target[k] = v;
                  }
                } // 子属性继续下去
                else {
                  target = target[k];
                }
              } else {
                inject.error('Library slot miss ' + k);
                return;
              }
            }
          }
        }
      });
    } // 兼容老版var-，只支持一级library元素
    else {
      Object.keys(json).forEach(function (k) {
        if (k.indexOf('var-library.') === 0) {
          var v = json[k];
          delete json[k];

          if (!v || !vars) {
            return;
          }

          var k2 = k.slice(12); // 有id且变量里面传入了替换的值

          if (k2 && v.id && vars.hasOwnProperty(v.id)) {
            var value = vars[v.id];

            if (isFunction(value)) {
              value = value(v);
            } // library对象也要加上id，与正常的library保持一致


            hash[k2] = Object.assign({
              id: k2
            }, value);
          }
        }
      });
    }
  }

  function replaceVars(json, vars) {
    if (json) {
      // 新版vars语法
      if (json.hasOwnProperty('vars')) {
        var slot = json.vars;
        delete json.vars;

        if (!Array.isArray(slot)) {
          slot = [slot];
        }

        if (Array.isArray(slot)) {
          slot.forEach(function (item) {
            var id = item.id,
                member = item.member;

            if (!Array.isArray(member)) {
              member = [member];
            } // 排除特殊的library


            if (Array.isArray(member) && member.length && member[0] !== 'library' && vars && vars.hasOwnProperty(id)) {
              var target = json;

              for (var i = 0, len = member.length; i < len; i++) {
                var k = member[i]; // 最后一个属性可以为空

                if (target.hasOwnProperty(k) || i === len - 1) {
                  // 最后一个member表达式替换
                  if (i === len - 1) {
                    var v = vars[id]; // undefined和null意义不同

                    if (v === undefined) {
                      return;
                    } // 支持函数模式和值模式


                    if (isFunction(v)) {
                      v = v(target[k]);
                    }

                    target[k] = v;
                  } else {
                    target = target[k];
                  }
                } else {
                  inject.error('Slot miss ' + k);
                  return;
                }
              }
            }
          });
        }
      } else {
        Object.keys(json).forEach(function (k) {
          if (k.indexOf('var-') === 0) {
            var v = json[k];
            delete json[k];

            if (!v || !vars) {
              return;
            }

            var k2 = k.slice(4); // 有id且变量里面传入了替换的值，值可为null，因为某些情况下空为自动

            if (k2 && v.id && vars.hasOwnProperty(v.id)) {
              var value = vars[v.id]; // undefined和null意义不同

              if (value === undefined) {
                return;
              }

              var target = json; // 如果有.则特殊处理子属性

              if (k2.indexOf('.') > -1) {
                var list = k2.split('.');
                var len = list.length;

                for (var i = 0; i < len - 1; i++) {
                  k2 = list[i]; // 避免异常

                  if (target[k2]) {
                    target = target[k2];
                  } else {
                    inject.warn('parseJson vars is not exist: ' + v.id + ', ' + k + ', ' + list.slice(0, i).join('.'));
                    return;
                  }
                }

                k2 = list[len - 1];
              } // 支持函数模式和值模式


              if (isFunction(value)) {
                value = value(v);
              }

              target[k2] = value;
            }
          }
        });
      }
    }
  } // parse的options可以传总的duration等


  function replaceAnimateOptions(options, opt) {
    ['iterations', 'fill', 'duration', 'direction', 'easing', 'fps', 'delay', 'endDelay', 'playbackRate', 'spfLimit'].forEach(function (k) {
      if (opt.hasOwnProperty(k)) {
        options[k] = opt[k];
      }
    });
  }

  function apply(json, opt, hash) {
    if (isPrimitive(json) || json instanceof Node || json instanceof Component) {
      return json;
    }

    if (Array.isArray(json)) {
      return json.map(function (item) {
        return apply(item, opt, hash);
      });
    } // 先判断是否是个链接到库的节点，是则进行链接操作


    var libraryId = json.libraryId;

    if (!isNil(libraryId)) {
      var libraryItem = hash[libraryId]; // 规定图层child只有init和动画，tagName和属性和子图层来自库

      if (libraryItem) {
        linkLibrary(json, libraryItem);
      } else {
        throw new Error('Link library miss id: ' + libraryId);
      }
    } // 再判断是否有library形成一个新的作用域，会出现library下的library使得一个链接节点链接后出现library的情况


    var library = json.library;

    if (Array.isArray(library)) {
      hash = {};
      library.forEach(function (item) {
        return initLibrary(item, hash);
      }); // 替换library插槽

      replaceLibraryVars(json, hash, opt.vars);
      delete json.library;
    }

    var tagName = json.tagName,
        _json$props = json.props,
        props = _json$props === void 0 ? {} : _json$props,
        _json$children = json.children,
        children = _json$children === void 0 ? [] : _json$children,
        _json$animate = json.animate,
        animate = _json$animate === void 0 ? [] : _json$animate;

    if (!tagName) {
      throw new Error('Dom must have a tagName: ' + JSON.stringify(json));
    } // 缩写src和font


    var src = props.src;

    if (/^#\d+$/.test(src)) {
      var imgs = opt.imgs,
          i = parseInt(src.slice(1));

      if (Array.isArray(imgs)) {
        props.src = imgs[i];
      }
    }

    var style = props.style;

    if (style) {
      var fontFamily = style.fontFamily;

      if (/^#\d+$/.test(fontFamily)) {
        var fonts = opt.fonts,
            _i = parseInt(fontFamily.slice(1));

        if (Array.isArray(fonts)) {
          style.fontFamily = fonts[_i];
        }
      }

      opt.abbr !== false && abbr2full(style, abbrCssProperty); // 先替换style的

      replaceVars(style, opt.vars);
    } // 再替换静态属性，style也作为属性的一种


    replaceVars(props, opt.vars); // 替换children里的内容，如文字，无法直接替换tagName/props/children/animate本身，因为下方用的还是原引用

    replaceVars(json, opt.vars);
    json.children = apply(children, opt, hash);

    if (animate) {
      if (!Array.isArray(animate)) {
        animate = [animate];
      }

      animate.forEach(function (item) {
        opt.abbr !== false && abbr2full(item, abbrAnimate);
        var value = item.value,
            options = item.options; // 忽略空动画

        if (Array.isArray(value) && value.length) {
          value.forEach(function (item) {
            opt.abbr !== false && abbr2full(item, abbrCssProperty);
            replaceVars(item, opt.vars);
          });
        }

        if (options) {
          opt.abbr !== false && abbr2full(options, abbrAnimateOption);
          replaceVars(options, opt.vars);
          replaceAnimateOptions(options, opt);
        }
      });
    }

    return json;
  } // 将library、vars应用于json，转换json为一个普通的原始json数据


  function apply$1 (json) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    // json中定义无abbr
    if (json.abbr === false) {
      options.abbr = false;
    }

    if (options.abbr !== false) {
      inject.warn('Abbr in json is deprecated');
    } // 特殊单例声明无需clone加速解析


    if (!options.singleton && !json.singleton) {
      json = util.clone(json);
    }

    return apply(json, options, {});
  }

  var o = {
    apply: apply$1,
    parse: function parse$1(karas, json, dom, options) {
      if (!json) {
        return;
      } // 根节点的fonts字段定义字体信息


      var fonts = json.fonts;

      if (fonts) {
        if (!Array.isArray(fonts)) {
          fonts = [fonts];
        }

        fonts.forEach(function (item) {
          var fontFamily = item.fontFamily,
              url = item.url,
              data = item.data;

          if (fontFamily && (url || data)) {
            o$3.register(fontFamily, url, data);
          }
        });
      } // 重载，在确定dom传入选择器字符串或html节点对象时作为渲染功能，否则仅创建vd返回


      if (!inject.isDom(dom)) {
        options = options || dom || {};
        dom = null;
      } else {
        options = options || {};
      }

      json = apply$1(json, options); // 暂存所有动画声明，等root的生成后开始执行

      var animateRecords = [];

      var vd = parse(karas, json, animateRecords, options, 0); // 有dom时parse作为根方法渲染


      if (dom) {
        var _json = json,
            tagName = _json.tagName;

        if (['canvas', 'svg', 'webgl'].indexOf(tagName) === -1) {
          throw new Error('Parse dom must be canvas/svg/webgl');
        } // parse直接（非递归）的动画记录


        var ac = options.controller instanceof Controller ? options.controller : vd.animateController; // 第一次render，收集递归json里面的animateRecords，它在xom的__layout最后生成

        karas.render(vd, dom); // 由于vd首先生成的都是json，根parse要特殊处理将target指向真正的vd引用，json的vd在builder中赋值
        // animateRecords.forEach(item => {
        //   item.target = item.target.vd;
        // });
        // 直接的json里的animateRecords，再加上递归的parse的json的（第一次render布局时处理）动画一并播放

        if (options.autoPlay !== false) {
          ac.__records = ac.__records.concat(animateRecords);

          ac.__playAuto();
        } // 不自动播放进入记录列表，初始化并等待手动调用
        else {
          ac.__records2 = ac.__records2.concat(animateRecords);
          ac.init(ac.__records2, ac.list2);
        }
      } // 递归的parse，如果有动画，此时还没root，先暂存下来，等上面的root的render第一次布局时收集
      else {
        if (animateRecords.length) {
          vd.__animateRecords = {
            options: options,
            list: animateRecords,
            controller: options.controller instanceof Controller ? options.controller : null
          };
        }
      }

      return vd;
    },
    loadAndParse: function loadAndParse(karas, json, dom, options) {
      var fonts = json.fonts,
          components = json.components,
          imgs = json.imgs;
      var list1 = [];
      var list2 = [];
      var list3 = [];

      if (fonts) {
        if (!Array.isArray(fonts)) {
          fonts = [fonts];
        }

        fonts.forEach(function (item) {
          var url = item.url;

          if (url) {
            list1.push(item);
          }
        });
      }

      if (components) {
        if (!Array.isArray(components)) {
          components = [components];
        }

        components.forEach(function (item) {
          var tagName = item.tagName,
              url = item.url,
              reload = item.reload; // 如果没申明reload且已经被注册，则无需重复加载

          if (tagName && karas.Component.hasRegister(tagName) && !reload) {
            return;
          } // 即便没有tagName也要加载，可能组件内部执行了注册逻辑


          if (url) {
            list2.push(item);
          }
        });
      }

      if (imgs) {
        if (!Array.isArray(imgs)) {
          imgs = [imgs];
        }

        imgs.forEach(function (item) {
          var url = item.url;

          if (url) {
            list3.push(url);
          }
        });
      }

      var a = list1.length,
          b = list2.length,
          c = list3.length;
      var count = 0;

      var cb = function cb() {
        if (count === a + b + c) {
          var res = o.parse(karas, json, dom, options);

          if (options && util.isFunction(options.callback)) {
            options.callback(res);
          }
        }
      };

      if (a || b || c) {
        karas.inject.loadFont(list1, function () {
          count += a;
          cb();
        });
        karas.inject.loadComponent(list2.map(function (item) {
          return item.url;
        }), function () {
          count += b; // 默认约定加载的js组件会在全局变量申明同名tagName，已有不覆盖，防止组件代码内部本身有register

          list2.forEach(function (item) {
            var tagName = item.tagName;

            if (tagName && window[tagName] && !karas.Component.hasRegister(tagName)) {
              karas.Component.register(tagName, window[tagName]);
            }
          });
          cb();
        });
        karas.inject.measureImg(list3, function () {
          count += c;
          cb();
        });
      } else {
        cb();
      }
    },
    abbr: abbr
  };

  var style = {
    css: css,
    reset: reset,
    unit: o$4,
    font: o$3,
    abbr: abbr$1,
    transform: transform
  };

  var animate = {
    Animation: Animation,
    Controller: Controller,
    easing: easing,
    frame: frame
  };

  var refresh = {
    level: o$1,
    change: o$2,
    Page: Page,
    Cache: Cache
  };

  var version = "0.79.1";

  Geom.register('$line', Line);
  Geom.register('$polyline', Polyline);
  Geom.register('$polygon', Polygon);
  Geom.register('$sector', Sector);
  Geom.register('$rect', Rect);
  Geom.register('$circle', Circle);
  Geom.register('$ellipse', Ellipse);
  var karas$1 = {
    version: version,
    render: function render(root, dom) {
      if (!(root instanceof Root)) {
        throw new Error('Render dom must be canvas/svg/webgl');
      }

      if (dom) {
        root.appendTo(dom);
      }

      return root;
    },
    createElement: function createElement(tagName, props) {
      props = props || {};
      var children = [];

      for (var i = 2, len = arguments.length; i < len; i++) {
        children.push(arguments[i]);
      }

      if (util.isString(tagName)) {
        if (tagName.charAt(0) === '$') {
          return this.createGm(tagName, props);
        } else {
          return this.createVd(tagName, props, children);
        }
      } else if (tagName) {
        // 特殊的$匿名类
        if (tagName instanceof Geom) {
          return this.createGm(tagName, props);
        }

        return this.createCp(tagName, props, children);
      }
    },
    createVd: function createVd(tagName, props) {
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      if (['canvas', 'svg', 'webgl'].indexOf(tagName) > -1) {
        return new Root(tagName, props, children);
      }

      if (tag.TAG_NAME.hasOwnProperty(tagName)) {
        if (tagName === 'img') {
          return new Img(tagName, props);
        } else {
          return new Dom(tagName, props, children);
        } // return {
        //   tagName,
        //   props,
        //   children,
        //   $$type: $$type.TYPE_VD,
        // };

      }

      throw new Error("Can not use <".concat(tagName, ">"));
    },
    createGm: function createGm(tagName, props) {
      var klass = Geom.getRegister(tagName);
      return new klass(tagName, props); // return {
      //   tagName,
      //   props,
      //   $$type: $$type.TYPE_GM,
      // };
    },
    createCp: function createCp(klass, props) {
      var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      props.children = children;
      return new klass(props, children); // return {
      //   klass,
      //   props,
      //   $$type: $$type.TYPE_CP,
      // };
    },
    parse: function parse(json, dom, options) {
      return o.parse(this, json, dom, options);
    },
    loadAndParse: function loadAndParse(json, dom, options) {
      return o.loadAndParse(this, json, dom, options);
    },
    mode: mode,
    Component: Component,
    Node: Node,
    Text: Text,
    Geom: Geom,
    Xom: Xom,
    Dom: Dom,
    Img: Img,
    Root: Root,
    Event: Event,
    util: util,
    inject: inject,
    style: style,
    parser: o,
    animate: animate,
    math: math,
    updater: updater,
    refresh: refresh,
    enums: enums,

    set debug(v) {
      debug.flag = !!v;
    }

  };

  if (typeof window !== 'undefined') {
    window.karas = karas$1;
  } else if (typeof self !== 'undefined') {
    self.karas = karas$1;
  }

  return karas$1;

}));
//# sourceMappingURL=index.js.map
